---
title: "装饰器模式（Decorator Pattern）"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 装饰器模式（Decorator Pattern）

## 概述

装饰器模式是一种结构型设计模式，它允许你通过将对象放入包含行为的特殊封装对象中来为原对象动态地添加新的行为。装饰器模式提供了子类继承之外的另一种灵活的方式来扩展对象的功能。

## 使用场景

- 需要在运行时动态地给对象添加额外的职责时
- 不想使用继承来扩展对象的功能时
- 需要保持类的开放-封闭原则时
- 需要动态地撤销对象的功能时

## 基本实现

```java
// 抽象组件
interface Component {
    void operation();
}

// 具体组件
class ConcreteComponent implements Component {
    @Override
    public void operation() {
        System.out.println("具体组件的基础功能");
    }
}

// 抽象装饰器
abstract class Decorator implements Component {
    protected Component component;

    public Decorator(Component component) {
        this.component = component;
    }

    @Override
    public void operation() {
        component.operation();
    }
}

// 具体装饰器A
class ConcreteDecoratorA extends Decorator {
    public ConcreteDecoratorA(Component component) {
        super(component);
    }

    @Override
    public void operation() {
        super.operation();
        addedBehavior();
    }

    private void addedBehavior() {
        System.out.println("装饰器A添加的功能");
    }
}

// 具体装饰器B
class ConcreteDecoratorB extends Decorator {
    public ConcreteDecoratorB(Component component) {
        super(component);
    }

    @Override
    public void operation() {
        super.operation();
        addedBehavior();
    }

    private void addedBehavior() {
        System.out.println("装饰器B添加的功能");
    }
}
```

## 实际应用示例

以咖啡订单系统为例：

```java
// 饮料抽象类
abstract class Beverage {
    protected String description = "未知饮料";

    public String getDescription() {
        return description;
    }

    public abstract double cost();
}

// 具体饮料：浓缩咖啡
class Espresso extends Beverage {
    public Espresso() {
        description = "浓缩咖啡";
    }

    @Override
    public double cost() {
        return 15.0;
    }
}

// 具体饮料：美式咖啡
class Americano extends Beverage {
    public Americano() {
        description = "美式咖啡";
    }

    @Override
    public double cost() {
        return 18.0;
    }
}

// 调料装饰器抽象类
abstract class CondimentDecorator extends Beverage {
    protected Beverage beverage;

    public abstract String getDescription();
}

// 具体调料：牛奶
class Milk extends CondimentDecorator {
    public Milk(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + " + 牛奶";
    }

    @Override
    public double cost() {
        return beverage.cost() + 5.0;
    }
}

// 具体调料：摩卡
class Mocha extends CondimentDecorator {
    public Mocha(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + " + 摩卡";
    }

    @Override
    public double cost() {
        return beverage.cost() + 8.0;
    }
}

// 使用示例
public class CoffeeShop {
    public static void main(String[] args) {
        // 订购一杯浓缩咖啡
        Beverage beverage1 = new Espresso();
        System.out.println(beverage1.getDescription() + " ￥" + beverage1.cost());

        // 订购一杯加牛奶和摩卡的美式咖啡
        Beverage beverage2 = new Americano();
        beverage2 = new Milk(beverage2);
        beverage2 = new Mocha(beverage2);
        System.out.println(beverage2.getDescription() + " ￥" + beverage2.cost());
    }
}
```

## 另一个实际示例：数据流处理

```java
// 基础数据流接口
interface DataSource {
    void writeData(String data);
    String readData();
}

// 具体文件数据源
class FileDataSource implements DataSource {
    private String filename;

    public FileDataSource(String filename) {
        this.filename = filename;
    }

    @Override
    public void writeData(String data) {
        System.out.println("写入文件: " + data);
    }

    @Override
    public String readData() {
        return "从文件读取的数据";
    }
}

// 加密装饰器
class EncryptionDecorator implements DataSource {
    private DataSource wrappee;

    public EncryptionDecorator(DataSource source) {
        this.wrappee = source;
    }

    @Override
    public void writeData(String data) {
        // 加密数据
        String encryptedData = encrypt(data);
        wrappee.writeData(encryptedData);
    }

    @Override
    public String readData() {
        // 解密数据
        String data = wrappee.readData();
        return decrypt(data);
    }

    private String encrypt(String data) {
        // 加密逻辑
        return "加密(" + data + ")";
    }

    private String decrypt(String data) {
        // 解密逻辑
        return "解密(" + data + ")";
    }
}

// 压缩装饰器
class CompressionDecorator implements DataSource {
    private DataSource wrappee;

    public CompressionDecorator(DataSource source) {
        this.wrappee = source;
    }

    @Override
    public void writeData(String data) {
        // 压缩数据
        String compressedData = compress(data);
        wrappee.writeData(compressedData);
    }

    @Override
    public String readData() {
        // 解压数据
        String data = wrappee.readData();
        return decompress(data);
    }

    private String compress(String data) {
        // 压缩逻辑
        return "压缩(" + data + ")";
    }

    private String decompress(String data) {
        // 解压逻辑
        return "解压(" + data + ")";
    }
}
```

## 优点

1. 比继承更灵活，可以动态地添加或删除职责
2. 遵循开闭原则，不需要修改现有代码就可以扩展对象的功能
3. 可以用多个装饰器来组合功能
4. 可以在运行时动态地添加或删除功能

## 缺点

1. 可能会产生很多小对象，增加系统的复杂度
2. 装饰器模式比继承更加灵活，但也更加难以理解
3. 装饰器的顺序可能会影响最终结果

## 适用场景

1. 需要在不影响其他对象的情况下，动态地给单个对象添加职责
2. 不适合使用继承来扩展功能的场景
3. 需要动态地组合多个功能的场景
4. 系统中存在大量独立的扩展功能

## 注意事项

1. 装饰器应该保持良好的可组合性
2. 注意装饰顺序可能带来的影响
3. 避免装饰器类的过度使用
4. 确保装饰器和被装饰对象有相同的接口

