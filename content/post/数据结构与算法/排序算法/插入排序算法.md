---
title: "插入排序（Insertion Sort）"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 插入排序（Insertion Sort）

## 1. 算法思想
插入排序的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。就像我们打扑克牌时的理牌过程：
1. **初始状态**：第一张牌已经排好序
2. **插入过程**：从第二张牌开始，将每一张牌插入到已经排好序的牌中的适当位置
3. **完成排序**：直到所有牌都插入完毕

## 2. 图解过程

```mermaid
graph TD
    A[初始数组: 5,2,4,6,1,3] --> B[第一步: 5|2,4,6,1,3]
    B --> C[第二步: 2,5|4,6,1,3]
    C --> D[第三步: 2,4,5|6,1,3]
    D --> E[第四步: 2,4,5,6|1,3]
    E --> F[第五步: 1,2,4,5,6|3]
    F --> G[最终: 1,2,3,4,5,6]
    
    style A fill:#f9f,stroke:#333,stroke-width:4px
    style G fill:#9ff,stroke:#333,stroke-width:4px
```

## 3. 代码实现

```java
public class InsertionSort {
    public void sort(int[] arr) {
        int n = arr.length;
        
        for (int i = 1; i < n; i++) {
            // 当前要插入的元素
            int key = arr[i];
            // 已排序区间的最后一个位置
            int j = i - 1;
            
            // 从后向前扫描已排序区间，找到插入位置
            while (j >= 0 && arr[j] > key) {
                // 将大于key的元素都向后移动一位
                arr[j + 1] = arr[j];
                j--;
            }
            
            // 插入元素
            arr[j + 1] = key;
        }
    }

    // 测试代码
    public static void main(String[] args) {
        int[] arr = {5, 2, 4, 6, 1, 3};
        InsertionSort insertionSort = new InsertionSort();

        System.out.println("排序前：");
        printArray(arr);

        insertionSort.sort(arr);

        System.out.println("\n排序后：");
        printArray(arr);
    }

    private static void printArray(int[] arr) {
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}
```

## 4. 算法分析

### 4.1 时间复杂度
- **最好情况**：O(n)，数组已经有序
- **最坏情况**：O(n²)，数组完全逆序
- **平均情况**：O(n²)

### 4.2 空间复杂度
- O(1)：只需要常数级的额外空间

### 4.3 稳定性
- 稳定排序：相同元素的相对位置不会改变

## 5. 优缺点

### 5.1 优点
1. 实现简单，容易理解
2. 对于小规模数据，性能较好
3. 是稳定的排序算法
4. 对于近乎有序的数据，效率很高

### 5.2 缺点
1. 对于大规模数据，性能不佳
2. 平均时间复杂度较高

## 6. 应用场景

1. **小规模数据排序**：当数据量较小时（通常小于50个元素）
2. **近乎有序的数据**：当数据已经接近有序状态
3. **作为其他排序算法的子过程**：如快速排序的优化

## 7. 优化方案

### 7.1 二分查找优化

```java
public class OptimizedInsertionSort {
    public void binaryInsertionSort(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            int key = arr[i];
            int left = 0;
            int right = i - 1;
            
            // 使用二分查找找到插入位置
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (arr[mid] > key) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
            
            // 将元素后移
            for (int j = i - 1; j >= left; j--) {
                arr[j + 1] = arr[j];
            }
            
            arr[left] = key;
        }
    }
}
```

### 7.2 希尔排序（插入排序的改进版）

```java
public class ShellSort {
    public void sort(int[] arr) {
        int n = arr.length;
        
        // 初始间隔
        for (int gap = n/2; gap > 0; gap /= 2) {
            // 对每个间隔进行插入排序
            for (int i = gap; i < n; i++) {
                int temp = arr[i];
                int j;
                
                for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                    arr[j] = arr[j - gap];
                }
                
                arr[j] = temp;
            }
        }
    }
}
```

## 8. 代码示例（优化版）

```java
public class EnhancedInsertionSort {
    private static final int BINARY_SORT_THRESHOLD = 47; // 使用二分查找的阈值
    
    public void sort(int[] arr) {
        if (arr == null || arr.length <= 1) {
            return;
        }
        
        // 对于较大数组使用希尔排序
        if (arr.length > BINARY_SORT_THRESHOLD) {
            shellSort(arr);
        } else {
            // 对于小数组使用二分插入排序
            binaryInsertionSort(arr);
        }
    }
    
    private void shellSort(int[] arr) {
        int n = arr.length;
        int gap = 1;
        
        // 计算初始间隔
        while (gap < n/3) {
            gap = 3 * gap + 1;
        }
        
        while (gap >= 1) {
            for (int i = gap; i < n; i++) {
                for (int j = i; j >= gap && arr[j] < arr[j-gap]; j -= gap) {
                    swap(arr, j, j-gap);
                }
            }
            gap /= 3;
        }
    }
    
    private void binaryInsertionSort(int[] arr) {
        for (int i = 1; i < arr.length; i++) {
            int key = arr[i];
            int insertIndex = binarySearch(arr, 0, i-1, key);
            
            // 移动元素
            System.arraycopy(arr, insertIndex, arr, insertIndex + 1, i - insertIndex);
            arr[insertIndex] = key;
        }
    }
    
    private int binarySearch(int[] arr, int left, int right, int key) {
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (arr[mid] > key) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
    
    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

## 9. 总结

插入排序是一种简单但实用的排序算法，它的主要特点是：

1. **简单直观**：算法的思想非常容易理解和实现
2. **适应性强**：对于小规模或近乎有序的数据集表现优秀
3. **稳定性好**：可以保持相同元素的相对顺序
4. **原地排序**：只需要常数级的额外空间

通过优化（如二分查找、希尔排序等），可以显著提高插入排序的性能。在实际应用中，插入排序常用于小规模数据的排序，或作为其他高级排序算法的子过程。它的简单性和对近乎有序数据的高效性使它在特定场景下仍然具有重要价值。
