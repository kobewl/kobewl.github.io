---
title: "中介者模式（Mediator Pattern）"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 中介者模式（Mediator Pattern）

## 概述

中介者模式是一种行为型设计模式，它通过封装一系列对象之间的交互，使得这些对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式将多对多的关系转换为一对多的关系，降低了系统的复杂度。

## 使用场景

- 一组对象之间存在复杂的通信方式时
- 对象之间存在大量的相互依赖关系，导致难以复用某个对象时
- 想要集中管理对象之间的交互时
- 多个类相互耦合形成网状结构时

## 基本实现

```java
// 抽象中介者
interface Mediator {
    void register(Colleague colleague);
    void relay(Colleague colleague, String message);
}

// 抽象同事类
abstract class Colleague {
    protected Mediator mediator;
    protected String name;

    public Colleague(String name, Mediator mediator) {
        this.name = name;
        this.mediator = mediator;
    }

    public abstract void receive(String message);
    public abstract void send(String message);
}

// 具体中介者
class ConcreteMediator implements Mediator {
    private List<Colleague> colleagues = new ArrayList<>();

    @Override
    public void register(Colleague colleague) {
        if (!colleagues.contains(colleague)) {
            colleagues.add(colleague);
        }
    }

    @Override
    public void relay(Colleague sender, String message) {
        for (Colleague colleague : colleagues) {
            if (!colleague.equals(sender)) {
                colleague.receive(message);
            }
        }
    }
}

// 具体同事类A
class ConcreteColleagueA extends Colleague {
    public ConcreteColleagueA(String name, Mediator mediator) {
        super(name, mediator);
    }

    @Override
    public void receive(String message) {
        System.out.println(name + "收到消息: " + message);
    }

    @Override
    public void send(String message) {
        System.out.println(name + "发送消息: " + message);
        mediator.relay(this, message);
    }
}

// 具体同事类B
class ConcreteColleagueB extends Colleague {
    public ConcreteColleagueB(String name, Mediator mediator) {
        super(name, mediator);
    }

    @Override
    public void receive(String message) {
        System.out.println(name + "收到消息: " + message);
    }

    @Override
    public void send(String message) {
        System.out.println(name + "发送消息: " + message);
        mediator.relay(this, message);
    }
}
```

## 实际应用示例

以聊天室系统为例：

```java
// 聊天室中介者接口
interface ChatMediator {
    void sendMessage(String message, User user);
    void addUser(User user);
}

// 用户抽象类
abstract class User {
    protected ChatMediator mediator;
    protected String name;

    public User(String name, ChatMediator mediator) {
        this.name = name;
        this.mediator = mediator;
    }

    public abstract void send(String message);
    public abstract void receive(String message);
}

// 聊天室具体中介者
class ChatRoom implements ChatMediator {
    private List<User> users;

    public ChatRoom() {
        this.users = new ArrayList<>();
    }

    @Override
    public void addUser(User user) {
        users.add(user);
    }

    @Override
    public void sendMessage(String message, User sender) {
        for (User user : users) {
            // 消息不发送给发送者自己
            if (user != sender) {
                user.receive(message);
            }
        }
    }
}

// 普通用户
class NormalUser extends User {
    public NormalUser(String name, ChatMediator mediator) {
        super(name, mediator);
    }

    @Override
    public void send(String message) {
        System.out.println(name + " 发送消息: " + message);
        mediator.sendMessage(message, this);
    }

    @Override
    public void receive(String message) {
        System.out.println(name + " 收到消息: " + message);
    }
}

// 管理员用户
class AdminUser extends User {
    public AdminUser(String name, ChatMediator mediator) {
        super(name, mediator);
    }

    @Override
    public void send(String message) {
        System.out.println("管理员 " + name + " 发送消息: " + message);
        mediator.sendMessage("[管理员消息] " + message, this);
    }

    @Override
    public void receive(String message) {
        System.out.println("管理员 " + name + " 收到消息: " + message);
    }
}
```

## 另一个实际示例：航空管制系统

```java
// 航空管制中介者接口
interface AirTrafficController {
    void registerFlight(Flight flight);
    void requestLanding(Flight flight);
    void requestTakeoff(Flight flight);
}

// 航班抽象类
abstract class Flight {
    protected String flightNumber;
    protected AirTrafficController controller;

    public Flight(String flightNumber, AirTrafficController controller) {
        this.flightNumber = flightNumber;
        this.controller = controller;
    }

    public abstract void requestLanding();
    public abstract void requestTakeoff();
    public abstract void receiveMessage(String message);
}

// 航空管制中心
class ControlTower implements AirTrafficController {
    private List<Flight> flights;
    private Queue<Flight> landingQueue;
    private Queue<Flight> takeoffQueue;

    public ControlTower() {
        this.flights = new ArrayList<>();
        this.landingQueue = new LinkedList<>();
        this.takeoffQueue = new LinkedList<>();
    }

    @Override
    public void registerFlight(Flight flight) {
        flights.add(flight);
    }

    @Override
    public void requestLanding(Flight flight) {
        landingQueue.offer(flight);
        processLandingQueue();
    }

    @Override
    public void requestTakeoff(Flight flight) {
        takeoffQueue.offer(flight);
        processTakeoffQueue();
    }

    private void processLandingQueue() {
        if (!landingQueue.isEmpty()) {
            Flight flight = landingQueue.poll();
            flight.receiveMessage("着陆请求已批准，可以开始降落。");
        }
    }

    private void processTakeoffQueue() {
        if (!takeoffQueue.isEmpty()) {
            Flight flight = takeoffQueue.poll();
            flight.receiveMessage("起飞请求已批准，可以开始起飞。");
        }
    }
}

// 客机
class PassengerFlight extends Flight {
    public PassengerFlight(String flightNumber, AirTrafficController controller) {
        super(flightNumber, controller);
    }

    @Override
    public void requestLanding() {
        System.out.println("客机 " + flightNumber + " 请求着陆");
        controller.requestLanding(this);
    }

    @Override
    public void requestTakeoff() {
        System.out.println("客机 " + flightNumber + " 请求起飞");
        controller.requestTakeoff(this);
    }

    @Override
    public void receiveMessage(String message) {
        System.out.println("客机 " + flightNumber + " 收到消息: " + message);
    }
}

// 货机
class CargoFlight extends Flight {
    public CargoFlight(String flightNumber, AirTrafficController controller) {
        super(flightNumber, controller);
    }

    @Override
    public void requestLanding() {
        System.out.println("货机 " + flightNumber + " 请求着陆");
        controller.requestLanding(this);
    }

    @Override
    public void requestTakeoff() {
        System.out.println("货机 " + flightNumber + " 请求起飞");
        controller.requestTakeoff(this);
    }

    @Override
    public void receiveMessage(String message) {
        System.out.println("货机 " + flightNumber + " 收到消息: " + message);
    }
}
```

## 优点

1. 减少了对象之间的相互依赖，降低了系统的耦合度
2. 将对象之间的一对多关联转变为一对一的关联
3. 集中控制对象之间的交互
4. 使系统更容易维护和扩展

## 缺点

1. 中介者可能会变得过于复杂
2. 如果同事对象太多，中介者的职责会过重
3. 把对象之间的交互复杂性转移到了中介者中

## 适用场景

1. 系统中对象之间存在复杂的引用关系
2. 一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象
3. 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类

## 注意事项

1. 不要让中介者承担太多责任
2. 注意中介者和观察者模式的结合使用
3. 在设计中介者时要考虑系统的可扩展性
4. 当系统出现了"多对多"交互复杂的对象群时，先考虑使用中介者模式

