---
title: "分布式服务"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 分布式服务

## 服务注册与发现

### 概述

服务注册与发现是微服务架构中的关键组件，用于管理服务实例的注册、发现和健康监控。

### 主流实现方案

1. **Eureka**

```java
// 服务注册
@EnableEurekaClient
public class ServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(ServiceApplication.class, args);
    }
}

// 服务配置
eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8761/eureka/
```

2. **Nacos**

```java
// 服务注册
@NacosPropertySource(dataId = "example", autoRefreshed = true)
public class NacosConfig {
    @NacosValue(value = "${service.name:default}", autoRefreshed = true)
    private String serviceName;
}
```

3. **Zookeeper**

```java
// 服务注册
public class ServiceRegistry {
    private ZooKeeper zk;

    public void register(String serviceName, String serviceAddress) {
        String path = "/services/" + serviceName;
        zk.create(path, serviceAddress.getBytes(),
                 ZooDefs.Ids.OPEN_ACL_UNSAFE,
                 CreateMode.EPHEMERAL);
    }
}
```

## 负载均衡

### 常见算法

1. **轮询（Round Robin）**

```java
public class RoundRobinLoadBalancer {
    private AtomicInteger position = new AtomicInteger(0);
    private List<Server> servers;

    public Server getServer() {
        if (servers.isEmpty()) {
            return null;
        }
        int pos = position.incrementAndGet() % servers.size();
        return servers.get(pos);
    }
}
```

2. **加权轮询**

```java
public class WeightedRoundRobinLoadBalancer {
    private List<WeightedServer> servers;

    public Server getServer() {
        int totalWeight = servers.stream()
                                .mapToInt(WeightedServer::getWeight)
                                .sum();
        int pos = random.nextInt(totalWeight);

        for (WeightedServer server : servers) {
            if (pos < server.getWeight()) {
                return server;
            }
            pos -= server.getWeight();
        }
        return null;
    }
}
```

3. **最小连接数**

```java
public class LeastConnectionLoadBalancer {
    private List<ServerStats> servers;

    public Server getServer() {
        return servers.stream()
                     .min(Comparator.comparingInt(ServerStats::getActiveConnections))
                     .map(ServerStats::getServer)
                     .orElse(null);
    }
}
```

## 服务熔断与降级

### 熔断器模式

```java
// Hystrix示例
@HystrixCommand(fallbackMethod = "fallback",
    commandProperties = {
        @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold", value = "20"),
        @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage", value = "50"),
        @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds", value = "5000")
    })
public String serviceMethod() {
    // 正常服务逻辑
}

public String fallback() {
    // 降级逻辑
    return "Service Degraded";
}
```

### 服务降级策略

1. **限流降级**

```java
// 令牌桶算法实现
public class RateLimiter {
    private long capacity;
    private long tokens;
    private long lastRefillTime;
    private long refillRate;

    public synchronized boolean tryAcquire() {
        refill();
        if (tokens > 0) {
            tokens--;
            return true;
        }
        return false;
    }

    private void refill() {
        long now = System.currentTimeMillis();
        long newTokens = (now - lastRefillTime) * refillRate / 1000;
        tokens = Math.min(capacity, tokens + newTokens);
        lastRefillTime = now;
    }
}
```

2. **服务降级**

```java
public class ServiceDegrader {
    private Map<String, DegradeRule> rules;

    public Response processRequest(Request request) {
        DegradeRule rule = rules.get(request.getServiceName());
        if (rule.shouldDegrade()) {
            return getDegradedResponse(request);
        }
        return processNormally(request);
    }

    private Response getDegradedResponse(Request request) {
        // 返回降级响应
        return new Response().setStatus(Status.DEGRADED);
    }
}
```

## 服务网关

### 功能特性

1. **路由转发**

```java
// Spring Cloud Gateway配置
spring:
  cloud:
    gateway:
      routes:
      - id: example_route
        uri: lb://example-service
        predicates:
        - Path=/example/**
        filters:
        - StripPrefix=1
```

2. **认证授权**

```java
public class AuthFilter implements GlobalFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange,
                            GatewayFilterChain chain) {
        String token = exchange.getRequest()
                             .getHeaders()
                             .getFirst("Authorization");
        if (isValidToken(token)) {
            return chain.filter(exchange);
        }
        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
        return exchange.getResponse().setComplete();
    }
}
```

3. **限流控制**

```java
// Sentinel限流配置
@SentinelResource(value = "resourceName",
                 blockHandler = "blockHandlerMethod")
public String methodName() {
    // 业务逻辑
}

public String blockHandlerMethod(BlockException ex) {
    // 限流处理逻辑
    return "Rate limited";
}
```

## 最佳实践

1. **服务注册发现**

   - 使用合适的注册中心
   - 实现健康检查
   - 优雅上下线

2. **负载均衡**

   - 选择合适的负载均衡策略
   - 考虑服务器性能差异
   - 动态调整权重

3. **熔断降级**

   - 合理的熔断阈值
   - 降级策略的优先级
   - 监控和告警

4. **网关设计**
   - 统一的认证授权
   - 请求限流和过滤
   - 日志监控

