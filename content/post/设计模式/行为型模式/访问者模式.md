---
title: "访问者模式（Visitor Pattern）"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 访问者模式（Visitor Pattern）

## 概述

访问者模式是一种行为型设计模式，它允许你在不改变已有类的情况下，定义作用于这些类的新操作。访问者模式通过将数据结构和数据操作分离，使得我们可以在不修改数据结构的情况下，增加新的操作。

## 使用场景

- 对象结构中的元素类型固定，但经常需要在这些元素上定义新的操作
- 需要对一个对象结构中的对象进行很多不同且不相关的操作
- 需要在不同时间对同一个对象结构进行不同的操作
- 数据结构相对稳定，但其操作经常变化

## 基本实现

```java
// 访问者接口
interface Visitor {
    void visit(ConcreteElementA element);
    void visit(ConcreteElementB element);
}

// 元素接口
interface Element {
    void accept(Visitor visitor);
}

// 具体元素A
class ConcreteElementA implements Element {
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }

    public String operationA() {
        return "ConcreteElementA";
    }
}

// 具体元素B
class ConcreteElementB implements Element {
    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }

    public String operationB() {
        return "ConcreteElementB";
    }
}

// 具体访问者1
class ConcreteVisitor1 implements Visitor {
    @Override
    public void visit(ConcreteElementA element) {
        System.out.println("访问者1访问" + element.operationA());
    }

    @Override
    public void visit(ConcreteElementB element) {
        System.out.println("访问者1访问" + element.operationB());
    }
}

// 具体访问者2
class ConcreteVisitor2 implements Visitor {
    @Override
    public void visit(ConcreteElementA element) {
        System.out.println("访问者2访问" + element.operationA());
    }

    @Override
    public void visit(ConcreteElementB element) {
        System.out.println("访问者2访问" + element.operationB());
    }
}

// 对象结构
class ObjectStructure {
    private List<Element> elements = new ArrayList<>();

    public void attach(Element element) {
        elements.add(element);
    }

    public void detach(Element element) {
        elements.remove(element);
    }

    public void accept(Visitor visitor) {
        for (Element element : elements) {
            element.accept(visitor);
        }
    }
}
```

## 实际应用示例

以文件系统为例：

```java
// 文件系统元素接口
interface FileSystemElement {
    void accept(FileVisitor visitor);
}

// 文件访问者接口
interface FileVisitor {
    void visit(File file);
    void visit(Directory directory);
}

// 文件类
class File implements FileSystemElement {
    private String name;
    private int size;

    public File(String name, int size) {
        this.name = name;
        this.size = size;
    }

    public String getName() { return name; }
    public int getSize() { return size; }

    @Override
    public void accept(FileVisitor visitor) {
        visitor.visit(this);
    }
}

// 目录类
class Directory implements FileSystemElement {
    private String name;
    private List<FileSystemElement> elements = new ArrayList<>();

    public Directory(String name) {
        this.name = name;
    }

    public String getName() { return name; }
    public List<FileSystemElement> getElements() { return elements; }

    public void addElement(FileSystemElement element) {
        elements.add(element);
    }

    @Override
    public void accept(FileVisitor visitor) {
        visitor.visit(this);
        // 递归访问子元素
        for (FileSystemElement element : elements) {
            element.accept(visitor);
        }
    }
}

// 大小计算访问者
class SizeCalculatorVisitor implements FileVisitor {
    private int totalSize = 0;

    @Override
    public void visit(File file) {
        totalSize += file.getSize();
    }

    @Override
    public void visit(Directory directory) {
        // 目录本身不占用空间
    }

    public int getTotalSize() {
        return totalSize;
    }
}

// 文件搜索访问者
class FileSearchVisitor implements FileVisitor {
    private String searchPattern;
    private List<File> matchedFiles = new ArrayList<>();

    public FileSearchVisitor(String searchPattern) {
        this.searchPattern = searchPattern;
    }

    @Override
    public void visit(File file) {
        if (file.getName().contains(searchPattern)) {
            matchedFiles.add(file);
        }
    }

    @Override
    public void visit(Directory directory) {
        // 不搜索目录名
    }

    public List<File> getMatchedFiles() {
        return matchedFiles;
    }
}
```

## 另一个实际示例：员工薪资系统

```java
// 员工接口
interface Employee {
    void accept(EmployeeVisitor visitor);
}

// 正式员工
class FullTimeEmployee implements Employee {
    private String name;
    private double monthlySalary;
    private int workingDays;

    public FullTimeEmployee(String name, double monthlySalary, int workingDays) {
        this.name = name;
        this.monthlySalary = monthlySalary;
        this.workingDays = workingDays;
    }

    public String getName() { return name; }
    public double getMonthlySalary() { return monthlySalary; }
    public int getWorkingDays() { return workingDays; }

    @Override
    public void accept(EmployeeVisitor visitor) {
        visitor.visit(this);
    }
}

// 兼职员工
class PartTimeEmployee implements Employee {
    private String name;
    private double hourlyRate;
    private int workingHours;

    public PartTimeEmployee(String name, double hourlyRate, int workingHours) {
        this.name = name;
        this.hourlyRate = hourlyRate;
        this.workingHours = workingHours;
    }

    public String getName() { return name; }
    public double getHourlyRate() { return hourlyRate; }
    public int getWorkingHours() { return workingHours; }

    @Override
    public void accept(EmployeeVisitor visitor) {
        visitor.visit(this);
    }
}

// 员工访问者接口
interface EmployeeVisitor {
    void visit(FullTimeEmployee employee);
    void visit(PartTimeEmployee employee);
}

// 薪资计算访问者
class PayrollVisitor implements EmployeeVisitor {
    @Override
    public void visit(FullTimeEmployee employee) {
        double salary = employee.getMonthlySalary() *
            (employee.getWorkingDays() / 22.0); // 假设一个月22个工作日
        System.out.println(employee.getName() + " 的薪资为: " + salary);
    }

    @Override
    public void visit(PartTimeEmployee employee) {
        double salary = employee.getHourlyRate() * employee.getWorkingHours();
        System.out.println(employee.getName() + " 的薪资为: " + salary);
    }
}

// 考勤统计访问者
class AttendanceVisitor implements EmployeeVisitor {
    @Override
    public void visit(FullTimeEmployee employee) {
        System.out.println(employee.getName() + " 本月工作天数: " +
            employee.getWorkingDays() + "天");
    }

    @Override
    public void visit(PartTimeEmployee employee) {
        System.out.println(employee.getName() + " 本月工作时长: " +
            employee.getWorkingHours() + "小时");
    }
}
```

## 优点

1. 符合单一职责原则，将数据结构与数据操作分离
2. 可以在不修改现有类的情况下，增加新的操作
3. 使得相关的操作可以集中在一起，而不是分散在各个类中
4. 访问者模式适用于数据结构相对稳定的系统

## 缺点

1. 增加新的元素类很困难，需要修改所有的访问者
2. 破坏了封装性，因为访问者需要访问元素的内部状态
3. 违反了依赖倒置原则，因为具体元素需要依赖具体访问者
4. 可能导致系统变得复杂

## 适用场景

1. 对象结构中的元素类型固定不变，但需要经常定义新的操作
2. 需要对一个对象结构中的对象进行很多不同且不相关的操作
3. 数据结构稳定，但操作经常变化的系统
4. 需要跨越多个不同的类层次结构的对象进行操作

## 注意事项

1. 在使用访问者模式之前，要确保对象结构相对稳定
2. 注意访问者模式可能会破坏封装性
3. 当需要添加新的元素类时要慎重考虑
4. 可以结合组合模式一起使用，来访问复杂的对象结构

