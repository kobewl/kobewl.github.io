---
title: "桥接模式（Bridge Pattern）"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 桥接模式（Bridge Pattern）

## 概述

桥接模式是一种结构型设计模式，它将抽象部分与其实现部分分离，使它们都可以独立地变化。这种模式通过组合的方式来替代继承，降低了抽象和实现这两个可变维度的耦合度。

## 使用场景

- 需要在多个维度上扩展一个类时
- 需要在运行时切换不同的实现时
- 需要将一个类的接口与其实现分离时
- 需要跨平台开发时

## 结构示例

```java
// 实现接口
interface DrawAPI {
    void drawCircle(int x, int y, int radius);
    void drawRectangle(int x, int y, int width, int height);
}

// 具体实现类A
class DrawingAPI1 implements DrawAPI {
    @Override
    public void drawCircle(int x, int y, int radius) {
        System.out.println("API1 drawing circle at (" + x + "," + y + ") with radius " + radius);
    }

    @Override
    public void drawRectangle(int x, int y, int width, int height) {
        System.out.println("API1 drawing rectangle at (" + x + "," + y + ") with width " + width + " and height " + height);
    }
}

// 具体实现类B
class DrawingAPI2 implements DrawAPI {
    @Override
    public void drawCircle(int x, int y, int radius) {
        System.out.println("API2 drawing circle at (" + x + "," + y + ") with radius " + radius);
    }

    @Override
    public void drawRectangle(int x, int y, int width, int height) {
        System.out.println("API2 drawing rectangle at (" + x + "," + y + ") with width " + width + " and height " + height);
    }
}

// 抽象类
abstract class Shape {
    protected DrawAPI drawAPI;

    protected Shape(DrawAPI drawAPI) {
        this.drawAPI = drawAPI;
    }

    abstract void draw();
}

// 扩展抽象类Circle
class Circle extends Shape {
    private int x, y, radius;

    public Circle(int x, int y, int radius, DrawAPI drawAPI) {
        super(drawAPI);
        this.x = x;
        this.y = y;
        this.radius = radius;
    }

    @Override
    void draw() {
        drawAPI.drawCircle(x, y, radius);
    }
}

// 扩展抽象类Rectangle
class Rectangle extends Shape {
    private int x, y, width, height;

    public Rectangle(int x, int y, int width, int height, DrawAPI drawAPI) {
        super(drawAPI);
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    @Override
    void draw() {
        drawAPI.drawRectangle(x, y, width, height);
    }
}
```

## 实际应用示例

以消息发送系统为例：

```java
// 消息实现接口
interface MessageImplementor {
    void send(String message, String toUser);
}

// 普通消息实现
class NormalMessage implements MessageImplementor {
    @Override
    public void send(String message, String toUser) {
        System.out.println("使用普通消息发送: " + message + " 到 " + toUser);
    }
}

// 加急消息实现
class UrgentMessage implements MessageImplementor {
    @Override
    public void send(String message, String toUser) {
        System.out.println("使用加急消息发送: " + message + " 到 " + toUser);
    }
}

// 抽象消息类
abstract class AbstractMessage {
    protected MessageImplementor implementor;

    public AbstractMessage(MessageImplementor implementor) {
        this.implementor = implementor;
    }

    abstract void sendMessage(String message, String toUser);
}

// 普通消息类型
class CommonMessage extends AbstractMessage {
    public CommonMessage(MessageImplementor implementor) {
        super(implementor);
    }

    @Override
    void sendMessage(String message, String toUser) {
        // 可以在这里添加普通消息的处理逻辑
        System.out.println("发送普通消息:");
        implementor.send(message, toUser);
    }
}

// 短信消息类型
class SMSMessage extends AbstractMessage {
    public SMSMessage(MessageImplementor implementor) {
        super(implementor);
    }

    @Override
    void sendMessage(String message, String toUser) {
        // 可以在这里添加短信特有的处理逻辑
        System.out.println("发送短信消息:");
        implementor.send(message, toUser);
    }
}

// 使用示例
public class BridgeDemo {
    public static void main(String[] args) {
        MessageImplementor normalImplementor = new NormalMessage();
        MessageImplementor urgentImplementor = new UrgentMessage();

        AbstractMessage commonMessage = new CommonMessage(normalImplementor);
        commonMessage.sendMessage("Hello", "张三");

        AbstractMessage urgentCommonMessage = new CommonMessage(urgentImplementor);
        urgentCommonMessage.sendMessage("紧急会议通知", "李四");

        AbstractMessage smsMessage = new SMSMessage(normalImplementor);
        smsMessage.sendMessage("短信通知", "王五");

        AbstractMessage urgentSMSMessage = new SMSMessage(urgentImplementor);
        urgentSMSMessage.sendMessage("紧急短信通知", "赵六");
    }
}
```

## 另一个实际示例：JDBC 连接

```java
// 数据库实现接口
interface DBImplementor {
    void connect(String connectionString);
    void execute(String sql);
}

// MySQL实现
class MySQLImplementor implements DBImplementor {
    @Override
    public void connect(String connectionString) {
        System.out.println("连接到MySQL数据库: " + connectionString);
    }

    @Override
    public void execute(String sql) {
        System.out.println("在MySQL中执行: " + sql);
    }
}

// Oracle实现
class OracleImplementor implements DBImplementor {
    @Override
    public void connect(String connectionString) {
        System.out.println("连接到Oracle数据库: " + connectionString);
    }

    @Override
    public void execute(String sql) {
        System.out.println("在Oracle中执行: " + sql);
    }
}

// 抽象数据库类
abstract class AbstractDatabase {
    protected DBImplementor implementor;

    public AbstractDatabase(DBImplementor implementor) {
        this.implementor = implementor;
    }

    abstract void query(String sql);
}

// 普通数据库
class StandardDatabase extends AbstractDatabase {
    public StandardDatabase(DBImplementor implementor) {
        super(implementor);
    }

    @Override
    void query(String sql) {
        implementor.connect("标准连接");
        implementor.execute(sql);
    }
}

// 事务数据库
class TransactionalDatabase extends AbstractDatabase {
    public TransactionalDatabase(DBImplementor implementor) {
        super(implementor);
    }

    @Override
    void query(String sql) {
        System.out.println("开始事务");
        implementor.connect("事务连接");
        implementor.execute(sql);
        System.out.println("提交事务");
    }
}
```

## 优点

1. 分离抽象接口及其实现部分
2. 提高了系统的可扩充性
3. 实现细节对客户透明
4. 可以在运行时切换实现方式

## 缺点

1. 增加了系统的理解与设计难度
2. 需要正确地识别出系统中两个独立变化的维度

## 适用场景

1. 需要在多个维度上独立扩展时
2. 不希望使用继承或继承导致类爆炸时
3. 需要在运行时切换不同实现时
4. 跨平台应用开发时

## 注意事项

1. 桥接模式要求正确识别出系统的两个独立变化维度
2. 桥接模式的使用要考虑系统的复杂度
3. 桥接模式可以与其他模式结合使用
4. 抽象和实现的分离程度需要恰当

