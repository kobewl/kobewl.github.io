---
title: "享元模式（Flyweight Pattern）"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 享元模式（Flyweight Pattern）

## 概述

享元模式是一种结构型设计模式，它通过共享来有效地支持大量细粒度对象的复用。享元模式通过共享已存在的对象来大幅度减少需要创建的对象数量，从而提高系统资源的利用率。

## 使用场景

- 系统中存在大量相似的对象，造成内存的大量耗费
- 对象的大部分状态都可以外部化，剥离出那些外部状态之后，可以用相对较少的共享对象取代大量对象
- 需要缓存池的场景
- 系统中存在大量重复创建的对象，且这些对象是可以共享的

## 基本实现

```java
// 享元接口
interface Flyweight {
    void operation(String extrinsicState);
}

// 具体享元类
class ConcreteFlyweight implements Flyweight {
    private String intrinsicState;  // 内部状态

    public ConcreteFlyweight(String intrinsicState) {
        this.intrinsicState = intrinsicState;
    }

    @Override
    public void operation(String extrinsicState) {
        System.out.println("内部状态: " + intrinsicState);
        System.out.println("外部状态: " + extrinsicState);
    }
}

// 享元工厂
class FlyweightFactory {
    private Map<String, Flyweight> flyweights = new HashMap<>();

    public Flyweight getFlyweight(String key) {
        if (!flyweights.containsKey(key)) {
            flyweights.put(key, new ConcreteFlyweight(key));
        }
        return flyweights.get(key);
    }

    public int getFlyweightCount() {
        return flyweights.size();
    }
}
```

## 实际应用示例

以字符渲染系统为例：

```java
// 字符属性（外部状态）
class CharacterStyle {
    private String color;
    private int size;
    private String fontFamily;

    public CharacterStyle(String color, int size, String fontFamily) {
        this.color = color;
        this.size = size;
        this.fontFamily = fontFamily;
    }

    @Override
    public String toString() {
        return "Color: " + color + ", Size: " + size + ", Font: " + fontFamily;
    }
}

// 字符享元接口
interface CharacterFlyweight {
    void display(int x, int y, CharacterStyle style);
}

// 具体字符享元类
class ConcreteCharacter implements CharacterFlyweight {
    private char character;  // 内部状态

    public ConcreteCharacter(char character) {
        this.character = character;
    }

    @Override
    public void display(int x, int y, CharacterStyle style) {
        System.out.println("在位置(" + x + "," + y + ")渲染字符'" +
            character + "'，样式：" + style);
    }
}

// 字符享元工厂
class CharacterFactory {
    private Map<Character, CharacterFlyweight> characters = new HashMap<>();

    public CharacterFlyweight getCharacter(char c) {
        if (!characters.containsKey(c)) {
            characters.put(c, new ConcreteCharacter(c));
            System.out.println("创建字符：" + c);
        }
        return characters.get(c);
    }

    public int getCharacterCount() {
        return characters.size();
    }
}

// 文本编辑器
class TextEditor {
    private CharacterFactory factory;
    private List<CharacterFlyweight> characters;
    private List<CharacterStyle> styles;
    private List<Integer> xCoords;
    private List<Integer> yCoords;

    public TextEditor() {
        factory = new CharacterFactory();
        characters = new ArrayList<>();
        styles = new ArrayList<>();
        xCoords = new ArrayList<>();
        yCoords = new ArrayList<>();
    }

    public void addCharacter(char c, int x, int y, CharacterStyle style) {
        CharacterFlyweight character = factory.getCharacter(c);
        characters.add(character);
        styles.add(style);
        xCoords.add(x);
        yCoords.add(y);
    }

    public void display() {
        for (int i = 0; i < characters.size(); i++) {
            characters.get(i).display(xCoords.get(i), yCoords.get(i), styles.get(i));
        }
    }
}
```

## 另一个实际示例：游戏中的树木渲染

```java
// 树木的外部状态
class TreeLocation {
    private int x;
    private int y;
    private String terrain;  // 地形类型

    public TreeLocation(int x, int y, String terrain) {
        this.x = x;
        this.y = y;
        this.terrain = terrain;
    }

    @Override
    public String toString() {
        return "位置(" + x + "," + y + "), 地形: " + terrain;
    }
}

// 树木享元接口
interface TreeFlyweight {
    void display(TreeLocation location);
}

// 具体树木类
class Tree implements TreeFlyweight {
    private final String type;      // 树的类型（内部状态）
    private final String texture;   // 树的纹理（内部状态）

    public Tree(String type, String texture) {
        this.type = type;
        this.texture = texture;
    }

    @Override
    public void display(TreeLocation location) {
        System.out.println("渲染一棵" + type + "树（纹理：" + texture +
            "）在" + location);
    }
}

// 树木工厂
class TreeFactory {
    private Map<String, TreeFlyweight> treeTypes = new HashMap<>();

    public TreeFlyweight getTreeType(String type, String texture) {
        String key = type + texture;
        if (!treeTypes.containsKey(key)) {
            treeTypes.put(key, new Tree(type, texture));
            System.out.println("创建新的树木类型：" + type);
        }
        return treeTypes.get(key);
    }

    public int getTreeTypesCount() {
        return treeTypes.size();
    }
}

// 森林管理类
class Forest {
    private List<TreeFlyweight> trees = new ArrayList<>();
    private List<TreeLocation> locations = new ArrayList<>();
    private TreeFactory factory = new TreeFactory();

    public void plantTree(int x, int y, String terrain, String type, String texture) {
        TreeFlyweight tree = factory.getTreeType(type, texture);
        trees.add(tree);
        locations.add(new TreeLocation(x, y, terrain));
    }

    public void display() {
        for (int i = 0; i < trees.size(); i++) {
            trees.get(i).display(locations.get(i));
        }
    }
}
```

## 优点

1. 大大减少了系统中对象的数量，节省了系统资源
2. 外部状态相对独立，不会影响内部状态
3. 享元对象能够被系统共享，减少了对象的创建和内存占用

## 缺点

1. 需要分离出内部状态和外部状态，增加了系统的复杂性
2. 对象的状态外部化可能会使得系统的设计变得更加复杂
3. 享元模式使得系统更加依赖于共享对象

## 适用场景

1. 系统中存在大量相似对象时
2. 需要缓冲池的场景
3. 对象的大部分状态可以外部化时
4. 系统中存在大量重复创建的对象时

## 注意事项

1. 注意划分内部状态和外部状态
2. 确保享元对象是不可变的
3. 注意线程安全问题
4. 注意享元对象的粒度

