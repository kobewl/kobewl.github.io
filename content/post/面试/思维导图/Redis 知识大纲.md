---
mindmap-plugin: basic
---

# 1 Redis 知识大纲

## 1.1 Redis 基础概念
- Redis 特性
	- 基本特点
		- **基于内存的高性能 NoSQL 数据库**
		- **"单线程"模型（实际上并不完全是单线程）**
			- 重要：Redis 的单线程主要指的是网络 IO 和命令执行是单线程的
			- 网络 IO 是单线程的（避免多线程带来的上下文切换开销和锁竞争）
			- 其他功能使用多线程
			- `持久化 RDB bgsave`
			- `AOF rewrite`
			- `异步删除`
			- `集群同步`
			- **Redis 6.0 后支持多线程 IO**
			> 注意：Redis 6.0 的多线程仅用于网络数据读写和协议解析，命令执行依然是单线程
		- **原子性操作**
		- **支持事务**
		- **持久化机制**
	- **为什么使用单线程模型**
		- 避免多线程上下文切换带来的性能损耗
		- 避免同步机制(如锁)带来的复杂性和性能损耗
		- 内存操作速度本身已经够快,CPU 通常不是瓶颈
		- 单线程模型也能处理高并发(基于 IO 多路复用)
	- 优势
		- **读写性能高（10w QPS）**
		- 数据结构丰富
		- 支持数据持久化
		- 支持主从复制
		- 支持集群部署
	- 应用场景
		- 缓存系统
		- 计数器系统
		- 排行榜系统
		- 社交关系
		- 消息队列
		- 分布式锁

## 1.2 数据类型与实现原理
- **基本数据类型**
	- Sub title
		- String（字符串）
			- 底层实现：**SDS（Simple Dynamic String）**
			- 应用场景：`缓存、计数器、分布式锁`
			- 常用命令：`SET、GET、INCR、DECR`
		- Hash（哈希）
			- 底层实现：**ziplist 或 hashtable**
			- 应用场景：`用户信息、商品信息`
			- 常用命令：`HSET、HGET、HDEL`
		- List（列表）
			- 底层实现：**quicklist（双向链表）**
			- 应用场景：`消息队列、文章列表`
			- 常用命令：`LPUSH、RPUSH、LPOP、RPOP`
		- Set（集合）
			- 底层实现：**intset 或 hashtable**
			- 应用场景：`标签系统、好友关系`
			- 常用命令：`SADD、SREM、SINTER`
		- Sorted Set（有序集合）
			- 底层实现：**skiplist + hashtable**
			- 应用场景：`排行榜、权重排序`
			- 常用命令：`ZADD、ZRANGE、ZRANK`
- 高级数据类型
	- Bitmap
		- 位图操作
		- 应用：用户签到、统计活跃用户
	- HyperLogLog
		- 基数统计
		- 应用：UV 统计
	- GEO
		- 地理位置
		- 应用：附近的人、店铺
	- Stream
		- 消息队列
		- 应用：消息订阅发布系统

## 1.3 持久化机制
- 持久化机制的三种方式
	- **RDB（快照持久化）**
		- 优点
			- **文件紧凑,占用空间小**
			- **恢复速度快**
			- fork 子进程备份,对性能影响小
		- 缺点
			- **可能丢失最后一次快照后的数据**
			- fork 过程耗时,可能阻塞服务
			- 不能实时持久化
	- **AOF（日志持久化）**
		- 优点
			- **数据安全性高**
			- 可读性强,便于分析
			- 支持重写优化
		- 缺点
			- **文件体积大**
			- **恢复速度慢**
			- 对性能有一定影响
		- 同步策略
			- 重要：这三种策略的选择直接影响 Redis 的性能和数据安全性
			- `always`：每次写入(最安全,性能最差)
			- `everysec`：每秒同步(**建议使用**)
			- `no`：由操作系统决定(不建议)
	- **混合持久化(4.0 版本后)**
		- > 推荐的持久化方式，结合了 RDB 和 AOF 的优点
		- 原理
			- RDB + AOF 结合
			- 重启时
				- 前半部分是 RDB 格式(快速恢复)
				- 后半部分是 AOF 格式(保证数据完整)

## 1.4 缓存机制
- **MySQL 和 Redis 数据一致性的四种更新策略**
	- 先删除 Redis，再更新 MySQL（推荐）
		- 流程
			- 删除 Redis 缓存（DEL key）。
			- 更新 MySQL 数据。
		- 优点
			- ✅ 避免脏数据：删除缓存后，即使有并发请求访问 Redis，也会从 MySQL 读取最新数据。
			- ✅ 适用于高并发场景，保证数据库数据最终一致。
		- 缺点
			- ❌ 可能有短暂的缓存穿透问题（删除缓存后，多个请求可能会同时查询 MySQL）。
		- 适用场景
			- 高并发业务（如订单、用户信息）。
			- 更新操作较少，查询频繁。
	- 先更新 MySQL，再删除 Redis
		- 流程
			- 更新 MySQL 数据。
			- 删除 Redis 缓存。
		- 优点
			- ✅ **不会造成缓存穿透**，因为缓存数据仍然可用，直到数据库更新完成后才删除。
			- ✅ **保证数据一致性**，更新后再删除缓存，不会导致数据不一致问题。
		- 缺点
			- ❌ **可能出现短暂的脏数据**，如果 MySQL 更新后 Redis 删除前，其他请求仍然访问 Redis，可能拿到旧数据。
		- 适用场景
			- 数据更新较频繁的业务（如商品库存、订单状态）。
			- 能容忍短暂的不一致。
	- 延迟双删策略（MySQL 更新前后都删除 Redis）
		- 流程
			- 先删除 Redis 缓存。
			- 更新 MySQL 数据。
			- 再延迟一段时间后，第二次删除 Redis（用 sleep(1s) 让 MySQL 事务提交后再删）。
		- 优点
			- ✅ 减少短暂脏数据问题，避免 MySQL 更新完成后 Redis 仍然存在旧数据的情况。
		- 缺点
			- ❌ 多一次 Redis 删除，稍微增加 Redis 负担。
			- ❌ 时间间隔难以调节，如果延迟时间太短，还是可能有并发问题。
		- 适用场景
			- 强一致性要求的业务（如支付、金融系统）。
	- 设置 Redis 过期时间 + 订阅 binlog 机制（异步更新）
		- 流程
			- 对 Redis 设定一个合理的过期时间（如 10 分钟）。
			- 当 Redis 过期后，请求自动从 MySQL 读取数据并回填缓存。
			- 同时订阅 MySQL binlog，监听数据变更，异步更新 Redis。
		- 优点
			- ✅ 自动清理缓存，减少手动管理 Redis 的成本。
			- ✅ 监听 binlog，可在 MySQL 更新后同步 Redis，实现最终一致性。
		- 缺点
			- ❌ 过期时间不好控制，可能导致 MySQL 压力瞬间升高（缓存击穿）。
			- ❌ binlog 订阅需要额外的中间件（如 Canal、Debezium），增加运维复杂度。
		- 适用场景
			- 数据一致性要求高，且 Redis 需要自动维护的业务（如电商商品详情页）。
			- 适合大数据量、更新频率低的场景。

## 1.5 高可用方案
- 主从复制
	- 原理
		- 全量同步
		- 增量同步
	- 优点
		- 读写分离
		- 故障恢复
	- 缺点
		- 延迟
		- 主节点故障需手动切换
- 哨兵模式（Sentinel）
	- 原理
		- 监控
		- 通知
		- 自动故障转移
	- 优点
		- 自动故障转移
		- 无需人工干预
	- 配置
		- sentinel monitor mymaster 127.0.0.1 6379 2
- 集群模式（Cluster）
	- 原理
		- 数据分片
		- 去中心化
		- 自动故障转移
	- 特点
		- 水平扩展
		- 高可用
	- 配置
		- cluster-enabled yes
		- cluster-config-file nodes.conf

## 1.6 性能优化
- 内存优化
	- 内存配置
	- 数据结构选择
	- 过期策略
- 命令优化
	- pipeline
	- 批量命令
	- Lua 脚本
- 网络优化
	- TCP 配置
	- 连接池
	- 压缩

## 1.7 实战经验
- 开发规范
	- key 命名规范
	- value 大小控制
	- 命令使用规范
- 运维经验
	- 监控指标
	- 容量规划
	- 备份策略

## 1.8 高频面试题
- **基础架构**
	- Redis 为什么这么快？
	- 单线程模型的优缺点？
	- **Redis 6.0 为什么引入多线程？**
- 数据结构
	- Redis 字符串的实现原理？
	- 跳表的实现原理？
	- 压缩列表的使用场景？
- 持久化
	- RDB 和 AOF 的区别？
	- 混合持久化的原理？
	- 持久化最佳实践？
- 集群方案
	- 主从复制的流程？
	- 哨兵的选举机制？
	- 集群的扩容和缩容？
- **实践问题**
	- > 这些都是实际工作中经常遇到的问题，需要重点掌握
	- Sub title
		- 如何保证缓存与数据库的一致性？
		- 如何设计一个可靠的分布式锁？
		- 大 key 问题如何解决？