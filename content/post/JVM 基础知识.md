# 1 JVM 内存模型是什么？

1. ==程序计数器==

		* 记录当前线程正在执行的字节码指令地址
		* 线程私有、唯一没有内存溢出的区域

2. ==虚拟机栈==

	* 存储方法调用的栈帧，每一个方法对应一个栈帧
		* 局部变量表：存放基本类型、对象引用。
	* **特性**：线程私有，可能抛出
		
3. 本地方法栈

	 - **作用**：为Native方法（如C/C++实现）服务，类似虚拟机栈。
     - **特性**：线程私有，可能抛出栈溢出错误。
4. 堆

	 - **作用**：存放对象实例和数组，是垃圾回收（GC）的主战场。
     - **结构**：
        - **新生代**：Eden区、两个Survivor区（From/To）。
        - **老年代**：长期存活的对象。
     - **特性**：线程共享，可能抛出 `OutOfMemoryError`。

5. 方法区（元空间、元数据区）

	- **作用**：存储类信息、常量、静态变量、即时编译器代码（Java 8后称为元空间，Metaspace）。
    - **特性**：线程共享，可能抛出 `OutOfMemoryError`（如加载过多类）。

6. 直接内存

**线程私有**：程序计数器、虚拟机栈、本地方法栈
**线程共享**：堆、方法区、直接内存

# 2 Java类加载机制与**双亲委派模型**

### 2.1.1 **一、类加载机制**

Java类加载机制是JVM将类的字节码文件（`.class`）加载到内存，并转换为`Class`对象的过程，分为以下阶段：

- **加载（Loading）**
    
    - **任务**：从文件系统、网络等获取类的二进制字节流，并在方法区生成运行时数据结构，最终创建`Class`对象作为访问入口。
        
    - **关键点**：类加载器（如`Bootstrap`、`Application`）负责加载。
        
- **连接（Linking）**
    
    - **验证（Verification）**：确保字节码符合JVM规范，防止恶意代码攻击（文件格式、字节码指令、语法等等）。
        
    - **准备（Preparation）**：为静态变量分配内存并赋初始值（如`int`初始化为0）。
        
    - **解析（Resolution）**：将符号引用（如类名、方法名）转换为直接引用（内存地址）。
        
- **初始化（Initialization）**
    
    - 执行类构造器`<clinit>()`方法，完成静态变量的赋值和静态代码块的逻辑。
    - **触发条件**：首次主动使用类时（如`new`对象、调用静态方法、访问静态字段）。


### 2.1.2 **二、双亲委派模型（Parent Delegation Model）**

双亲委派是类加载器的协作机制，核心是**优先委派父类加载器加载类**。

1. **类加载器层级**
    
    - **启动类加载器（Bootstrap ClassLoader）**：加载`JAVA_HOME/lib`下的核心类（如`java.lang.*`）。
        
    - **扩展类加载器（Extension ClassLoader）**：加载`JAVA_HOME/lib/ext`下的扩展类。
        
    - **应用程序类加载器（Application ClassLoader）**：加载用户类路径（`classpath`）下的类。
        
    - **自定义类加载器**：用户继承`ClassLoader`实现的加载器。
        
2. **工作流程**
    
    - 类加载器收到请求后，优先委派给父类加载器处理。
        
    - 若父类无法加载（在自己的搜索范围内未找到），子类才尝试加载。
        
    - **优点**：
        - 避免重复加载核心类（如`java.lang.Object`）。
        - 防止用户代码替换核心类（安全沙箱）。

**示例**：  **自定义类加载器实现**：需继承`ClassLoader`并重写`findClass()`。
加载用户自定义类`com.example.MyClass`时：

1. `Application ClassLoader`委派给`Extension ClassLoader`；
    
2. `Extension ClassLoader`委派给`Bootstrap ClassLoader`；
    
3. `Bootstrap ClassLoader`无法加载，回退到`Extension`，再回退到`Application`，最终由`Application ClassLoader`加载。

### 2.1.3 **三、破坏双亲委派的场景**

#### 2.1.3.1 **1. 为什么需要破坏？**

- **场景1：SPI机制（如JDBC）**
    
    - **问题**：`DriverManager`（由`Bootstrap`加载）需要加载第三方数据库驱动（如MySQL的`Driver`类），但驱动位于`classpath`下，应由`Application ClassLoader`加载。
        
    - **解决**：使用线程上下文类加载器（`ThreadContextClassLoader`），通过`Thread.currentThread().setContextClassLoader()`临时切换加载器。
        
- **场景2：模块化热部署（如Tomcat）**
    
    - **需求**：每个Web应用需要独立的类加载器，避免类冲突。
        
    - **实现**：Tomcat的`WebappClassLoader`优先加载自身路径的类，不遵循双亲委派。

#### 2.1.3.2 **2. 如何破坏？**

- **方法1：重写`loadClass()`方法**  
    直接跳过父类加载逻辑，例如Tomcat的类加载器：
```java
	public class WebappClassLoader extends ClassLoader {
    @Override
    public Class<?> loadClass(String name) throws ClassNotFoundException {
        // 1. 检查是否已加载
        // 2. 优先从Web应用目录加载
        // 3. 若未找到，再委派给父类加载器
    }
}
```

**方法2：利用线程上下文类加载器**  
	JDBC通过`ServiceLoader`加载驱动：

```java
ServiceLoader<Driver> drivers = ServiceLoader.load(Driver.class);
// 底层使用Thread.currentThread().getContextClassLoader()
```

#### 2.1.3.3 **3. 实际案例：Tomcat的类加载机制**

- **类加载器层次**：
    
    - **Common ClassLoader**：加载Tomcat共享类。
        
    - **Webapp ClassLoader**：每个Web应用独立，优先加载`/WEB-INF/classes`和`/WEB-INF/lib`下的类。
        
- **隔离性**：不同Web应用的类互不可见，避免冲突。

#### 2.1.3.4 **4. 线上类加载问题排查**

- **常见异常**：
    
    - `ClassNotFoundException`：类未找到（如类路径错误）。
        
    - `NoClassDefFoundError`：类初始化失败（如静态代码块抛出异常）。
        
- **排查工具**：
    
    - `-verbose:class`：打印类加载日志。
        
    - `jstack`：查看线程上下文类加载器。


# 3 JVM 垃圾回收机制？

#### 3.1.1.1 **一、GC算法**

垃圾回收（Garbage Collection, GC）的核心任务是自动回收不再使用的对象内存。以下是经典GC算法及其特点：

1. **标记-清除（Mark-Sweep）**
    
    - **原理**：
        1. **标记**：遍历所有对象，标记存活对象。
        2. **清除**：回收未标记的对象内存。
            
    - **优点**：实现简单，无需移动对象。
        
    - **缺点**：
        - 产生内存碎片，可能触发频繁GC。
        - 效率较低（需两次遍历）。
            
    - **适用场景**：老年代（如CMS收集器）。
        
2. **复制算法（Copying）**
    
    - **原理**：将内存分为两块（如Eden和Survivor区），每次使用一块。存活对象复制到另一块，清空原块。
        
    - **优点**：无内存碎片，回收高效。
        
    - **缺点**：
        - 内存利用率仅50%。
        - 对象存活率高时复制成本高。
            
    - **适用场景**：新生代（如Serial、ParNew收集器）。
        
3. **标记-整理（Mark-Compact）**
    
    - **原理**：
        1. **标记**：标记存活对象。
        2. **整理**：将存活对象向内存一端移动，清理边界外内存。
            
    - **优点**：无内存碎片。
        
    - **缺点**：移动对象带来额外开销。
        
    - **适用场景**：老年代（如Serial Old收集器）。
        
4. **分代收集（Generational Collection）**
    
    - **核心思想**：根据对象存活周期划分内存区域（新生代、老年代），针对不同区域采用不同算法。
        
        - **新生代**：存活时间短，使用复制算法（如Eden区→Survivor区）。
        - **老年代**：存活时间长，使用标记-清除或标记-整理。
            
    - **优化逻辑**：
        - 新生代GC（Minor GC）频率高，但停顿短。
        - 老年代GC（Major GC/Full GC）频率低，但停顿长。

#### 3.1.1.2 **二、垃圾收集器**

JVM提供了多种垃圾收集器，适用于不同场景：

1. **Serial收集器**
    
    - **特点**：单线程执行GC，全程STW（Stop-The-World）。
    - **适用场景**：客户端应用或小内存服务端（如嵌入式系统）。
    - **组合**：Serial（新生代） + Serial Old（老年代）。
        
2. **ParNew收集器**
    
    - **特点**：多线程并行执行新生代GC，STW时间缩短。
    - **适用场景**：配合CMS收集器的老年代回收（JDK 8及之前）。
    - **组合**：ParNew（新生代） + CMS（老年代）。
        
3. **CMS（Concurrent Mark-Sweep）收集器**
    
    - **目标**：减少老年代GC停顿时间，实现部分并发。
    - **流程**：
        1. **初始标记（STW）**：标记GC Roots直接关联的对象。
        2. **并发标记**：遍历对象图，与用户线程并发执行。
        3. **重新标记（STW）**：修正并发标记期间变动的对象。
        4. **并发清除**：回收垃圾对象。
            
    - **优点**：低停顿（尤其适合响应敏感应用）。
        
    - **缺点**：
        
        - 内存碎片问题（需Full GC时触发压缩）。
        - CPU资源竞争（并发阶段占用线程）。
            
    - **适用场景**：Web服务、实时交易系统（JDK 8及之前）。
        
4. **G1（Garbage-First）收集器**
    
    - **特点**：
        
        - 将堆划分为多个Region（默认2048个），每个Region可以是Eden、Survivor或Old区。
        - 通过停顿预测模型（Pause Prediction Model），控制每次GC的停顿时间。
        - 采用Mixed GC模式，同时回收新生代和老年代。
            
    - **流程**：
        
        1. **初始标记（STW）**：标记GC Roots直接关联的对象。
        2. **并发标记**：并发标记存活对象。
        3. **最终标记（STW）**：处理剩余SATB（Snapshot-At-The-Beginning）记录。
        4. **筛选回收（STW）**：根据Region的回收价值排序，选择收益最高的Region回收。
            
    - **优点**：
        
        - 可控的停顿时间（通过`-XX:MaxGCPauseMillis`设置）。
        - 高吞吐量与低延迟的平衡。
            
    - **适用场景**：大内存、高并发的服务端应用（JDK 9+默认收集器）。
        
5. **ZGC（Z Garbage Collector）**
    
    - **目标**：亚毫秒级停顿（<10ms），适合超大堆内存（TB级）。
        
    - **关键技术**：
        
        - **染色指针（Colored Pointers）**：在指针中存储元数据，标记对象状态。
        - **读屏障（Load Barrier）**：处理并发时对象状态变化。
            
    - **流程**：
        
        1. **并发标记**：标记存活对象。
        2. **并发预备重分配**：确定需回收的Region。
        3. **并发重分配**：移动存活对象并更新引用。
        4. **并发重映射**：修正旧地址到新地址的引用。
            
    - **优点**：几乎无停顿，吞吐量损失小。
        
    - **适用场景**：实时性要求极高的系统（如金融交易、大数据平台）。

#### 3.1.1.3 **三、GC调优实践**

GC调优需结合应用场景，平衡吞吐量、延迟和内存占用。

1. **常用参数配置**
    
    - **堆大小**：
        
        - `-Xms`：初始堆大小（如`-Xms4g`）。
            
        - `-Xmx`：最大堆大小（通常与`-Xms`相同，避免动态调整开销）。
            
    - **新生代与老年代比例**：
        
        - `-XX:NewRatio=2`（老年代:新生代=2:1）。
            
        - `-XX:SurvivorRatio=8`（Eden:Survivor =8:1:1）。
            
    - **GC日志**：
        
        - `-Xloggc:/path/to/gc.log`：输出GC日志。
            
        - `-XX:+PrintGCDetails`：打印详细GC信息。
            
        - `-XX:+UseGCLogFileRotation`：启用日志滚动。
            
2. **调优目标**
    
     -  **降低Full GC频率**：减少老年代内存不足触发Full GC的风险。
            
        - **减少GC停顿时间**：优化CMS、G1或ZGC的停顿控制参数。
            
        - **提高吞吐量**：确保GC时间占总运行时间的比例较低（如`-XX:GCTimeRatio=99`表示GC时间不超过1%）。
            
    - **调优步骤**
        
        - **确定目标**：明确是优化延迟、吞吐量还是内存占用。
            
        - **收集数据**：使用工具（如`jstat`、GC日志分析工具）监控GC行为。
            
        - **分析问题**：
            
            - 频繁Minor GC：可能是新生代过小或对象分配速率过高。
            - Full GC频繁：可能是老年代内存不足或内存泄漏。
                
        - **调整参数**：
            
            - 新生代调优：增大`-Xmn`（新生代大小）。
            - 老年代调优：调整`-XX:CMSInitiatingOccupancyFraction`（CMS触发阈值）。
                
        - **验证效果**：通过压测对比调优前后的GC日志。
            
    - **实际案例**
        
        - **CMS并发模式失败**：
            
            - **现象**：日志中出现`Concurrent Mode Failure`。
                
            - **原因**：老年代内存不足，无法完成并发清除。
                
            - **解决**：
                
                1. 增大老年代空间（`-Xmx`）。
                2. 降低CMS触发阈值（`-XX:CMSInitiatingOccupancyFraction=70`）。
                3. 启用内存碎片整理（`-XX:+UseCMSCompactAtFullCollection`）。
 **G1调优经验**：
 
- **目标**：控制最大停顿时间。
    - **参数**：`-XX:MaxGCPauseMillis=200`（设置期望停顿时间）。
    - **优化**：调整Region大小（`-XX:G1HeapRegionSize`）或增加并发线程数（`-XX:ConcGCThreads`）。
        
- **ZGC使用场景**：
    
    - **适用场景**：需要处理TB级堆内存且要求停顿时间极低（如实时数据分析）。
    - **参数**：`-XX:+UseZGC -Xmx16g`。
    - **限制**：JDK 11+支持，且需64位系统。


#### 3.1.1.4 **四、工具与监控**

1. **命令行工具**
    
    - `jstat`：实时监控堆内存和GC情况（如`jstat -gcutil <pid> 1000`）。
    - `jmap`：生成堆转储快照（如`jmap -dump:format=b,file=heap.bin <pid>`）。
    - `jstack`：查看线程栈信息（排查STW原因）。
        
2. **可视化工具**
    
    - **VisualVM**：分析GC日志、内存泄漏。
    - **GCEasy**：在线GC日志分析工具，生成可视化报告。
    - **MAT（Memory Analyzer Tool）**：分析堆转储文件，定位内存泄漏。


# 4 JVM 调优参数

以下是针对JVM调优参数的详细讲解，结合**图表化记忆方法**帮助您深入理解：

---

### 4.1.1 **一、内存相关参数**
#### 4.1.1.1 **1. 核心参数与内存布局**
以下参数直接影响JVM堆和元空间的内存分配：

| 参数                     | 作用      | 默认值          | 图表示例（堆结构）                               |
| ---------------------- | ------- | ------------ | --------------------------------------- |
| `-Xms`                 | 初始堆大小   | 物理内存的1/64    | 堆内存结构                                   |
| `-Xmx`                 | 最大堆大小   | 物理内存的1/4     | 图中：堆分为新生代（Young）和老年代（Old），`-Xmn`指定新生代大小 |
| `-Xmn`                 | 新生代大小   | 无默认值，需显式设置   |                                         |
| `-XX:MetaspaceSize`    | 元空间初始大小 | 平台依赖（约20MB）  | 元空间独立于堆，使用本地内存                          |
| `-XX:MaxMetaspaceSize` | 元空间最大大小 | 无限制（受物理内存限制） |                                         |

**图表说明**：  
- 堆内存分为**新生代**（Eden + Survivor）和**老年代**，`-Xms`和`-Xmx`控制堆的初始和最大容量。  
- `-Xmn`直接指定新生代大小（如`-Xmn2g`），剩余空间自动分配给老年代。  
- 元空间（Metaspace）存放类元数据，需单独配置防止`OOM`。

---

### 4.1.2 **二、GC相关参数**
#### 4.1.2.1 **1. G1收集器核心参数与Region划分**
G1收集器将堆划分为多个Region，参数控制其行为：

| 参数                     | 作用                          | 示例值           | 图表示例（G1 Region）                                                            |
|--------------------------|-------------------------------|------------------|----------------------------------------------------------------------------------|
| `-XX:+UseG1GC`           | 启用G1收集器                  | 无               | ![G1 Region](https://via.placeholder.com/400x200?text=G1+Region+划分+Mixed+GC)    |
| `-XX:MaxGCPauseMillis`   | 目标最大停顿时间              | `200`（毫秒）     | 图中：Region分为Eden、Survivor、Old和Humongous（大对象）区                       |
| `-XX:ParallelGCThreads`  | 并行GC线程数                  | CPU核心数的5/8    |                                                                                  |

**图表说明**：  
- G1通过Region划分实现局部回收，`MaxGCPauseMillis`控制每次GC的停顿时间上限。  
- `ParallelGCThreads`影响GC并发阶段的吞吐量（线程越多，GC越快，但CPU竞争加剧）。

---

### 4.1.3 **三、日志相关参数**
#### 4.1.3.1 **1. GC日志格式与参数对应关系**
配置日志参数后，GC日志结构如下：

| 参数                    | 日志输出示例                                                                 | 图表说明                                                                         |
|-------------------------|-----------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| `-XX:+PrintGCDetails`   | `[GC (Allocation Failure) [PSYoungGen: 614400K->87040K] 0.045 secs]`       | ![GC日志](https://via.placeholder.com/400x100?text=GC+日志格式+时间戳+详情)       |
| `-XX:+PrintGCDateStamps`| `2023-10-01T12:34:56.789+0800: [GC ...]`                                   | 时间戳帮助定位GC发生时段                                                         |
| `-Xloggc:/path/to/gc.log`| 将日志输出到指定文件                                                       | 日志文件需定期归档分析                                                           |

---

### 4.1.4 **四、实战经验与调优场景**
#### 4.1.4.1 **1. 不同场景参数配置对比**
通过表格对比不同场景的核心参数：

| 场景                 | 参数配置示例                                                                 | 图表说明                                                                         |
|----------------------|-----------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| **高吞吐量（批处理）** | `-XX:+UseParallelGC -Xmx8g -Xms8g -XX:ParallelGCThreads=8`                 | ![高吞吐量](https://via.placeholder.com/400x150?text=ParallelGC+大堆+多线程)      |
| **低延迟（Web服务）**  | `-XX:+UseG1GC -Xmx4g -XX:MaxGCPauseMillis=150 -XX:InitiatingHeapOccupancyPercent=45` | 使用G1控制停顿时间                                                              |
| **超大堆（缓存服务）** | `-XX:+UseZGC -Xmx32g -XX:ConcGCThreads=4`                                  | ZGC适合TB级堆，几乎无停顿                                                       |

#### 4.1.4.2 **2. 线上问题排查案例流程图**
**问题：频繁Full GC导致服务卡顿**  
```plaintext
1. 监控报警 → 2. 查看GC日志 → 3. 发现频繁Full GC  
   ↓  
2. 使用`jmap -histo`分析对象分布 → 5. 发现内存泄漏（如缓存未清理）  
   ↓  
3. 调整参数（增大老年代/优化代码） → 7. 验证效果  
```

---

### 4.1.5 **五、记忆技巧**
1. **堆内存结构图**：绘制堆的Eden、Survivor、Old区域，标注`-Xms`、`-Xmx`、`-Xmn`。  
2. **G1 Region示意图**：展示Region划分和Mixed GC过程。  
3. **参数分类表格**：按内存、GC、日志分类整理参数。  
4. **场景对比表**：高吞吐量 vs 低延迟 vs 超大堆的参数差异。

---

### 4.1.6 **六、总结**
- **内存参数**：控制堆和元空间的容量，避免OOM和频繁扩容。  
- **GC参数**：根据场景选择收集器，G1平衡吞吐量和延迟，ZGC适合极致低延迟。  
- **日志参数**：记录GC行为，用于事后分析和调优验证。  
- **实战调优**：结合监控工具（如VisualVM、Prometheus）和日志分析，持续优化参数。