---
mindmap-plugin: basic
---
****
# 1 Java 知识大纲

## 1.1 Java 基础
- 1.1 面向对象基础
	- 三大特性
		- 封装
			- 访问权限修饰符
				- public：任何地方都可访问
				- protected：同包和子类可访问
				- default：同包可访问
				- private：仅本类可访问
			- 属性私有化，提供 getter/setter
				- 数据隐藏
				- 实现细节封装
				- 控制访问权限
		- 继承
			- 单继承多实现
				- Java 为什么不支持多继承
				- 接口多实现的好处
				- 继承与组合的选择
			- 方法重写规则
				- 访问权限不能更严格
				- 返回类型可以是子类
				- 不能抛出更多异常
			- super 和 this 关键字
				- super 调用父类方法和属性
				- this 调用本类方法和属性
				- 构造方法中的使用规则
		- 多态
			- 方法重写与重载
				- 重写（Override）：运行时多态
				- 重载（Overload）：编译时多态
				- 区别与使用场景
			- 运行时绑定
				- 动态分派机制
				- 虚方法表
				- 方法调用过程
			- 向上转型和向下转型
				- 安全性考虑
				- instanceof 运算符
				- 类型转换异常处理
	- 类与接口
		- 抽象类
			- 抽象方法
				- 定义规范
				- 强制实现
			- 构造方法
				- 抽象类构造方法作用
				- 子类调用规则
				- 初始化顺序
			- 普通方法
				- 默认实现
				- 模板方法模式
				- 复用性考虑
		- 接口
			- JDK8 默认方法
				- 接口演进
				- 多继承问题解决
				- 实现类优先级
			- 静态方法
				- 工具方法提供
				- 接口内聚性
				- 使用场景
			- 函数式接口
				- @FunctionalInterface 注解
				- Lambda 表达式支持
				- 常用函数式接口
		- 内部类
			- 静态内部类
				- 独立于外部类的实例
				- 访问外部类静态成员
				- 单例模式应用
			- 成员内部类
				- 隐式持有外部类引用
				- 访问外部类的所有成员
				- 内存泄漏风险
			- 局部内部类
				- 方法内部定义
				- 访问局部变量的限制
				- 实际应用场景
			- 匿名内部类
				- 使用场景
				- 实现原理
				- 注意事项
- 1.2 基本数据类型
	- 八种基本类型
		- 整型：byte、short、int、long
			- 取值范围
			- 默认值
			- 使用场景
		- 浮点型：float、double
			- 精度问题
			- BigDecimal 的使用
			- 浮点数比较
		- 字符型：char
			- Unicode 编码
			- 转义字符
		- 布尔型：boolean
			- 内存占用
			- 默认值
			- 条件判断
	- 包装类型
		- 自动装箱与拆箱
			- 实现原理
			- 性能影响
			- 注意事项
		- 缓存机制
			- Integer 缓存范围
			- Character 缓存范围
			- Boolean 缓存
		- 常量池技术
			- 字符串常量池
			- 包装类常量池
			- intern() 方法
	- 类型转换
		- 隐式转换
			- 自动类型提升
			- 表达式类型转换
			- 注意事项
		- 显式转换
			- 强制类型转换
			- 数据截断
			- 精度损失
		- 精度损失问题
			- 浮点数转整数
			- 大数值转换
			- 解决方案
- 1.3 String 相关
	- String 特性[[Java基础知识#^497c70]]
		- 不可变性
			- final 修饰的好处
			- 线程安全原因
			- 字符串常量池优化
		- 线程安全性
			- 并发访问安全
			- 共享访问
			- 性能考虑
		- 字符串常量池
			- 实现原理
			- 内存位置
			- 垃圾回收
	- StringBuilder 和 StringBuffer[[Java基础知识#^9211a3]]
		- 可变性
			- 内部实现
			- 扩容机制
			- 性能特点
		- 线程安全性
			- StringBuffer 的同步实现
			- StringBuilder 的非同步特性
			- 使用选择
		- 性能比较
			- 单线程场景
			- 多线程场景
			- 最佳实践
	- 字符串操作
		- 常用方法
			- split() 的陷阱
			- replace 和 replaceAll
			- 正则表达式支持
		- 性能优化
			- 字符串拼接优化
			- 字符串比较优化
			- 内存占用优化

## 1.2 Java 集合框架[[Java集合]]
- 2.1 Collection 接口
	- List[[Java集合#^e549f5]]
		- ArrayList[[Java集合#^461613]]
			- 底层实现
				- 动态数组
				- 默认容量
				- 扩容机制
			- 扩容机制
				- 扩容时机
				- 扩容大小
				- 性能影响
			- 线程安全性
				- 非线程安全原因
				- 并发修改异常
				- 同步包装器
		- LinkedList[[Java集合#^cb1ba7]]
			- 双向链表
				- 节点结构
				- 插入删除性能
				- 随机访问性能
			- 操作特点
				- 头尾操作效率
				- 中间操作效率
				- 迭代器实现
		- Vector[[Java集合#^4c46fc]]
			- 线程安全
				- 同步实现方式
				- 性能开销
				- 替代方案
			- 性能特点
				- 扩容机制
				- 并发性能
				- 内存占用
			- 使用建议
				- 不推荐使用的原因
				- 替代方案选择
				- 历史遗留问题
	- Set[[Java集合#^baddb9]]
		- HashSet[[Java集合#^29663c]]
			- 底层实现
				- HashMap 实现原理
				- 哈希冲突处理
				- 负载因子作用
			- 去重机制
				- hashCode() 和 equals()
				- 自定义对象注意事项
				- 性能考虑
		- TreeSet[[Java集合#^9934ba]]
			- 红黑树实现
				- 树的平衡
				- 插入删除原理
				- 遍历效率
			- 有序性
				- 自然排序
				- 比较器排序
				- 排序稳定性
			- 使用场景
				- 有序集合需求
				- 范围查询
				- 性能考虑
		- LinkedHashSet[[Java集合#^e72186]]
			- 特点和用途
				- 插入顺序维护
				- 访问顺序维护
				- 性能特点
			- 实现原理
				- 链表 + 哈希表
				- 双向链表维护
				- 内存开销
			- 应用场景
				- LRU 缓存实现
				- 有序去重
				- 实际应用建议
- 2.2 Map 接口[[Java集合#^397b75]]
	- HashMap[[Java集合#^b56e93]]
		- 数据结构
			- 数组 + 链表 + 红黑树
				- 基本结构
				- 链表转红黑树条件
				- 性能优化
				- 扩容机制
					- 扩容时机
					- 扩容过程
					- 性能影响
			- 负载因子
				- 默认值选择
				- 调整建议
				- 性能影响
		- 工作原理
			- hash 算法
				- 哈希函数设计
				- 哈希冲突处理
				- 性能考虑
			- 解决冲突
				- 链地址法
				- 红黑树优化
				- 实际效果
			- 树化条件
				- 链表长度阈值
				- 数组容量要求
				- 树化过程
		- HashMap与ConcurrentHashMap对比[[Java集合#^6b2e0e]]
	- TreeMap[[Java集合#^7724c6]]
		- 红黑树[[红黑树]]实现
			- 树的特性
			- 平衡维护
			- 性能分析
		- 有序性保证
			- 自然排序
			- 定制排序
			- 排序稳定性
	- LinkedHashMap[[Java集合#^54be60]]
		- 特点和用途
			- 插入顺序
			- 访问顺序
			- 性能特点
		- LRU 缓存实现
			- 实现原理
			- 性能分析
			- 实际应用
		- 访问顺序维护
			- 双向链表
			- 节点移动
			- 性能开销
	- Hashtable[[Java集合#^d5953d]]
		- 线程安全
			- 同步实现
			- 性能影响
			- 使用场景
		- 性能特点
			- 并发性能
			- 空间开销
			- 实际表现
		- 不推荐原因
			- 性能问题
			- 替代方案
			- 历史原因

## 1.3 Java IO
- 3.1 基础 IO
	- 字节流
		- InputStream
			- 基本方法
			- 缓冲机制
			- 性能优化
		- OutputStream
			- 基本方法
			- 刷新机制
			- 关闭处理
		- 实现类及用途
			- FileInputStream/FileOutputStream
			- BufferedInputStream/BufferedOutputStream
			- DataInputStream/DataOutputStream
	- 字符流
		- Reader
			- 字符编码
			- 缓冲策略
			- 常用方法
		- Writer
			- 字符编码
			- 缓冲策略
			- 刷新机制
		- 编码转换
			- 字符集支持
			- 编码问题处理
			- 最佳实践
	- 转换流
		- InputStreamReader
			- 字节到字符转换
			- 编码设置
			- 性能考虑
		- OutputStreamWriter
			- 字符到字节转换
			- 编码设置
			- 缓冲处理
		- 字符集处理
			- 常见字符集
			- 编码转换
			- 乱码处理
- 3.2 NIO
	- Buffer
		- 缓冲区操作
			- 基本属性
			- 读写模式切换
			- 常用方法
		- 直接缓冲区
			- 实现原理
			- 使用场景
			- 性能特点
		- 内存映射
			- 实现机制
			- 适用场景
			- 注意事项
	- Channel
		- 文件通道
			- 基本操作
			- 性能优化
			- 异步操作
		- 网络通道
			- TCP 通道
			- UDP 通道
			- 异步通道
		- 通道转换
			- 流转通道
			- 通道互转
			- 效率考虑
	- Selector
		- 多路复用
			- 实现原理
			- 性能优势
			- 使用场景
		- 事件监听
			- 事件类型
			- 处理机制
			- 实际应用
		- 非阻塞 IO
			- 实现方式
			- 性能特点
			- 应用场景

## 1.4 Java 反射与注解
- 4.1 反射机制[[反射机制]]
	- Class 类
		- 获取方式
			- 类名.class
			- 对象.getClass()
			- Class.forName()
		- 类信息
			- 成员变量
			- 方法信息
			- 构造方法
		- 类加载
			- 加载过程
			- 类加载器
			- 双亲委派
	- 反射操作
		- 构造方法
			- 获取构造器
			- 创建实例
			- 访问控制
		- 成员变量
			- 获取字段
			- 设置值
			- 访问权限
		- 方法调用
			- 获取方法
			- 调用方法
			- 参数处理
	- 动态代理[[代理模式]]
		- JDK 动态代理
			- 实现原理
			- 使用限制
			- 性能分析
		- CGLIB 代理
			- 实现原理
			- 使用场景
			- 性能特点
		- 实际应用
			- AOP 实现[[Spring 核心概念#^494af1]]
			- 性能监控
			- 权限控制
- 4.2 注解[[Java 反射与注解#^e9934b]]
	- 基础注解
		- @Override
			- 作用
			- 编译检查
			- 使用场景
		- @Deprecated
			- 版本兼容
			- 替代方案
			- 文档说明
		- @SuppressWarnings
			- 警告类型
			- 使用范围
			- 最佳实践
	- 元注解
		- @Target
			- 注解使用位置
			- 限制范围
			- 组合使用
		- @Retention
			- 保留策略
			- 运行时处理
			- 编译时处理
		- @Documented
			- 文档生成
			- API 说明
			- 使用场景
		- @Inherited
			- 继承行为
			- 使用限制
			- 实际应用
	- 自定义注解
		- 定义方法
			- 属性定义
			- 默认值
			- 返回类型
		- 处理器
			- 注解处理器
			- 运行时处理
			- 编译时处理
		- 应用实例
			- 配置管理
			- 权限控制
			- 参数校验

## 1.5 Java 8 新特性[[Java 8新特性]]
- 5.1 Lambda 表达式[[Lambda和Stream]]
	- 基本语法
		- 参数列表
			- 参数类型
			- 参数推断
			- 特殊情况
		- 箭头操作符
			- 语法规则
			- 使用限制
			- 作用域
		- 函数体
			- 单行表达式
			- 代码块
			- 返回值
	- 函数式接口
		- Predicate
			- 判断接口
			- 组合操作
			- 使用场景
		- Consumer
			- 消费接口
			- 链式操作
			- 实际应用
		- Function
			- 转换接口
			- 组合函数
			- 类型转换
		- Supplier
			- 提供接口
			- 延迟计算
			- 工厂方法
	- 方法引用
		- 静态方法引用
			- 语法格式
			- 使用场景
			- 性能优势
		- 实例方法引用
			- 对象方法
			- 类型方法
			- 使用限制
		- 构造方法引用
			- 创建对象
			- 数组创建
			- 工厂模式
- 5.2 Stream API[[Lambda和Stream#^708003]]
	- 创建 Stream
		- 集合创建
			- Collection 接口
			- Arrays 工具类
			- Stream.of()
		- 数组创建
			- 基本类型数组
			- 对象数组
			- 并行流
		- 其他方式
			- 无限流
			- 文件流
			- 自定义流
- 5.3 Optional 类
	- 创建 Optional
		- of
			- 非空值
			- 空值处理
			- 异常处理
		- ofNullable
			- 可空值
			- 默认值
			- 链式调用
		- empty
			- 空对象
			- 使用场景
			- 性能考虑
	- 使用方法
		- map
			- 值转换
			- 链式操作
			- 空值处理
		- flatMap
			- 扁平化处理
			- 嵌套 Optional
			- 实际应用
		- filter
			- 条件过滤
			- 组合条件
			- 使用建议
		- orElse
			- 默认值
			- 异常处理
			- 性能优化
	- 最佳实践
		- 空值处理
			- NPE 预防
			- 异常处理
			- 代码简化
		- 链式调用
			- 方法组合
			- 代码可读性
			- 性能考虑
		- 代码简化
			- 条件判断
			- 异常处理
			- 返回值处理

## 1.6 Java 高级特性
- 6.1 泛型[[Java泛型]]
	- 泛型类
		- 定义和使用
			- 类型参数
			- 泛型约束
			- 类型推断
		- 类型参数
			- 命名约定
			- 边界限定
			- 多重边界
		- 泛型方法
			- 定义语法
			- 类型推断
			- 使用限制
	- 类型擦除
		- 原理
			- 擦除过程
			- 桥接方法
			- 运行时类型
		- 局限性
			- 类型检查
			- 创建泛型数组
			- instanceof 限制
		- 桥接方法
			- 生成原理
			- 重写规则
			- 实际应用
	- 通配符
		- 上界通配符
			- extends 关键字
			- 使用场景
			- 类型安全
		- 下界通配符
			- super 关键字
			- 使用场景
			- 类型安全
		- PECS 原则
			- Producer Extends
			- Consumer Super
			- 最佳实践
- 6.2 序列化
	- Serializable 接口
		- 序列化 ID
			- 版本控制
			- 兼容性
			- 生成策略
		- 默认序列化
			- 序列化过程
			- 反序列化过程
			- 性能考虑
		- 自定义序列化
			- writeObject 方法
			- readObject 方法
			- 安全考虑
	- 序列化方式
		- Java 序列化
			- 原生支持
			- 性能特点
			- 使用限制
		- JSON 序列化
			- 常用框架
			- 性能比较
			- 跨语言支持
		- Protocol Buffers
			- 高效序列化
			- 跨平台支持
			- 使用场景
	- 注意事项
		- 安全性
			- 反序列化漏洞
			- 数据验证
			- 加密处理
		- 性能考虑
			- 序列化大小
			- 序列化速度
			- 内存占用
		- 版本兼容
			- 向前兼容
			- 向后兼容
			- 字段变更
- 6.3 异常处理[[Java异常处理]]
	- 异常体系
		- Throwable
			- 异常基类
			- 错误和异常
			- 继承体系
		- Error
			- 系统错误
			- 内存溢出
			- 栈溢出
		- Exception
			- 检查异常
			- 运行时异常
			- 自定义异常
	- 异常处理机制
		- try-catch-finally
			- 执行顺序
			- 资源释放
			- 返回值
		- try-with-resources
			- 自动关闭
			- 实现原理
			- 使用建议
		- throws 声明
			- 异常传播
			- 方法重写
			- 异常链
	- 最佳实践
		- 异常设计
			- 异常粒度
			- 异常封装
			- 异常转换
		- 性能考虑
			- 异常开销
			- 异常缓存
			- 异常处理策略
		- 日志记录
			- 日志级别
			- 异常信息
			- 堆栈信息