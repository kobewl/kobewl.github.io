---
title: "外观模式/门面模式（Facade Pattern）"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 外观模式/门面模式（Facade Pattern）

## 概述

外观模式是一种结构型设计模式，它为复杂的子系统提供一个简单的接口。外观模式定义了一个高层接口，使得子系统更容易使用。这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。

## 使用场景

- 需要为复杂的子系统提供一个简单的接口时
- 需要将系统分层时，可以使用外观模式定义子系统中每层的入口点
- 需要减少客户端与子系统之间的耦合度时
- 需要将系统的复杂性隐藏起来时

## 基本实现

```java
// 子系统类A
class SubSystemA {
    public void operationA() {
        System.out.println("子系统A的操作");
    }
}

// 子系统类B
class SubSystemB {
    public void operationB() {
        System.out.println("子系统B的操作");
    }
}

// 子系统类C
class SubSystemC {
    public void operationC() {
        System.out.println("子系统C的操作");
    }
}

// 外观类
class Facade {
    private SubSystemA systemA;
    private SubSystemB systemB;
    private SubSystemC systemC;

    public Facade() {
        systemA = new SubSystemA();
        systemB = new SubSystemB();
        systemC = new SubSystemC();
    }

    // 提供给客户端的简单接口
    public void operation1() {
        System.out.println("操作1：");
        systemA.operationA();
        systemB.operationB();
    }

    public void operation2() {
        System.out.println("操作2：");
        systemB.operationB();
        systemC.operationC();
    }
}

// 客户端使用示例
public class Client {
    public static void main(String[] args) {
        Facade facade = new Facade();
        facade.operation1();
        facade.operation2();
    }
}
```

## 实际应用示例

以智能家居系统为例：

```java
// 子系统：灯光控制
class LightSystem {
    public void turnOn() {
        System.out.println("打开灯光");
    }

    public void turnOff() {
        System.out.println("关闭灯光");
    }

    public void dim() {
        System.out.println("调暗灯光");
    }
}

// 子系统：空调控制
class AirConditioner {
    public void turnOn() {
        System.out.println("打开空调");
    }

    public void turnOff() {
        System.out.println("关闭空调");
    }

    public void setTemperature(int temperature) {
        System.out.println("设置温度为: " + temperature + "度");
    }
}

// 子系统：音响系统
class MusicSystem {
    public void turnOn() {
        System.out.println("打开音响");
    }

    public void turnOff() {
        System.out.println("关闭音响");
    }

    public void setVolume(int volume) {
        System.out.println("设置音量为: " + volume);
    }
}

// 子系统：窗帘控制
class CurtainSystem {
    public void open() {
        System.out.println("打开窗帘");
    }

    public void close() {
        System.out.println("关闭窗帘");
    }
}

// 智能家居外观类
class SmartHomeFacade {
    private LightSystem lightSystem;
    private AirConditioner airConditioner;
    private MusicSystem musicSystem;
    private CurtainSystem curtainSystem;

    public SmartHomeFacade() {
        lightSystem = new LightSystem();
        airConditioner = new AirConditioner();
        musicSystem = new MusicSystem();
        curtainSystem = new CurtainSystem();
    }

    // 起床模式
    public void wakeUpMode() {
        System.out.println("启动起床模式...");
        curtainSystem.open();
        lightSystem.turnOn();
        airConditioner.turnOn();
        airConditioner.setTemperature(26);
        musicSystem.turnOn();
        musicSystem.setVolume(20);
    }

    // 睡眠模式
    public void sleepMode() {
        System.out.println("启动睡眠模式...");
        musicSystem.turnOff();
        curtainSystem.close();
        lightSystem.dim();
        airConditioner.setTemperature(23);
    }

    // 离家模式
    public void leaveHomeMode() {
        System.out.println("启动离家模式...");
        lightSystem.turnOff();
        airConditioner.turnOff();
        musicSystem.turnOff();
        curtainSystem.close();
    }
}
```

## 另一个实际示例：计算机启动过程

```java
// 子系统：CPU
class CPU {
    public void freeze() {
        System.out.println("CPU: 冻结所有进程");
    }

    public void jump(long position) {
        System.out.println("CPU: 跳转到位置 " + position);
    }

    public void execute() {
        System.out.println("CPU: 开始执行指令");
    }
}

// 子系统：内存
class Memory {
    public void load(long position, String data) {
        System.out.println("内存: 从" + position + "位置加载数据: " + data);
    }
}

// 子系统：硬盘
class HardDrive {
    public String read(long lba, int size) {
        System.out.println("硬盘: 从扇区" + lba + "读取" + size + "字节数据");
        return "数据...";
    }
}

// 计算机外观类
class ComputerFacade {
    private static final long BOOT_ADDRESS = 0x0000L;
    private static final long BOOT_SECTOR = 0x00000L;
    private static final int SECTOR_SIZE = 512;

    private CPU cpu;
    private Memory memory;
    private HardDrive hardDrive;

    public ComputerFacade() {
        this.cpu = new CPU();
        this.memory = new Memory();
        this.hardDrive = new HardDrive();
    }

    public void start() {
        System.out.println("计算机启动过程开始...");
        cpu.freeze();
        String bootData = hardDrive.read(BOOT_SECTOR, SECTOR_SIZE);
        memory.load(BOOT_ADDRESS, bootData);
        cpu.jump(BOOT_ADDRESS);
        cpu.execute();
        System.out.println("计算机启动完成！");
    }
}

// 使用示例
public class ComputerDemo {
    public static void main(String[] args) {
        ComputerFacade computer = new ComputerFacade();
        computer.start();
    }
}
```

## 优点

1. 简化了客户端与子系统之间的关系，使得客户端使用起来更加容易
2. 实现了子系统与客户端之间的松耦合关系
3. 提供了一个统一的接口，来访问子系统中的一群接口
4. 隐藏了系统的复杂性，提高了系统的可维护性

## 缺点

1. 外观类可能会变得很大，违反单一职责原则
2. 不符合开闭原则，增加新的子系统可能需要修改外观类
3. 可能会产生过度依赖外观类的问题

## 适用场景

1. 需要为复杂的子系统提供一个简单接口时
2. 客户端与抽象类的实现之间存在很大的依赖性时
3. 需要构建一个层次结构的子系统时
4. 需要将系统的复杂性隐藏起来时

## 注意事项

1. 外观模式只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类
2. 不要试图通过外观类为子系统添加新的行为
3. 外观类应该是"薄"的，尽量保持较少的业务逻辑
4. 考虑使用抽象外观类来提供更多的灵活性

