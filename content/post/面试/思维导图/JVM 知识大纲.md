---
mindmap-plugin: basic
---

# 1 JVM 知识大纲

## 1.1 JVM 基础概念

### 1.1.1 Java 虚拟机概述

- JVM 的作用
  - 跨平台特性实现
    - Write Once, Run Anywhere
    - 字节码转换为机器码
  - 自动内存管理
    - 垃圾回收
    - 内存分配
  - 安全控制
    - 字节码验证
    - 安全管理器
- JVM 规范
  - 《Java 虚拟机规范》
    - 类文件格式
    - 指令集架构
    - 运行时数据区
  - 主流 JVM 实现
    - HotSpot（Oracle）
      - 最广泛使用的 JVM
      - 服务器、客户端两种模式
    - OpenJ9（IBM）
      - 内存占用小
      - 启动快
    - GraalVM
      - 支持多语言
      - AOT 编译
- JDK、JRE、JVM 关系
  - JDK：开发工具 + JRE
  - JRE：运行环境 + JVM
  - JVM：虚拟机实现

### 1.1.2 Java 代码执行流程

- 源代码到机器码的过程
  - 编译过程
    - 词法分析
    - 语法分析
    - 语义分析
    - 字节码生成
  - 类加载过程
    - 加载、验证、准备
    - 解析、初始化
  - 执行过程
    - 解释执行
    - JIT 编译执行
    - 混合模式
- JIT（即时编译）
  - 热点代码识别
    - 方法调用计数器
    - 循环回边计数器
  - 编译优化
    - 方法内联
    - 逃逸分析
    - 循环优化
  - 编译触发条件
    - 调用阈值（默认 10000）
    - OSR 阈值（默认 10700）
    - 分层编译策略

## 1.2 类加载机制

### 1.2.1 类加载过程

- 加载（Loading）
  - 通过类的全限定名获取二进制字节流
    - 文件系统（jar、war）
    - 网络（Web Applet）
    - 计算生成（动态代理）
    - 数据库
    - 其他文件（如 jsp）
  - 将字节流所代表的静态存储结构转化为方法区的运行时数据结构
  - 在内存中生成 Class 对象，作为方法区这个类的各种数据的访问入口
- 连接（Linking）
  - 验证（Verification）
    - 文件格式验证
      - 魔数检查（0xCAFEBABE）
      - 版本号检查
      - 常量池检查
    - 元数据验证
      - 是否有父类
      - 继承是否合法
      - 抽象类是否实现了所有方法
    - 字节码验证
      - 跳转指令是否正确
      - 操作数类型是否合法
    - 符号引用验证
      - 符号引用转化为直接引用是否可访问
  - 准备（Preparation）
    - 为类变量（static）分配内存
    - 设置初始值
      - 基本类型默认值（0、0L、null 等）
      - 常量获得显式赋值（static final）
    - 不包含实例变量（随对象实例化分配）
  - 解析（Resolution）
    - 符号引用替换为直接引用
      - 类或接口解析
      - 字段解析
      - 方法解析
      - 接口方法解析
    - 解析时机
      - 主动使用时
      - 显式调用时
- 初始化（Initialization）
  - 执行类构造器 <clinit>() 方法
    - 由编译器自动收集类中所有变量的赋值动作
    - 静态语句块中的语句
    - 父类先于子类
  - 初始化时机（主动引用）
    - new、getstatic、putstatic、invokestatic 指令
    - 反射调用
    - 子类初始化触发父类初始化
    - 包含 main 方法的类
    - 动态语言支持
  - 被动引用（不触发初始化）
    - 子类引用父类静态字段
    - 通过数组定义引用类
    - 常量引用

### 1.2.2 类加载器详解

- 类加载器分类
  - 启动类加载器（Bootstrap ClassLoader）
    - 加载核心类库（JAVA_HOME/lib）
    - 如 rt.jar、tools.jar
    - C++实现，Java 中为 null
  - 扩展类加载器（Extension ClassLoader）
    - 加载扩展类库（JAVA_HOME/lib/ext）
    - 如 javax.\*开头的类
    - Java 实现，sun.misc.Launcher$ExtClassLoader
  - 应用程序类加载器（Application ClassLoader）
    - 加载应用程序 classpath 下的类
    - 程序默认类加载器
    - Java 实现，sun.misc.Launcher$AppClassLoader
  - 自定义类加载器
    - 继承 ClassLoader 抽象类
- 加载
  - 查找和读取 class 文件
  - 生成 Class 对象
- 连接
  - 验证：确保 class 文件格式正确
  - 准备：静态变量分配内存并初始化默认值
  - 解析：符号引用转为直接引用
- 初始化
  - 执行类构造器 <clinit>
  - 静态变量赋值
  - 静态代码块执行

### 1.2.3 类加载器

- 类加载器分类
  - 启动类加载器（Bootstrap）
  - 扩展类加载器（Extension）
  - 应用类加载器（Application）
  - 自定义类加载器
- 双亲委派模型
  - 工作原理
  - 优点
  - 如何打破
- 类加载器特点
  - 层次性
  - 可见性
  - 唯一性

## 1.3 内存区域与内存管理

### 1.3.1 运行时数据区

- 线程私有
  - 程序计数器
    - 作用
    - 特点
  - 虚拟机栈
    - 栈帧结构
    - 局部变量表
    - 操作数栈
    - 动态链接
    - 返回地址
  - 本地方法栈
    - Native 方法支持
- 线程共享
  - 堆
    - 新生代（Eden、S0、S1）
    - 老年代
    - 对象分配策略
  - 方法区
    - 类信息
    - 常量
    - 静态变量
  - 直接内存
    - NIO 支持
    - 内存映射文件

### 1.3.2 对象探秘

- 对象的创建过程
  - 类加载检查
  - 分配内存
  - 初始化零值
  - 设置对象头
  - 执行 init 方法
- 对象的内存布局
  - 对象头
    - Mark Word
    - 类型指针
  - 实例数据
  - 对齐填充
- 对象的访问方式
  - 句柄访问
  - 直接指针

## 1.4 垃圾回收机制

### 1.4.1 垃圾识别算法

- 引用计数法
  - 原理
    - 对象被引用计数加 1
    - 引用失效计数减 1
    - 计数为 0 时回收
  - 优缺点
    - 优点：实时性强，内存管理简单
    - 缺点：无法解决循环引用，计数器维护开销大
  - 循环引用问题
    - 相互引用导致计数永不为 0
    - Python 的解决方案
- 可达性分析
  - GC Roots 对象
    - 虚拟机栈引用的对象
    - 方法区中静态属性引用的对象
    - 方法区中常量引用的对象
    - 本地方法栈 JNI 引用的对象
    - 同步锁持有的对象
    - 活跃线程对象
  - 引用链
    - 强引用（Strong Reference）
      - 普通对象引用
      - 永远不会被回收
    - 软引用（Soft Reference）
      - 内存不足时回收
      - 实现内存敏感的缓存
    - 弱引用（Weak Reference）
      - GC 时立即回收
      - WeakHashMap 的实现
    - 虚引用（Phantom Reference）
      - 不影响对象生命周期
      - 用于跟踪对象被回收的状态
  - 对象死亡判定
    - 第一次标记
    - finalize() 方法
    - 第二次标记

### 1.4.2 垃圾收集算法

- 标记-清除（Mark-Sweep）
  - 原理
    - 标记阶段：标记所有可达对象
    - 清除阶段：回收未标记对象
  - 优缺点
    - 优点：实现简单，不需要移动对象
    - 缺点：产生大量内存碎片，标记清除效率不高
  - 适用场景
    - 老年代收集
    - 内存碎片不敏感的场景
- 复制算法（Copying）
  - 原理
    - 将内存分为两块
    - 存活对象复制到另一块
    - 清空当前内存块
  - 优缺点
    - 优点：内存整齐，无碎片
    - 缺点：内存利用率低，对象复制开销大
  - 适用场景
    - 新生代收集
    - 存活对象较少的场景
- 标记-整理（Mark-Compact）
  - 原理
    - 标记阶段：标记可达对象
    - 整理阶段：将存活对象向一端移动
  - 优缺点
    - 优点：无内存碎片，内存利用率高
    - 缺点：移动对象开销大，需要更新引用
  - 适用场景
    - 老年代收集
    - 内存碎片敏感的场景

### 1.4.3 垃圾收集器

- 新生代收集器
  - Serial
    - 单线程收集器
    - Client 模式默认
    - 简单高效，适合小内存
  - ParNew
    - Serial 的多线程版本
    - 常配合 CMS 使用
    - 服务器环境首选
  - Parallel Scavenge
    - 关注吞吐量
    - 自适应调节
    - 适合后台计算
- 老年代收集器
  - Serial Old
    - Serial 的老年代版本
    - 标记-整理算法
    - Client 模式默认
  - Parallel Old
    - Parallel Scavenge 老年代版本
    - 吞吐量优先
  - CMS（Concurrent Mark Sweep）
    - 最短停顿时间
    - 并发收集
    - 标记-清除算法
    - 四个步骤
      - 初始标记（STW）
      - 并发标记
      - 重新标记（STW）
      - 并发清除
- 全局收集器
  - G1（Garbage First）
    - 特点
      - 区域化分代式
      - 可预测停顿时间
      - 混合收集
    - 运作过程
      - 初始标记（STW）
      - 并发标记
      - 最终标记（STW）
      - 筛选回收
    - 使用场景
      - 大内存、多处理器
      - 需要低停顿时间
  - ZGC
    - 特点
      - 低延迟（<10ms）
      - 大内存支持
      - 着色指针
    - 适用场景
      - 低延迟业务
      - 大内存服务器
  - Shenandoah
    - 特点
      - 与 ZGC 类似
      - 连接矩阵
      - 并发整理
    - Red Hat 开发
- 收集器选择
  - 选择依据
    - 系统需求（延迟/吞吐量）
    - 硬件规格
    - JDK 版本
  - 最佳实践
    - 小内存：Serial + Serial Old
    - 中等内存：ParNew + CMS
    - 大内存：G1
    - 超大内存：ZGC
