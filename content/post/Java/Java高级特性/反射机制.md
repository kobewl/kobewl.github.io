---
title: "1 Java 反射机制"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 1 Java 反射机制

## 1.1 基本概念

### 1.1.1 什么是反射

- 在运行时检查和修改类的结构和行为的能力
- 可以在运行时获取类的所有信息
- 可以在运行时调用任意方法和构造器

### 1.1.2 反射的主要用途

```ascii
反射应用场景：

框架开发 ────┐
动态代理 ────┤
依赖注入 ────┼──> 反射机制
单元测试 ────┤
类加载器 ────┘
```

## 1.2 获取类信息

### 1.2.1 获取 Class 对象

```java
// 1. 通过类名
Class<?> class1 = String.class;

// 2. 通过对象
String str = "Hello";
Class<?> class2 = str.getClass();

// 3. 通过完整类名
Class<?> class3 = Class.forName("java.lang.String");

// 4. 通过类加载器
ClassLoader loader = Thread.currentThread().getContextClassLoader();
Class<?> class4 = loader.loadClass("java.lang.String");
```

### 1.2.2 获取类的结构

```java
// 示例类
class Person {
    private String name;
    public int age;

    public Person(String name) {
        this.name = name;
    }

    public void sayHello() {
        System.out.println("Hello, " + name);
    }
}

// 获取类的结构信息
Class<?> personClass = Person.class;

// 1. 获取所有字段
Field[] fields = personClass.getDeclaredFields();

// 2. 获取所有方法
Method[] methods = personClass.getDeclaredMethods();

// 3. 获取所有构造器
Constructor<?>[] constructors = personClass.getDeclaredConstructors();

// 4. 获取父类和接口
Class<?> superClass = personClass.getSuperclass();
Class<?>[] interfaces = personClass.getInterfaces();
```

## 1.3 反射操作

### 1.3.1 创建对象

```java
// 1. 使用默认构造器
Object obj1 = personClass.newInstance();  // 已过时
Object obj2 = personClass.getDeclaredConstructor().newInstance();  // 推荐

// 2. 使用带参构造器
Constructor<?> constructor = personClass.getDeclaredConstructor(String.class);
Object obj3 = constructor.newInstance("John");
```

### 1.3.2 访问字段

```java
// 获取 Person 类的实例
Person person = new Person("John");
Class<?> clazz = person.getClass();

// 1. 访问公有字段
Field ageField = clazz.getField("age");
ageField.set(person, 25);
int age = (int) ageField.get(person);

// 2. 访问私有字段
Field nameField = clazz.getDeclaredField("name");
nameField.setAccessible(true);  // 设置可访问
nameField.set(person, "Tom");
String name = (String) nameField.get(person);
```

### 1.3.3 调用方法

```java
// 1. 调用无参方法
Method sayHelloMethod = clazz.getDeclaredMethod("sayHello");
sayHelloMethod.invoke(person);

// 2. 调用带参方法
Method setNameMethod = clazz.getDeclaredMethod("setName", String.class);
setNameMethod.invoke(person, "Alice");

// 3. 调用私有方法
Method privateMethod = clazz.getDeclaredMethod("privateMethod");
privateMethod.setAccessible(true);
privateMethod.invoke(person);
```

## 1.4 反射的应用实例

### 1.4.1 简单 IoC 容器实现

```java
public class SimpleContainer {
    private Map<String, Object> beans = new HashMap<>();

    public void register(String name, Class<?> clazz) throws Exception {
        Object instance = clazz.getDeclaredConstructor().newInstance();
        beans.put(name, instance);
    }

    public Object getBean(String name) {
        return beans.get(name);
    }
}

// 使用示例
SimpleContainer container = new SimpleContainer();
container.register("person", Person.class);
Person person = (Person) container.getBean("person");
```

### 1.4.2 注解处理器

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
@interface Value {
    String value();
}

public class AnnotationProcessor {
    public static void processAnnotations(Object obj) throws Exception {
        Class<?> clazz = obj.getClass();
        for (Field field : clazz.getDeclaredFields()) {
            Value value = field.getAnnotation(Value.class);
            if (value != null) {
                field.setAccessible(true);
                field.set(obj, value.value());
            }
        }
    }
}

// 使用示例
class Config {
    @Value("localhost")
    private String host;

    @Value("8080")
    private String port;
}
```

## 1.5 性能考虑

### 1.5.1 反射的开销

```ascii
反射操作的性能开销：

普通方法调用 ───> [0.0001ms]
             │
反射方法调用 ───> [0.01ms]
             │
首次反射调用 ───> [1ms]
```

### 1.5.2 优化建议

1. **缓存反射对象**

```java
// 不推荐
Method method = clazz.getDeclaredMethod("someMethod");  // 每次都获取
method.invoke(obj);

// 推荐
private static final Method method = clazz.getDeclaredMethod("someMethod");  // 缓存
method.invoke(obj);
```

2. **适时使用 setAccessible**

```java
// 批量操作时，一次性设置
method.setAccessible(true);
for (int i = 0; i < 1000; i++) {
    method.invoke(obj);
}
```

## 1.6 注意事项

### 1.6.1 安全性考虑

```ascii
反射的安全风险：

私有成员访问 ──> 破坏封装性
系统方法调用 ──> 可能危及系统
类加载安全 ──> 潜在恶意代码
```

### 1.6.2 最佳实践

1. **限制反射使用范围**
2. **进行安全检查**
3. **异常处理**
4. **及时关闭反射访问**

```java
Field field = null;
try {
    field = clazz.getDeclaredField("privateField");
    field.setAccessible(true);
    // 使用字段
} catch (Exception e) {
    // 异常处理
} finally {
    if (field != null) {
        field.setAccessible(false);  // 恢复访问限制
    }
}
```

