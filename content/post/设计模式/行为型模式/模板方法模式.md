---
title: "模板方法模式（Template Method Pattern）"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 模板方法模式（Template Method Pattern）

## 概述

模板方法模式是一种行为型设计模式，它定义了一个算法的骨架，将一些步骤延迟到子类中实现。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。这种模式通过将不变的行为搬移到超类，去除子类中的重复代码来体现它的优势。

## 使用场景

- 多个类有相似的算法，只是其中的某些步骤不同
- 需要控制子类扩展的时候
- 需要一次性实现一个算法的不变部分，并将可变的行为留给子类来实现
- 各子类中有重复的代码需要提取和复用时

## 基本实现

```java
// 抽象类，定义算法骨架
abstract class AbstractClass {
    // 模板方法，定义算法骨架
    public final void templateMethod() {
        step1();
        step2();
        step3();
        hook();  // 钩子方法
    }

    // 具体方法
    private void step1() {
        System.out.println("AbstractClass: 执行步骤1");
    }

    // 抽象方法，由子类实现
    protected abstract void step2();

    // 具体方法
    protected void step3() {
        System.out.println("AbstractClass: 执行步骤3");
    }

    // 钩子方法，子类可以选择性重写
    protected void hook() {
        // 默认空实现
    }
}

// 具体类A
class ConcreteClassA extends AbstractClass {
    @Override
    protected void step2() {
        System.out.println("ConcreteClassA: 执行步骤2");
    }

    @Override
    protected void hook() {
        System.out.println("ConcreteClassA: 执行钩子方法");
    }
}

// 具体类B
class ConcreteClassB extends AbstractClass {
    @Override
    protected void step2() {
        System.out.println("ConcreteClassB: 执行步骤2");
    }
}
```

## 实际应用示例

以数据导出功能为例：

```java
// 抽象数据导出类
abstract class DataExporter {
    // 模板方法
    public final void exportData() {
        connectToDataSource();
        extractData();
        transformData();
        if (needsFormatting()) {
            formatData();
        }
        saveData();
        cleanup();
    }

    // 连接数据源
    private void connectToDataSource() {
        System.out.println("连接数据源");
    }

    // 提取数据（具体实现由子类完成）
    protected abstract void extractData();

    // 转换数据（具体实现由子类完成）
    protected abstract void transformData();

    // 格式化数据（钩子方法）
    protected void formatData() {
        // 默认空实现
    }

    // 是否需要格式化（钩子方法）
    protected boolean needsFormatting() {
        return true;
    }

    // 保存数据（具体实现由子类完成）
    protected abstract void saveData();

    // 清理资源
    private void cleanup() {
        System.out.println("清理资源");
    }
}

// PDF导出器
class PDFExporter extends DataExporter {
    @Override
    protected void extractData() {
        System.out.println("从数据库提取数据用于PDF导出");
    }

    @Override
    protected void transformData() {
        System.out.println("转换数据为PDF格式");
    }

    @Override
    protected void formatData() {
        System.out.println("格式化PDF数据");
    }

    @Override
    protected void saveData() {
        System.out.println("保存为PDF文件");
    }
}

// Excel导出器
class ExcelExporter extends DataExporter {
    @Override
    protected void extractData() {
        System.out.println("从数据库提取数据用于Excel导出");
    }

    @Override
    protected void transformData() {
        System.out.println("转换数据为Excel格式");
    }

    @Override
    protected boolean needsFormatting() {
        return false;  // Excel不需要额外格式化
    }

    @Override
    protected void saveData() {
        System.out.println("保存为Excel文件");
    }
}
```

## 另一个实际示例：饮品制作

```java
// 抽象饮品类
abstract class Beverage {
    // 模板方法：制作饮品
    public final void prepareBeverage() {
        boilWater();
        brew();
        pourInCup();
        if (customerWantsCondiments()) {
            addCondiments();
        }
    }

    // 烧水
    private void boilWater() {
        System.out.println("将水煮沸");
    }

    // 冲泡（由子类实现）
    protected abstract void brew();

    // 倒入杯中
    private void pourInCup() {
        System.out.println("倒入杯中");
    }

    // 添加调料（由子类实现）
    protected abstract void addCondiments();

    // 钩子方法：是否需要添加调料
    protected boolean customerWantsCondiments() {
        return true;
    }
}

// 咖啡类
class Coffee extends Beverage {
    private boolean wantsCondiments;

    public Coffee(boolean wantsCondiments) {
        this.wantsCondiments = wantsCondiments;
    }

    @Override
    protected void brew() {
        System.out.println("用沸水冲泡咖啡");
    }

    @Override
    protected void addCondiments() {
        System.out.println("添加糖和牛奶");
    }

    @Override
    protected boolean customerWantsCondiments() {
        return wantsCondiments;
    }
}

// 茶类
class Tea extends Beverage {
    @Override
    protected void brew() {
        System.out.println("用沸水浸泡茶叶");
    }

    @Override
    protected void addCondiments() {
        System.out.println("添加柠檬");
    }
}
```

## 优点

1. 提高代码复用性，将相同部分的代码放在抽象的父类中
2. 提供了一个框架，子类可以在不改变算法整体结构的情况下，重新定义算法中的特定步骤
3. 通过钩子方法可以让子类决定是否执行某些步骤
4. 符合开闭原则，可以方便地增加新的子类

## 缺点

1. 每个不同的实现都需要定义一个子类，可能会导致类的数量增加
2. 父类中的方法可能过于复杂，不同的实现可能需要不同的参数，不容易确定父类方法的参数类型
3. 对父类的修改可能会影响所有的子类实现

## 适用场景

1. 算法的整体步骤很固定，但其中某些步骤的实现可能不同
2. 多个类有相似的行为，但是其中一些行为略有不同
3. 需要控制子类扩展的时候
4. 需要将一次性实现的算法的不变部分和可变部分分离时

## 注意事项

1. 模板方法应该尽量保持简单，不要过于复杂
2. 注意抽象类和具体类之间的职责划分
3. 注意钩子方法的使用，不要过度使用
4. 遵循"好莱坞原则"：不要调用我们，我们会调用你

