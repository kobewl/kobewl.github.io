---
title: "分布式锁（Distributed Lock）"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 分布式锁（Distributed Lock）

## 概述

分布式锁是控制分布式系统中多个进程对共享资源进行访问的一种锁实现。用于在分布式系统中协调多个节点之间的同步访问，防止彼此干扰。

## 分布式锁的特性

1. **互斥性**：任意时刻只能有一个客户端持有锁
2. **可重入性**：同一个节点获取了锁之后，可以再次获取
3. **锁超时**：防止死锁，超时自动释放
4. **高可用**：锁服务要保证高可用
5. **高性能**：加锁解锁要高效

## 实现方式

### 1. 基于数据库实现

```sql
-- 创建锁表
CREATE TABLE distributed_lock (
    lock_key VARCHAR(50) PRIMARY KEY,
    lock_value VARCHAR(50),
    expire_time TIMESTAMP
);

-- 获取锁
INSERT INTO distributed_lock (lock_key, lock_value, expire_time)
VALUES ('lock_key', 'lock_value', NOW() + INTERVAL '1' MINUTE)
ON CONFLICT (lock_key) DO NOTHING;

-- 释放锁
DELETE FROM distributed_lock
WHERE lock_key = 'lock_key' AND lock_value = 'lock_value';
```

优点：

- 实现简单，容易理解
- 支持可重入性
- 具有持久性

缺点：

- 性能较差
- 数据库可能成为瓶颈
- 不适合高并发场景

### 2. 基于 Redis 实现

```java
// 获取锁
String result = jedis.set(lockKey, requestId, "NX", "PX", expireTime);

// 释放锁（Lua脚本）
String script = "if redis.call('get', KEYS[1]) == ARGV[1] then " +
                "return redis.call('del', KEYS[1]) " +
                "else return 0 end";
jedis.eval(script, Collections.singletonList(lockKey),
           Collections.singletonList(requestId));
```

优点：

- 性能高
- 实现相对简单
- 可以设置过期时间

缺点：

- 可能存在锁超时问题
- 主从切换时可能丢失锁

### 3. 基于 Zookeeper 实现

```java
// 创建临时有序节点
String path = zk.create(lockPath + "/lock_", data,
                       ZooDefs.Ids.OPEN_ACL_UNSAFE,
                       CreateMode.EPHEMERAL_SEQUENTIAL);

// 判断是否获得锁
List<String> nodes = zk.getChildren(lockPath, false);
Collections.sort(nodes);
if(path.equals(lockPath + "/" + nodes.get(0))){
    return true;
}
```

优点：

- 可靠性高
- 自动释放锁
- 支持读写锁

缺点：

- 性能相对较差
- 实现复杂
- 需要额外维护 ZK 集群

## 使用场景

1. **秒杀系统**

   - 控制商品库存
   - 防止超卖

2. **订单处理**

   - 防止重复下单
   - 保证订单状态一致性

3. **定时任务**

   - 防止重复执行
   - 集群环境下的任务调度

4. **数据同步**
   - 控制同步过程
   - 防止数据混乱

## 最佳实践

1. **选择合适的实现方式**

   - 低并发：数据库
   - 高并发：Redis
   - 高可靠：Zookeeper

2. **处理异常情况**

   - 锁超时处理
   - 网络异常处理
   - 节点宕机处理

3. **性能优化**

   - 合理设置超时时间
   - 使用锁的粒度要适中
   - 避免长时间持有锁

4. **可靠性保证**
   - 加锁解锁要成对出现
   - 使用 finally 块释放锁
   - 考虑重试机制

## 注意事项

1. **死锁预防**

   - 设置合理的超时时间
   - 实现锁的自动释放
   - 避免循环等待

2. **性能考虑**

   - 减少锁的持有时间
   - 选择合适的锁粒度
   - 使用合适的实现方式

3. **可用性保证**
   - 实现锁的降级机制
   - 考虑备用方案
   - 监控锁的使用情况

