---
mindmap-plugin: basic
---

# 1 Java 多线程知识大纲

## 1.1 线程基础
- 1.1.1 线程概述
	- 线程的定义
		- 程序执行的最小单位
		- 共享进程资源
		- 独立的执行路径
	- 线程与进程的区别
		- 资源占用
			- 进程是资源分配的基本单位
			- 进程拥有独立的地址空间和系统资源
			- 线程共享所属进程的地址空间和资源
		- 切换开销
			- 进程切换开销大（需要切换页表、内存空间）
			- 线程切换开销小（只需要切换程序计数器、寄存器等）
		- 通信方式
			- 进程间通信（IPC）：管道、消息队列、共享内存、信号量等
			- 线程间通信：共享内存、wait/notify、volatile 等
		- 并发性
			- 进程间并发
			- 线程间并发（更轻量级）
		- 系统开销
			- 进程创建和销毁开销大
			- 线程创建和销毁开销小
	- 线程的生命周期[[Java 多线程基础#^bb5688]]
		- NEW（新建）
			- 线程被创建但尚未启动的状态
			- 调用 start() 方法前的状态
		- RUNNABLE（可运行）
			- 包含 Ready 和 Running 两个状态
			- Ready：等待 CPU 调度
			- Running：获得 CPU 时间片正在运行
		- BLOCKED（阻塞）
			- 等待获取 synchronized 锁
			- 被其他线程占用锁时的状态
		- WAITING（等待）
			- 无限期等待其他线程的动作
			- Object.wait()
			- Thread.join()
			- LockSupport.park()
		- TIMED_WAITING（限时等待）
			- 等待指定时间后自动返回
			- Thread.sleep(time)
			- Object.wait(time)
			- Thread.join(time)
		- TERMINATED（终止）
			- run() 方法执行完毕
			- 出现未捕获的异常
- 1.1.2 线程的创建与使用
	- 创建线程的方式[[Java 多线程基础#^35e54f]]
		- 继承 Thread 类
			- 重写 run() 方法
			- 直接调用 start()
			- 缺点：Java 单继承限制
		- 实现 Runnable 接口
			- 实现 run() 方法
			- 通过 Thread 构造执行
			- 优点：可以继承其他类
		- 实现 Callable 接口
			- 可以有返回值
			- 可以抛出异常
			- 需要配合 FutureTask
			- 适合有返回值的异步任务
		- 使用线程池
			- ExecutorService
			- ThreadPoolExecutor
			- Executors 工具类
			- 优点：线程复用，控制并发数
	- 线程的基本操作
		- start()：启动线程
			- 创建新线程并执行 run()
			- 只能调用一次
		- run()：线程执行体
			- 定义线程要执行的任务
			- 直接调用等同于普通方法调用
		- sleep()：线程休眠
			- 暂时让出 CPU 执行权
			- 不会释放锁
			- 可以被中断
		- join()：等待线程结束
			- 等待调用 join() 的线程执行完毕
			- 可以设置超时时间
		- yield()：让出 CPU 执行权
			- 提示线程调度器让出当前线程的执行
			- 具体实现依赖操作系统
		- interrupt()：中断线程
			- 设置线程的中断标志
			- 如果线程在 sleep/wait，会抛出 InterruptedException

## 1.2 线程安全
- 1.2.1 并发问题
	- 原子性问题
		- 一个操作不可被中断
			- CPU 指令级别的原子性
			- Java 中的原子性操作
			- 复合操作的原子性问题
		- CPU 指令的原子性
			- 单个指令的原子性
			- 多个指令的非原子性
			- 长整型赋值的非原子性问题
		- Java 原子类的使用
			- CAS 操作
			- ABA 问题及解决
			- 原子类的实现原理
	- 可见性问题
		- 缓存导致的可见性问题
			- CPU 缓存模型
			- 缓存一致性协议
			- 写缓冲区和无效化队列
		- volatile 关键字
			- 保证可见性
			- 禁止指令重排
			- 不保证原子性
			- 内存屏障实现
		- synchronized 的可见性保证
			- 进入同步块时的读取
			- 退出同步块时的写入
			- happens-before 关系
	- 有序性问题
		- 指令重排序
			- 编译器重排序
			- 处理器重排序
			- 内存系统重排序
		- happens-before 原则
			- 程序顺序规则
			- 监视器锁规则
			- volatile 变量规则
			- 传递性规则
			- start() 规则
			- join() 规则
		- 内存屏障
			- LoadLoad 屏障
			- StoreStore 屏障
			- LoadStore 屏障
			- StoreLoad 屏障
- 1.2.2 线程安全解决方案
	- synchronized 关键字[[Java 线程安全#^86ce7c]]
		- 对象锁
			- 同步代码块
				- synchronized(this)
				- synchronized(object)
			- 同步方法
				- 实例方法上的 synchronized
				- 锁对象为 this
		- 类锁
			- 静态同步方法
				- 静态方法上的 synchronized
				- 锁对象为类对象
			- Class 对象同步
				- synchronized(Class)
				- 全局锁
		- 原理
			- 对象头 Mark Word
				- 锁标志位
				- 锁状态
				- 哈希码
				- GC 分代年龄
			- 锁升级过程
				- 无锁状态
					- 对象初始状态
					- Mark Word 存储对象 HashCode
				- 偏向锁
					- 加锁：记录线程 ID
					- 撤销：遇到其他线程竞争
					- 批量重偏向和批量撤销
				- 轻量级锁
					- 自旋等待
					- 适合锁竞争不激烈的场景
					- CAS 操作替换 Mark Word
				- 重量级锁
					- 向操作系统申请资源
					- 线程阻塞/唤醒
					- 适合锁竞争激烈的场景
			- 偏向锁/轻量级锁/重量级锁
				- 锁升级是单向的
				- 升级顺序：无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁
				- 不同锁的使用场景
	- Lock 接口[[Java 线程安全#^62d4e8]]
		- ReentrantLock
			- 可重入性
				- 同一个线程可以多次获取锁
				- 重入次数计数
			- 公平锁/非公平锁
				- 公平锁：按照申请锁的顺序获取锁
				- 非公平锁：抢占式获取锁
				- 性能和公平性的权衡
			- 条件变量
				- await() 和 signal()
				- 支持多个条件队列
				- 精确的线程唤醒
		- ReadWriteLock
			- 读写分离
				- 读锁共享
				- 写锁排他
				- 适合读多写少的场景
			- 写锁独占
				- 写操作的互斥
				- 写锁可降级为读锁
			- 读锁共享
				- 多个线程可同时读
				- 读写互斥
		- StampedLock
			- 乐观读
				- 无锁的读操作
				- 数据校验机制
			- 悲观读
				- 类似 ReadWriteLock
				- 不支持重入
			- 写锁
				- 独占式写锁
				- 版本号控制

## 1.3 线程通信
- 1.3.1 线程协作
	- wait/notify 机制
		- wait()：等待
			- 释放锁并等待
			- 需要在同步块中调用
			- 可能虚假唤醒
		- notify()：唤醒单个线程
			- 随机唤醒一个等待线程
			- 不会立即释放锁
		- notifyAll()：唤醒所有线程
			- 唤醒所有等待线程
			- 避免死锁风险
	- Condition 接口
		- await()
			- 类似 wait()
			- 支持中断
			- 支持超时
		- signal()
			- 类似 notify()
			- 精确唤醒
		- signalAll()
			- 类似 notifyAll()
			- 唤醒特定条件的所有线程
	- CountDownLatch
		- 等待多线程完成
			- 初始化计数值
			- await() 等待计数为 0
		- 计数器机制
			- countDown() 计数减一
			- 计数为 0 后不能重用
	- CyclicBarrier
		- 循环栅栏
			- 可重用的同步屏障
			- 支持所有线程到达后的回调
		- 等待指定数量线程
			- await() 等待其他线程
			- 超时机制
	- Semaphore
		- 信号量机制
			- 控制并发访问的线程数
			- 支持公平和非公平模式
		- 控制并发访问数
			- acquire() 获取许可
			- release() 释放许可
- 1.3.2 线程通信方式
	- 共享内存
		- volatile 变量
			- 保证可见性
			- 适用于一写多读
			- 不保证原子性
		- 静态变量
			- 全局共享
			- 线程不安全
		- 对象实例
			- 堆内存共享
			- 需要同步措施
	- 消息传递
		- wait/notify
			- 等待/通知机制
			- 需要同步
		- BlockingQueue
			- 阻塞队列
			- 生产者-消费者模式
		- 管道流
			- PipedInputStream
			- PipedOutputStream
			- 线程间字节流传输

## 1.4 线程池[[Java 多线程基础#^2f105e]]
- 1.4.1 线程池原理[[Java 多线程基础#^a1772d]]
	- 核心参数
		- corePoolSize：核心线程数
			- 最小保持的线程数
			- 不会被回收
		- maximumPoolSize：最大线程数
			- 线程池最大线程数
			- 包括核心线程和临时线程
		- keepAliveTime：空闲线程存活时间
			- 临时线程的空闲时间
			- 超时则回收
		- workQueue：工作队列
			- 任务等待队列
			- 不同队列的选择
		- threadFactory：线程工厂
			- 创建新线程
			- 自定义线程属性
		- handler：拒绝策略
			- CallerRunsPolicy：调用者运行
			- AbortPolicy：抛出异常
			- DiscardPolicy：丢弃任务
			- DiscardOldestPolicy：丢弃最旧任务
	- 工作流程[[Java 多线程基础#^6266c2]]
		- 核心线程创建
			- 优先创建核心线程
			- 直到达到核心线程数
		- 任务队列处理
			- 核心线程满后进入队列
			- 队列满后创建临时线程
		- 线程池扩容
			- 临时线程的创建
			- 最大线程数限制
		- 拒绝策略触发
			- 队列满且达到最大线程数
			- 执行拒绝策略
	- 自定义拒绝策略
		- 可通过实现RejectedExecutionHandler接口自定义策略，例如记录日志或降级处理。
- 1.4.2 线程池种类[[Java 多线程基础#^25200c]]
	- FixedThreadPool
		- 固定线程数
			- 核心线程数等于最大线程数
			- 不会回收线程
		- 适用场景
			- 负载稳定的场景
			- CPU 密集型任务
	- SingleThreadExecutor
		- 单线程执行
			- 只有一个工作线程
			- 保证顺序执行
		- 顺序执行保证
			- 任务按照提交顺序执行
			- 适合串行任务
	- CachedThreadPool
		- 缓存线程池
			- 按需创建线程
			- 空闲线程回收
		- 灵活回收
			- 60 秒空闲回收
			- 适合短期异步任务
	- ScheduledThreadPool
		- 定时执行
			- 延迟执行
			- 周期性执行
		- 周期性任务
			- scheduleAtFixedRate
			- scheduleWithFixedDelay
	- 自定义线程池
		- 参数配置
			- 根据实际需求设置参数
			- 避免资源耗尽
		- 最佳实践
			- 根据任务特点选择队列
			- 合理配置线程数
			- 监控线程池状态

## 1.5 并发工具类
- 1.5.1 并发容器
	- ConcurrentHashMap[[Java 并发工具类#^be824f]]
		- 分段锁机制
			- JDK 1.7：Segment 分段锁
			- JDK 1.8：CAS + synchronized
		- 并发度优化
			- 桶级别的锁定
			- 红黑树优化
		- 读写性能
			- 读操作无锁
			- 写操作使用 CAS
	- CopyOnWriteArrayList
		- 写时复制
			- 修改操作创建新数组
			- 适合读多写少
		- 适用场景
			- 读多写少
			- 集合较小
	- BlockingQueue
		- ArrayBlockingQueue
			- 有界队列
			- 循环数组实现
		- LinkedBlockingQueue
			- 可选有界队列
			- 链表实现
		- PriorityBlockingQueue
			- 优先级队列
			- 自然排序
		- DelayQueue
			- 延迟获取
			- 优先级队列实现
- 1.5.2 原子类
	- 基本类型原子类
		- AtomicInteger
			- CAS 操作
			- 常用方法
		- AtomicLong
			- 64 位原子操作
			- 高并发优化
		- AtomicBoolean
			- 布尔类型原子操作
			- 状态标志
	- 数组原子类
		- AtomicIntegerArray
			- 整型数组原子操作
			- 索引访问
		- AtomicLongArray
			- 长整型数组
			- 批量原子操作
		- AtomicReferenceArray
			- 引用类型数组
			- 对象原子更新
	- 引用原子类
		- AtomicReference
			- 对象引用原子操作
			- CAS 更新
		- AtomicStampedReference
			- 带版本号的原子引用
			- 解决 ABA 问题
		- AtomicMarkableReference
			- 带标记的原子引用
			- 状态转换

## 1.6 并发设计模式
- 单例模式的线程安全实现
	- 双重检查锁定
		- volatile 关键字
		- synchronized 块
		- 注意指令重排
	- 静态内部类
		- 延迟加载
		- 线程安全
	- 枚举实现
		- 最安全的实现
		- 防止序列化问题
- 生产者-消费者模式
	- BlockingQueue 实现
		- 队列作为缓冲区
		- 自动的线程协作
	- wait/notify 实现
		- 显式的线程协作
		- 条件变量
- 线程池模式
	- 任务分发
		- 任务提交
		- 任务调度
	- 线程复用
		- 避免频繁创建销毁
		- 控制并发数
- Future 模式
	- 异步计算
		- 提交任务
		- 获取结果
	- 结果获取
		- 超时机制
		- 取消任务

## 1.7 实践经验
- 1.7.1 性能优化
	- 减少锁粒度
		- 缩小同步范围
		- 锁分解
		- 锁分段
	- 避免锁竞争
		- 合理使用锁
		- 减少锁持有时间
		- 锁粗化
	- 合理使用线程池
		- 线程数配置
		- 任务分配策略
		- 监控和调优
	- 注意伪共享问题
		- 缓存行对齐
		- @Contended 注解
		- 补齐字节
- 1.7.2 常见问题
	- 死锁问题
		- 产生原因
			- 互斥条件
			- 请求与保持
			- 不剥夺条件
			- 循环等待
		- 预防方法
			- 固定加锁顺序
			- 超时释放
			- 死锁检测
		- 检测和解决
			- jstack 分析
			- 线程转储
			- 预防措施
	- 活锁问题
		- 特点
			- 线程持续改变状态
			- 但无法继续执行
		- 解决方案
			- 引入随机等待
			- 退避策略
	- 线程饥饿
		- 原因分析
			- 优先级设置不当
			- 锁持有时间过长
			- 资源分配不公
		- 优化方法
			- 公平锁
			- 合理设置优先级
			- 资源分配策略