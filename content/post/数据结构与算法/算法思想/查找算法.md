---
title: "查找算法 (Searching Algorithms)"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 查找算法 (Searching Algorithms)

## 1. 基本查找算法

### 1.1 顺序查找 (Linear Search)

```java
public class LinearSearch {
    // 基本顺序查找
    public static int search(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i;  // 返回目标元素的索引
            }
        }
        return -1;  // 未找到目标元素
    }

    // 带哨兵的顺序查找（优化版本）
    public static int searchWithSentinel(int[] arr, int target) {
        int len = arr.length;
        int last = arr[len - 1];  // 保存最后一个元素
        arr[len - 1] = target;    // 设置哨兵

        int i = 0;
        while (arr[i] != target) {
            i++;
        }

        arr[len - 1] = last;  // 恢复最后一个元素
        if (i < len - 1 || arr[len - 1] == target) {
            return i;
        }
        return -1;
    }
}
```

### 1.2 二分查找 (Binary Search)

```java
public class BinarySearch {
    // 基本二分查找（递归版本）
    public static int searchRecursive(int[] arr, int target, int left, int right) {
        if (left > right) return -1;

        int mid = left + (right - left) / 2;  // 避免整数溢出

        if (arr[mid] == target) {
            return mid;
        } else if (arr[mid] > target) {
            return searchRecursive(arr, target, left, mid - 1);
        } else {
            return searchRecursive(arr, target, mid + 1, right);
        }
    }

    // 基本二分查找（迭代版本）
    public static int searchIterative(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return -1;
    }

    // 查找第一个等于目标值的元素
    public static int searchFirst(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (arr[mid] > target) {
                right = mid - 1;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                if (mid == 0 || arr[mid - 1] != target) {
                    return mid;
                }
                right = mid - 1;
            }
        }
        return -1;
    }

    // 查找最后一个等于目标值的元素
    public static int searchLast(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;

            if (arr[mid] > target) {
                right = mid - 1;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                if (mid == arr.length - 1 || arr[mid + 1] != target) {
                    return mid;
                }
                left = mid + 1;
            }
        }
        return -1;
    }
}
```

## 2. 树形查找

### 2.1 二叉搜索树查找 (BST Search)

```java
public class BSTSearch {
    class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;

        TreeNode(int val) {
            this.val = val;
        }
    }

    // 递归查找
    public TreeNode searchBST(TreeNode root, int target) {
        if (root == null || root.val == target) {
            return root;
        }

        if (target < root.val) {
            return searchBST(root.left, target);
        } else {
            return searchBST(root.right, target);
        }
    }

    // 迭代查找
    public TreeNode searchBSTIterative(TreeNode root, int target) {
        while (root != null && root.val != target) {
            root = target < root.val ? root.left : root.right;
        }
        return root;
    }
}
```

### 2.2 平衡树查找 (AVL/红黑树查找)

```java
public class BalancedTreeSearch {
    // AVL树节点
    class AVLNode {
        int val;
        AVLNode left;
        AVLNode right;
        int height;

        AVLNode(int val) {
            this.val = val;
            this.height = 1;
        }
    }

    // AVL树查找
    public AVLNode searchAVL(AVLNode root, int target) {
        if (root == null || root.val == target) {
            return root;
        }

        if (target < root.val) {
            return searchAVL(root.left, target);
        } else {
            return searchAVL(root.right, target);
        }
    }
}
```

## 3. 哈希查找 (Hash Search)

```java
public class HashSearch {
    class HashTable {
        private class Node {
            int key;
            int value;
            Node next;

            Node(int key, int value) {
                this.key = key;
                this.value = value;
            }
        }

        private Node[] table;
        private int size;
        private static final int DEFAULT_CAPACITY = 16;

        public HashTable() {
            table = new Node[DEFAULT_CAPACITY];
        }

        // 哈希函数
        private int hash(int key) {
            return key % table.length;
        }

        // 查找
        public Integer search(int key) {
            int index = hash(key);
            Node current = table[index];

            while (current != null) {
                if (current.key == key) {
                    return current.value;
                }
                current = current.next;
            }
            return null;
        }
    }
}
```

## 4. 性能分析

### 4.1 时间复杂度

| 算法       | 平均情况 | 最坏情况 | 空间复杂度 |
| ---------- | -------- | -------- | ---------- |
| 顺序查找   | O(n)     | O(n)     | O(1)       |
| 二分查找   | O(log n) | O(log n) | O(1)       |
| BST 查找   | O(log n) | O(n)     | O(1)       |
| 平衡树查找 | O(log n) | O(log n) | O(1)       |
| 哈希查找   | O(1)     | O(n)     | O(n)       |

### 4.2 适用场景

1. **顺序查找**

   - 适用于小规模数据
   - 数据无序
   - 很少查找的情况

2. **二分查找**

   - 适用于有序数据
   - 数据量较大
   - 静态数据集

3. **树形查找**

   - 需要动态维护数据
   - 需要范围查询
   - 需要有序遍历

4. **哈希查找**
   - 需要快速查找
   - 数据量大
   - 不需要有序性

## 5. 实践建议

### 5.1 算法选择

1. **数据规模**

   - 小规模：顺序查找
   - 中等规模：二分查找
   - 大规模：哈希查找

2. **数据特征**
   - 有序数据：二分查找
   - 动态数据：树形查找
   - 静态数据：哈希查找

### 5.2 优化策略

1. **二分查找优化**

   - 防止整数溢出
   - 处理重复元素
   - 边界条件处理

2. **树形查找优化**

   - 平衡维护
   - 缓存优化
   - 并发处理

3. **哈希查找优化**
   - 哈希函数设计
   - 冲突处理
   - 动态扩容

