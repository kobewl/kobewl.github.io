---
title: "迭代器模式（Iterator Pattern）"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 迭代器模式（Iterator Pattern）

## 概述

迭代器模式是一种行为型设计模式，它提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。这种模式将遍历集合的责任从集合中分离出来，放到专门的迭代器类中，使得集合的接口和实现能够独立变化。

## 使用场景

- 需要访问一个聚合对象的内容而无需暴露它的内部表示时
- 需要为遍历不同的聚合结构提供一个统一的接口时
- 需要支持对聚合对象的多种遍历方式时
- 需要为遍历不同的聚合类提供一个统一的接口时

## 基本实现

```java
// 迭代器接口
interface Iterator<T> {
    boolean hasNext();
    T next();
    void remove();
}

// 集合接口
interface Collection<T> {
    Iterator<T> iterator();
    void add(T element);
    void remove(T element);
    int size();
}

// 具体集合
class ConcreteCollection<T> implements Collection<T> {
    private List<T> list = new ArrayList<>();

    @Override
    public Iterator<T> iterator() {
        return new ConcreteIterator<>(this);
    }

    @Override
    public void add(T element) {
        list.add(element);
    }

    @Override
    public void remove(T element) {
        list.remove(element);
    }

    @Override
    public int size() {
        return list.size();
    }

    public T get(int index) {
        return list.get(index);
    }
}

// 具体迭代器
class ConcreteIterator<T> implements Iterator<T> {
    private ConcreteCollection<T> collection;
    private int position = 0;

    public ConcreteIterator(ConcreteCollection<T> collection) {
        this.collection = collection;
    }

    @Override
    public boolean hasNext() {
        return position < collection.size();
    }

    @Override
    public T next() {
        if (hasNext()) {
            return collection.get(position++);
        }
        throw new NoSuchElementException();
    }

    @Override
    public void remove() {
        if (position <= 0) {
            throw new IllegalStateException();
        }
        collection.remove(collection.get(--position));
    }
}
```

## 实际应用示例

以自定义的树形结构遍历为例：

```java
// 树节点类
class TreeNode<T> {
    private T data;
    private List<TreeNode<T>> children;

    public TreeNode(T data) {
        this.data = data;
        this.children = new ArrayList<>();
    }

    public void addChild(TreeNode<T> child) {
        children.add(child);
    }

    public T getData() {
        return data;
    }

    public List<TreeNode<T>> getChildren() {
        return children;
    }
}

// 树迭代器接口
interface TreeIterator<T> {
    boolean hasNext();
    TreeNode<T> next();
}

// 深度优先遍历迭代器
class DepthFirstIterator<T> implements TreeIterator<T> {
    private Stack<TreeNode<T>> stack = new Stack<>();

    public DepthFirstIterator(TreeNode<T> root) {
        stack.push(root);
    }

    @Override
    public boolean hasNext() {
        return !stack.isEmpty();
    }

    @Override
    public TreeNode<T> next() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }

        TreeNode<T> node = stack.pop();
        List<TreeNode<T>> children = node.getChildren();
        // 将子节点按照相反的顺序压入栈中，确保按照正确的顺序遍历
        for (int i = children.size() - 1; i >= 0; i--) {
            stack.push(children.get(i));
        }
        return node;
    }
}

// 广度优先遍历迭代器
class BreadthFirstIterator<T> implements TreeIterator<T> {
    private Queue<TreeNode<T>> queue = new LinkedList<>();

    public BreadthFirstIterator(TreeNode<T> root) {
        queue.offer(root);
    }

    @Override
    public boolean hasNext() {
        return !queue.isEmpty();
    }

    @Override
    public TreeNode<T> next() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }

        TreeNode<T> node = queue.poll();
        queue.addAll(node.getChildren());
        return node;
    }
}

// 树类
class Tree<T> {
    private TreeNode<T> root;

    public Tree(T rootData) {
        root = new TreeNode<>(rootData);
    }

    public TreeIterator<T> depthFirstIterator() {
        return new DepthFirstIterator<>(root);
    }

    public TreeIterator<T> breadthFirstIterator() {
        return new BreadthFirstIterator<>(root);
    }

    public TreeNode<T> getRoot() {
        return root;
    }
}
```

## 另一个实际示例：自定义集合遍历

```java
// 自定义集合类
class CustomCollection<T> {
    private T[] elements;
    private int size;
    private static final int DEFAULT_CAPACITY = 10;

    @SuppressWarnings("unchecked")
    public CustomCollection() {
        elements = (T[]) new Object[DEFAULT_CAPACITY];
        size = 0;
    }

    public void add(T element) {
        ensureCapacity();
        elements[size++] = element;
    }

    private void ensureCapacity() {
        if (size == elements.length) {
            elements = Arrays.copyOf(elements, size * 2);
        }
    }

    // 正向迭代器
    public ForwardIterator<T> forwardIterator() {
        return new ForwardIterator<>(this);
    }

    // 反向迭代器
    public ReverseIterator<T> reverseIterator() {
        return new ReverseIterator<>(this);
    }

    // 步进迭代器
    public StepIterator<T> stepIterator(int step) {
        return new StepIterator<>(this, step);
    }

    public T get(int index) {
        if (index >= size) {
            throw new IndexOutOfBoundsException();
        }
        return elements[index];
    }

    public int size() {
        return size;
    }
}

// 正向迭代器
class ForwardIterator<T> implements Iterator<T> {
    private CustomCollection<T> collection;
    private int position = 0;

    public ForwardIterator(CustomCollection<T> collection) {
        this.collection = collection;
    }

    @Override
    public boolean hasNext() {
        return position < collection.size();
    }

    @Override
    public T next() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }
        return collection.get(position++);
    }
}

// 反向迭代器
class ReverseIterator<T> implements Iterator<T> {
    private CustomCollection<T> collection;
    private int position;

    public ReverseIterator(CustomCollection<T> collection) {
        this.collection = collection;
        this.position = collection.size() - 1;
    }

    @Override
    public boolean hasNext() {
        return position >= 0;
    }

    @Override
    public T next() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }
        return collection.get(position--);
    }
}

// 步进迭代器
class StepIterator<T> implements Iterator<T> {
    private CustomCollection<T> collection;
    private int position = 0;
    private int step;

    public StepIterator(CustomCollection<T> collection, int step) {
        this.collection = collection;
        this.step = step;
    }

    @Override
    public boolean hasNext() {
        return position < collection.size();
    }

    @Override
    public T next() {
        if (!hasNext()) {
            throw new NoSuchElementException();
        }
        T element = collection.get(position);
        position += step;
        return element;
    }
}
```

## 优点

1. 支持以不同的方式遍历一个聚合对象，而不暴露其内部结构
2. 简化了聚合类，将遍历责任分离出来
3. 在同一个聚合上可以有多个遍历
4. 迭代器模式使得添加新的遍历方式变得容易

## 缺点

1. 对于比较简单的遍历，使用迭代器可能会增加系统的复杂性
2. 迭代器模式在某些情况下可能会在原有聚合对象的设计中增加额外的状态存储
3. 如果一个聚合对象有多种遍历方式，要为每种遍历方式都提供一个迭代器类，会增加系统的复杂度

## 适用场景

1. 访问一个聚合对象的内容而无需暴露它的内部表示
2. 需要为遍历不同的聚合结构提供一个统一的接口
3. 需要支持对聚合对象的多种遍历方式
4. 为遍历不同的聚合类提供一个统一的接口

## 注意事项

1. 迭代器模式就是分离了集合对象的遍历行为
2. 注意避免迭代器的状态与集合的状态不同步
3. 在并发环境下使用迭代器时要特别注意线程安全问题
4. 可以结合其他模式（如工厂模式）来创建迭代器

