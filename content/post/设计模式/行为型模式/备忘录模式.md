---
title: "备忘录模式（Memento Pattern）"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 备忘录模式（Memento Pattern）

## 概述

备忘录模式是一种行为型设计模式，它允许在不破坏封装性的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。这个模式在需要实现撤销/重做、存档/读档功能时特别有用。

## 使用场景

- 需要保存和恢复对象的状态时
- 需要实现撤销/重做功能时
- 需要在不破坏封装性的前提下保存对象的状态时
- 需要提供回滚操作时

## 基本实现

```java
// 备忘录类
class Memento {
    private String state;

    public Memento(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }
}

// 发起人类
class Originator {
    private String state;

    public void setState(String state) {
        this.state = state;
    }

    public String getState() {
        return state;
    }

    // 创建备忘录
    public Memento saveStateToMemento() {
        return new Memento(state);
    }

    // 从备忘录恢复状态
    public void getStateFromMemento(Memento memento) {
        state = memento.getState();
    }
}

// 管理者类
class Caretaker {
    private List<Memento> mementoList = new ArrayList<>();

    public void add(Memento state) {
        mementoList.add(state);
    }

    public Memento get(int index) {
        return mementoList.get(index);
    }
}
```

## 实际应用示例

以文本编辑器为例：

```java
// 文本编辑器状态备忘录
class TextEditorMemento {
    private String content;
    private int cursorPosition;
    private String selectedText;

    public TextEditorMemento(String content, int cursorPosition, String selectedText) {
        this.content = content;
        this.cursorPosition = cursorPosition;
        this.selectedText = selectedText;
    }

    // 只提供获取方法，不提供设置方法以保证封装性
    public String getContent() {
        return content;
    }

    public int getCursorPosition() {
        return cursorPosition;
    }

    public String getSelectedText() {
        return selectedText;
    }
}

// 文本编辑器类
class TextEditor {
    private String content;
    private int cursorPosition;
    private String selectedText;
    private Stack<TextEditorMemento> undoStack = new Stack<>();
    private Stack<TextEditorMemento> redoStack = new Stack<>();

    public TextEditor() {
        this.content = "";
        this.cursorPosition = 0;
        this.selectedText = "";
    }

    // 保存当前状态
    private void saveState() {
        undoStack.push(new TextEditorMemento(content, cursorPosition, selectedText));
        redoStack.clear(); // 新的操作会清空重做栈
    }

    // 输入文本
    public void type(String text) {
        saveState();
        if (selectedText.length() > 0) {
            // 如果有选中的文本，则替换它
            content = content.substring(0, cursorPosition - selectedText.length()) +
                     text + content.substring(cursorPosition);
        } else {
            // 在光标位置插入文本
            content = content.substring(0, cursorPosition) +
                     text + content.substring(cursorPosition);
        }
        cursorPosition += text.length();
        selectedText = "";
    }

    // 删除文本
    public void delete() {
        if (cursorPosition > 0) {
            saveState();
            if (selectedText.length() > 0) {
                // 删除选中的文本
                content = content.substring(0, cursorPosition - selectedText.length()) +
                         content.substring(cursorPosition);
                cursorPosition -= selectedText.length();
                selectedText = "";
            } else {
                // 删除光标前的一个字符
                content = content.substring(0, cursorPosition - 1) +
                         content.substring(cursorPosition);
                cursorPosition--;
            }
        }
    }

    // 选择文本
    public void select(int start, int end) {
        if (start >= 0 && end <= content.length() && start <= end) {
            cursorPosition = end;
            selectedText = content.substring(start, end);
        }
    }

    // 撤销操作
    public void undo() {
        if (!undoStack.isEmpty()) {
            // 保存当前状态到重做栈
            redoStack.push(new TextEditorMemento(content, cursorPosition, selectedText));
            // 恢复之前的状态
            TextEditorMemento memento = undoStack.pop();
            restoreState(memento);
        }
    }

    // 重做操作
    public void redo() {
        if (!redoStack.isEmpty()) {
            // 保存当前状态到撤销栈
            undoStack.push(new TextEditorMemento(content, cursorPosition, selectedText));
            // 恢复之后的状态
            TextEditorMemento memento = redoStack.pop();
            restoreState(memento);
        }
    }

    // 恢复状态
    private void restoreState(TextEditorMemento memento) {
        this.content = memento.getContent();
        this.cursorPosition = memento.getCursorPosition();
        this.selectedText = memento.getSelectedText();
    }

    // 获取当前内容
    public String getContent() {
        return content;
    }
}
```

## 另一个实际示例：游戏存档系统

```java
// 游戏存档
class GameMemento {
    private final int level;
    private final int score;
    private final List<String> inventory;
    private final Date saveTime;

    public GameMemento(int level, int score, List<String> inventory) {
        this.level = level;
        this.score = score;
        this.inventory = new ArrayList<>(inventory);
        this.saveTime = new Date();
    }

    // getter方法
    public int getLevel() { return level; }
    public int getScore() { return score; }
    public List<String> getInventory() { return new ArrayList<>(inventory); }
    public Date getSaveTime() { return saveTime; }
}

// 游戏类
class Game {
    private int level;
    private int score;
    private List<String> inventory;

    public Game() {
        this.level = 1;
        this.score = 0;
        this.inventory = new ArrayList<>();
    }

    // 创建存档
    public GameMemento save() {
        return new GameMemento(level, score, inventory);
    }

    // 读取存档
    public void restore(GameMemento memento) {
        this.level = memento.getLevel();
        this.score = memento.getScore();
        this.inventory = memento.getInventory();
    }

    // 游戏进展相关方法
    public void levelUp() {
        level++;
    }

    public void addScore(int points) {
        score += points;
    }

    public void addItem(String item) {
        inventory.add(item);
    }

    // 获取游戏状态
    public String getGameState() {
        return String.format("Level: %d, Score: %d, Items: %s",
            level, score, String.join(", ", inventory));
    }
}

// 存档管理器
class GameSaveManager {
    private Map<String, GameMemento> saves = new HashMap<>();

    // 保存游戏
    public void saveGame(String saveName, Game game) {
        saves.put(saveName, game.save());
        System.out.println("游戏已保存: " + saveName);
    }

    // 加载游戏
    public void loadGame(String saveName, Game game) {
        GameMemento memento = saves.get(saveName);
        if (memento != null) {
            game.restore(memento);
            System.out.println("游戏已加载: " + saveName);
        } else {
            System.out.println("存档不存在: " + saveName);
        }
    }

    // 获取所有存档
    public List<String> getAllSaves() {
        return new ArrayList<>(saves.keySet());
    }

    // 获取存档信息
    public String getSaveInfo(String saveName) {
        GameMemento memento = saves.get(saveName);
        if (memento != null) {
            return String.format("存档: %s, 等级: %d, 分数: %d, 保存时间: %s",
                saveName, memento.getLevel(), memento.getScore(), memento.getSaveTime());
        }
        return "存档不存在: " + saveName;
    }
}
```

## 优点

1. 提供了一种可以恢复状态的机制
2. 实现了信息的封装，客户端不需要关心状态的保存细节
3. 提供了容易实现的恢复机制
4. 可以保证对象状态的完整性

## 缺点

1. 如果需要保存的状态较多，会占用较大的内存空间
2. 如果发起人对象的状态变化频繁，可能会导致大量的备忘录对象被创建
3. 可能需要管理大量的备忘录对象

## 适用场景

1. 需要提供撤销/重做功能的场景
2. 需要保存和恢复数据的场景
3. 需要监控对象状态的变化，并在某个时刻恢复状态的场景
4. 需要防止外界直接访问对象状态，但又需要保存和恢复状态的场景

## 注意事项

1. 注意备忘录的存储位置和生命周期管理
2. 注意内存的使用，可以考虑使用压缩或清理机制
3. 在多线程环境下需要考虑同步问题
4. 可以结合其他模式（如命令模式）来实现更复杂的功能

