---
title: "命令模式（Command Pattern）"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 命令模式（Command Pattern）

## 概述

命令模式是一种行为型设计模式，它将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。这种模式将请求的发送者和接收者解耦，使得系统更加灵活。

## 使用场景

- 需要将请求的发送者和接收者解耦时
- 需要将请求参数化时
- 需要支持请求的排队、记录日志或撤销/重做功能时
- 需要支持事务操作时
- GUI 中的菜单项、按钮等操作的实现

## 基本实现

```java
// 命令接口
interface Command {
    void execute();
    void undo();
}

// 接收者
class Receiver {
    public void action() {
        System.out.println("接收者执行请求");
    }

    public void undoAction() {
        System.out.println("接收者撤销请求");
    }
}

// 具体命令
class ConcreteCommand implements Command {
    private Receiver receiver;

    public ConcreteCommand(Receiver receiver) {
        this.receiver = receiver;
    }

    @Override
    public void execute() {
        receiver.action();
    }

    @Override
    public void undo() {
        receiver.undoAction();
    }
}

// 调用者
class Invoker {
    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    public void executeCommand() {
        command.execute();
    }

    public void undoCommand() {
        command.undo();
    }
}
```

## 实际应用示例

以智能家居遥控器为例：

```java
// 电器接口
interface HomeAppliance {
    void on();
    void off();
    void setLevel(int level);
}

// 具体电器：电灯
class Light implements HomeAppliance {
    private String location;
    private int level;

    public Light(String location) {
        this.location = location;
    }

    @Override
    public void on() {
        System.out.println(location + "的灯打开了");
    }

    @Override
    public void off() {
        System.out.println(location + "的灯关闭了");
    }

    @Override
    public void setLevel(int level) {
        this.level = level;
        System.out.println(location + "的灯亮度设置为" + level);
    }
}

// 具体电器：空调
class AirConditioner implements HomeAppliance {
    private String location;
    private int temperature;

    public AirConditioner(String location) {
        this.location = location;
    }

    @Override
    public void on() {
        System.out.println(location + "的空调打开了");
    }

    @Override
    public void off() {
        System.out.println(location + "的空调关闭了");
    }

    @Override
    public void setLevel(int temperature) {
        this.temperature = temperature;
        System.out.println(location + "的空调温度设置为" + temperature);
    }
}

// 命令接口
interface Command {
    void execute();
    void undo();
}

// 开启命令
class TurnOnCommand implements Command {
    private HomeAppliance appliance;

    public TurnOnCommand(HomeAppliance appliance) {
        this.appliance = appliance;
    }

    @Override
    public void execute() {
        appliance.on();
    }

    @Override
    public void undo() {
        appliance.off();
    }
}

// 关闭命令
class TurnOffCommand implements Command {
    private HomeAppliance appliance;

    public TurnOffCommand(HomeAppliance appliance) {
        this.appliance = appliance;
    }

    @Override
    public void execute() {
        appliance.off();
    }

    @Override
    public void undo() {
        appliance.on();
    }
}

// 调节命令
class SetLevelCommand implements Command {
    private HomeAppliance appliance;
    private int oldLevel;
    private int newLevel;

    public SetLevelCommand(HomeAppliance appliance, int level) {
        this.appliance = appliance;
        this.newLevel = level;
    }

    @Override
    public void execute() {
        appliance.setLevel(newLevel);
    }

    @Override
    public void undo() {
        appliance.setLevel(oldLevel);
    }
}

// 遥控器（调用者）
class RemoteControl {
    private Command[] onCommands;
    private Command[] offCommands;
    private Stack<Command> commandHistory;

    public RemoteControl() {
        onCommands = new Command[5];
        offCommands = new Command[5];
        commandHistory = new Stack<>();

        Command noCommand = new NoCommand();
        for (int i = 0; i < 5; i++) {
            onCommands[i] = noCommand;
            offCommands[i] = noCommand;
        }
    }

    public void setCommand(int slot, Command onCommand, Command offCommand) {
        onCommands[slot] = onCommand;
        offCommands[slot] = offCommand;
    }

    public void onButtonPressed(int slot) {
        onCommands[slot].execute();
        commandHistory.push(onCommands[slot]);
    }

    public void offButtonPressed(int slot) {
        offCommands[slot].execute();
        commandHistory.push(offCommands[slot]);
    }

    public void undoButtonPressed() {
        if (!commandHistory.isEmpty()) {
            Command command = commandHistory.pop();
            command.undo();
        }
    }
}
```

## 另一个实际示例：文本编辑器的撤销重做功能

```java
// 文本编辑器类
class TextEditor {
    private StringBuilder content;
    private String clipboard;

    public TextEditor() {
        content = new StringBuilder();
    }

    public void insert(String text, int position) {
        content.insert(position, text);
    }

    public void delete(int position, int length) {
        content.delete(position, position + length);
    }

    public void copy(int position, int length) {
        clipboard = content.substring(position, position + length);
    }

    public void paste(int position) {
        content.insert(position, clipboard);
    }

    public String getContent() {
        return content.toString();
    }
}

// 编辑命令接口
interface EditCommand {
    void execute();
    void undo();
}

// 插入文本命令
class InsertCommand implements EditCommand {
    private TextEditor editor;
    private String text;
    private int position;

    public InsertCommand(TextEditor editor, String text, int position) {
        this.editor = editor;
        this.text = text;
        this.position = position;
    }

    @Override
    public void execute() {
        editor.insert(text, position);
    }

    @Override
    public void undo() {
        editor.delete(position, text.length());
    }
}

// 删除文本命令
class DeleteCommand implements EditCommand {
    private TextEditor editor;
    private String deletedText;
    private int position;

    public DeleteCommand(TextEditor editor, int position, int length) {
        this.editor = editor;
        this.position = position;
        this.deletedText = editor.getContent().substring(position, position + length);
    }

    @Override
    public void execute() {
        editor.delete(position, deletedText.length());
    }

    @Override
    public void undo() {
        editor.insert(deletedText, position);
    }
}

// 编辑器命令管理器
class EditorCommandManager {
    private Stack<EditCommand> undoStack = new Stack<>();
    private Stack<EditCommand> redoStack = new Stack<>();

    public void executeCommand(EditCommand command) {
        command.execute();
        undoStack.push(command);
        redoStack.clear();  // 执行新命令后清空重做栈
    }

    public void undo() {
        if (!undoStack.isEmpty()) {
            EditCommand command = undoStack.pop();
            command.undo();
            redoStack.push(command);
        }
    }

    public void redo() {
        if (!redoStack.isEmpty()) {
            EditCommand command = redoStack.pop();
            command.execute();
            undoStack.push(command);
        }
    }
}
```

## 优点

1. 降低了系统的耦合度，将请求的发送者和接收者解耦
2. 新的命令可以很容易地加入到系统中
3. 可以比较容易地设计一个命令队列和宏命令
4. 可以方便地实现对请求的撤销和重做

## 缺点

1. 可能会导致某些系统有过多的具体命令类
2. 系统复杂度增加

## 适用场景

1. 系统需要将请求调用者和请求接收者解耦时
2. 系统需要在不同的时间指定请求、将请求排队和执行请求
3. 系统需要支持命令的撤销和恢复功能
4. 系统需要将一组操作组合在一起形成宏命令

## 注意事项

1. 命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开
2. 命令模式使用的场景：需要抽象出待执行的动作，然后以参数的形式提供出来
3. 使用命令模式，请求发送者和请求接收者之间的耦合度降低，使得系统更容易扩展
4. 命令模式可以结合责任链模式，实现命令的链式处理

