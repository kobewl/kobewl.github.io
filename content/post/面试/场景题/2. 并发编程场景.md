---
title: "1 并发编程场景题"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 1 并发编程场景题

## 1.1 生产者消费者问题

### 1.1.1 场景描述

实现一个线程安全的生产者消费者模型。

### 1.1.2 核心要求

- 使用阻塞队列实现
- 保证线程安全
- 避免死锁
- 控制队列大小

### 1.1.3 示例代码

```java
// 使用 BlockingQueue 实现
public class ProducerConsumer {
    private BlockingQueue<Integer> queue;
    private static final int QUEUE_SIZE = 10;

    public ProducerConsumer() {
        queue = new LinkedBlockingQueue<>(QUEUE_SIZE);
    }

    // Producer 实现
    class Producer implements Runnable {
        public void run() {
            try {
                while (true) {
                    queue.put(produce());
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        private Integer produce() {
            // 生产逻辑
            return new Random().nextInt(100);
        }
    }

    // Consumer 实现
    class Consumer implements Runnable {
        public void run() {
            try {
                while (true) {
                    consume(queue.take());
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        private void consume(Integer value) {
            // 消费逻辑
        }
    }
}
```

## 1.2 银行转账问题

### 1.2.1 场景描述

实现一个线程安全的银行转账系统。

### 1.2.2 核心要求

- 保证转账原子性
- 避免死锁
- 处理并发转账
- 保证数据一致性

### 1.2.3 示例代码

```java
public class BankAccount {
    private double balance;
    private final ReentrantLock lock = new ReentrantLock();

    public BankAccount(double initialBalance) {
        this.balance = initialBalance;
    }

    public void transfer(BankAccount target, double amount) {
        // 使用 try-finally 确保锁的释放
        lock.lock();
        try {
            if (this.balance < amount) {
                throw new InsufficientFundsException();
            }
            this.balance -= amount;
            target.deposit(amount);
        } finally {
            lock.unlock();
        }
    }

    private void deposit(double amount) {
        lock.lock();
        try {
            this.balance += amount;
        } finally {
            lock.unlock();
        }
    }
}
```

## 1.3 线程池任务调度问题

### 1.3.1 场景描述

设计一个支持优先级的线程池任务调度系统。

### 1.3.2 核心要求

- 支持任务优先级
- 控制线程池大小
- 处理任务超时
- 优雅关闭线程池

### 1.3.3 解决方案

[详细设计方案...]

