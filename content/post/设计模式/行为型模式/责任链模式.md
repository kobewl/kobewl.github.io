---
title: "责任链模式（Chain of Responsibility Pattern）"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 责任链模式（Chain of Responsibility Pattern）

## 概述

责任链模式是一种行为设计模式，它允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，或将其传递给链中的下个处理者。这种模式通过将请求和处理者解耦，使得多个对象都有机会处理请求。

## 使用场景

- 需要对一个请求进行多级处理时
- 需要在不明确指定接收者的情况下，向多个对象中的一个提交一个请求
- 有多个对象可以处理一个请求，但具体由哪个对象处理在运行时确定
- 想要动态地指定一组对象处理请求时

## 基本实现

```java
// 抽象处理者
abstract class Handler {
    protected Handler successor;

    public void setSuccessor(Handler successor) {
        this.successor = successor;
    }

    public abstract void handleRequest(int request);
}

// 具体处理者A
class ConcreteHandlerA extends Handler {
    @Override
    public void handleRequest(int request) {
        if (request >= 0 && request < 10) {
            System.out.println("处理者A处理请求: " + request);
        } else if (successor != null) {
            successor.handleRequest(request);
        }
    }
}

// 具体处理者B
class ConcreteHandlerB extends Handler {
    @Override
    public void handleRequest(int request) {
        if (request >= 10 && request < 20) {
            System.out.println("处理者B处理请求: " + request);
        } else if (successor != null) {
            successor.handleRequest(request);
        }
    }
}

// 具体处理者C
class ConcreteHandlerC extends Handler {
    @Override
    public void handleRequest(int request) {
        if (request >= 20 && request < 30) {
            System.out.println("处理者C处理请求: " + request);
        } else if (successor != null) {
            successor.handleRequest(request);
        }
    }
}
```

## 实际应用示例

以日志记录系统为例：

```java
// 日志级别枚举
enum LogLevel {
    INFO(1), DEBUG(2), ERROR(3);

    private int level;

    LogLevel(int level) {
        this.level = level;
    }

    public int getLevel() {
        return level;
    }
}

// 日志消息类
class LogMessage {
    private LogLevel level;
    private String message;

    public LogMessage(LogLevel level, String message) {
        this.level = level;
        this.message = message;
    }

    public LogLevel getLevel() {
        return level;
    }

    public String getMessage() {
        return message;
    }
}

// 抽象日志处理者
abstract class LogHandler {
    protected LogHandler nextHandler;
    protected LogLevel level;

    public LogHandler(LogLevel level) {
        this.level = level;
    }

    public void setNextHandler(LogHandler nextHandler) {
        this.nextHandler = nextHandler;
    }

    public void handleLog(LogMessage logMessage) {
        if (logMessage.getLevel().getLevel() <= this.level.getLevel()) {
            write(logMessage);
        }
        if (nextHandler != null) {
            nextHandler.handleLog(logMessage);
        }
    }

    protected abstract void write(LogMessage logMessage);
}

// 控制台日志处理者
class ConsoleLogHandler extends LogHandler {
    public ConsoleLogHandler(LogLevel level) {
        super(level);
    }

    @Override
    protected void write(LogMessage logMessage) {
        System.out.println("控制台日志: " + logMessage.getMessage());
    }
}

// 文件日志处理者
class FileLogHandler extends LogHandler {
    public FileLogHandler(LogLevel level) {
        super(level);
    }

    @Override
    protected void write(LogMessage logMessage) {
        System.out.println("文件日志: " + logMessage.getMessage());
    }
}

// 邮件日志处理者
class EmailLogHandler extends LogHandler {
    public EmailLogHandler(LogLevel level) {
        super(level);
    }

    @Override
    protected void write(LogMessage logMessage) {
        System.out.println("邮件日志: " + logMessage.getMessage());
    }
}

// 使用示例
class LoggerDemo {
    public static void main(String[] args) {
        // 创建处理链
        LogHandler consoleHandler = new ConsoleLogHandler(LogLevel.INFO);
        LogHandler fileHandler = new FileLogHandler(LogLevel.DEBUG);
        LogHandler emailHandler = new EmailLogHandler(LogLevel.ERROR);

        // 设置处理链
        consoleHandler.setNextHandler(fileHandler);
        fileHandler.setNextHandler(emailHandler);

        // 处理不同级别的日志
        consoleHandler.handleLog(new LogMessage(LogLevel.INFO, "这是一条信息日志"));
        consoleHandler.handleLog(new LogMessage(LogLevel.DEBUG, "这是一条调试日志"));
        consoleHandler.handleLog(new LogMessage(LogLevel.ERROR, "这是一条错误日志"));
    }
}
```

## 另一个实际示例：请假审批系统

```java
// 请假请求类
class LeaveRequest {
    private String employeeName;
    private int leaveDays;
    private String reason;

    public LeaveRequest(String employeeName, int leaveDays, String reason) {
        this.employeeName = employeeName;
        this.leaveDays = leaveDays;
        this.reason = reason;
    }

    // getter方法
    public String getEmployeeName() { return employeeName; }
    public int getLeaveDays() { return leaveDays; }
    public String getReason() { return reason; }
}

// 抽象审批者
abstract class Approver {
    protected Approver nextApprover;
    protected String name;

    public Approver(String name) {
        this.name = name;
    }

    public void setNextApprover(Approver nextApprover) {
        this.nextApprover = nextApprover;
    }

    public abstract void processRequest(LeaveRequest request);
}

// 主管审批
class Supervisor extends Approver {
    public Supervisor(String name) {
        super(name);
    }

    @Override
    public void processRequest(LeaveRequest request) {
        if (request.getLeaveDays() <= 3) {
            System.out.println("主管" + name + "批准" + request.getEmployeeName() +
                "的" + request.getLeaveDays() + "天请假申请");
        } else if (nextApprover != null) {
            System.out.println("主管" + name + "无权批准，转交给上级");
            nextApprover.processRequest(request);
        }
    }
}

// 部门经理审批
class DepartmentManager extends Approver {
    public DepartmentManager(String name) {
        super(name);
    }

    @Override
    public void processRequest(LeaveRequest request) {
        if (request.getLeaveDays() <= 7) {
            System.out.println("部门经理" + name + "批准" + request.getEmployeeName() +
                "的" + request.getLeaveDays() + "天请假申请");
        } else if (nextApprover != null) {
            System.out.println("部门经理" + name + "无权批准，转交给上级");
            nextApprover.processRequest(request);
        }
    }
}

// 总经理审批
class GeneralManager extends Approver {
    public GeneralManager(String name) {
        super(name);
    }

    @Override
    public void processRequest(LeaveRequest request) {
        if (request.getLeaveDays() <= 30) {
            System.out.println("总经理" + name + "批准" + request.getEmployeeName() +
                "的" + request.getLeaveDays() + "天请假申请");
        } else {
            System.out.println("请假天数过长，不予批准");
        }
    }
}
```

## 优点

1. 降低了请求的发送者和接收者之间的耦合度
2. 增强了系统的可扩展性，可以根据需要增加新的处理者
3. 增强了给对象指派职责的灵活性
4. 符合开闭原则，无需修改现有代码即可添加新的处理者

## 缺点

1. 不能保证请求一定会被处理
2. 可能会形成较长的处理链，影响系统性能
3. 可能会导致系统调试困难，特别是在链比较长的时候

## 适用场景

1. 有多个对象可以处理同一个请求，但具体由哪个对象处理在运行时动态确定
2. 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求
3. 需要动态指定一组对象处理请求时

## 注意事项

1. 注意避免链过长导致的性能问题
2. 注意设置合适的处理顺序
3. 注意处理请求传递的终止条件
4. 可以考虑在链中实现双向传递

