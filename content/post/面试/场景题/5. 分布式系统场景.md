---
title: "分布式系统场景题"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 分布式系统场景题

## 1. 分布式锁实现

### 场景描述

在分布式环境下实现一个高可用的分布式锁。

### 核心要求

- 保证互斥性
- 防止死锁
- 高可用性
- 支持重入

### 实现方案

1. 基于 Redis 的分布式锁

```java
public class RedisDistributedLock {
    private StringRedisTemplate redisTemplate;
    private static final String LOCK_PREFIX = "distributed_lock:";
    private static final long DEFAULT_EXPIRE = 30000L; // 30秒

    public boolean tryLock(String key, String requestId, long expireTime) {
        String lockKey = LOCK_PREFIX + key;
        // 使用 SET NX 命令
        return redisTemplate.opsForValue()
            .setIfAbsent(lockKey, requestId, expireTime, TimeUnit.MILLISECONDS);
    }

    public boolean releaseLock(String key, String requestId) {
        String lockKey = LOCK_PREFIX + key;
        // 使用 Lua 脚本保证原子性
        String script = "if redis.call('get', KEYS[1]) == ARGV[1] then " +
                       "return redis.call('del', KEYS[1]) else return 0 end";
        return redisTemplate.execute(new DefaultRedisScript<>(script, Boolean.class),
            Collections.singletonList(lockKey), requestId);
    }
}
```

2. 基于 Zookeeper 的分布式锁

```java
public class ZookeeperDistributedLock {
    private CuratorFramework client;
    private static final String LOCK_PATH = "/distributed_lock/";

    public boolean tryLock(String key) throws Exception {
        String lockPath = LOCK_PATH + key;
        try {
            // 创建临时节点
            client.create()
                .creatingParentsIfNeeded()
                .withMode(CreateMode.EPHEMERAL)
                .forPath(lockPath);
            return true;
        } catch (NodeExistsException e) {
            return false;
        }
    }
}
```

## 2. 分布式事务实现

### 场景描述

实现一个满足 CAP 理论的分布式事务系统。

### 核心要求

- 保证数据一致性
- 处理网络异常
- 支持事务回滚
- 高性能

### 实现方案

1. 基于 2PC 的实现

```java
public class TwoPhaseCommit {
    private List<ResourceManager> resourceManagers;

    public boolean execute(Transaction tx) {
        // 准备阶段
        boolean canCommit = prepare(tx);
        if (!canCommit) {
            rollback(tx);
            return false;
        }

        // 提交阶段
        return commit(tx);
    }

    private boolean prepare(Transaction tx) {
        return resourceManagers.stream()
            .allMatch(rm -> rm.prepare(tx));
    }

    private void rollback(Transaction tx) {
        resourceManagers.forEach(rm -> rm.rollback(tx));
    }
}
```

## 3. 服务发现与注册

### 场景描述

设计一个服务发现与注册系统。

### 核心要求

- 服务自动注册
- 服务健康检查
- 负载均衡
- 容错处理

### 实现方案

```java
@Service
public class ServiceRegistry {
    private final DiscoveryClient discoveryClient;

    public void registerService(ServiceInstance instance) {
        // 注册服务实例
        discoveryClient.register(instance);

        // 启动健康检查
        startHealthCheck(instance);
    }

    private void startHealthCheck(ServiceInstance instance) {
        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
        executor.scheduleAtFixedRate(() -> {
            if (!isHealthy(instance)) {
                discoveryClient.deregister(instance);
            }
        }, 30, 30, TimeUnit.SECONDS);
    }

    public List<ServiceInstance> getServices(String serviceId) {
        return discoveryClient.getInstances(serviceId);
    }
}
```

