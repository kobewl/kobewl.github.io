---
title: "分布式消息"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 分布式消息

## 消息队列原理

### 基础架构

1. **生产者-消费者模型**

```java
// 生产者实现
public class Producer {
    private MessageQueue queue;

    public void send(Message message) {
        // 消息持久化
        String msgId = persistMessage(message);
        // 发送消息
        queue.send(msgId, message);
        // 确认发送结果
        confirmSend(msgId);
    }
}

// 消费者实现
public class Consumer {
    private MessageQueue queue;

    public void consume() {
        while (true) {
            Message message = queue.receive();
            try {
                // 处理消息
                processMessage(message);
                // 确认消费
                queue.ack(message.getId());
            } catch (Exception e) {
                // 处理失败，重试或死信队列
                handleFailure(message);
            }
        }
    }
}
```

2. **消息存储**

```java
public class MessageStore {
    // 消息持久化
    public void store(Message message) {
        // 写入磁盘
        String filePath = getStorePath(message);
        writeToFile(filePath, message);
        // 更新索引
        updateIndex(message);
    }

    // 消息读取
    public Message read(String messageId) {
        // 查找索引
        String filePath = findMessagePath(messageId);
        // 读取消息
        return readFromFile(filePath);
    }
}
```

## 消息幂等性

### 实现方案

1. **全局消息 ID**

```java
public class MessageIdGenerator {
    private static final String MACHINE_ID = "001";
    private AtomicLong sequence = new AtomicLong(0);

    public String generateId() {
        long timestamp = System.currentTimeMillis();
        long seq = sequence.incrementAndGet();
        return String.format("%d-%s-%d", timestamp, MACHINE_ID, seq);
    }
}
```

2. **幂等性检查**

```java
public class IdempotencyChecker {
    private Cache<String, Boolean> processedMessages;

    public boolean isProcessed(String messageId) {
        return processedMessages.containsKey(messageId);
    }

    public void markAsProcessed(String messageId) {
        processedMessages.put(messageId, true);
    }

    // 使用示例
    public void processMessage(Message message) {
        if (!isProcessed(message.getId())) {
            try {
                // 处理消息
                doProcess(message);
                // 标记为已处理
                markAsProcessed(message.getId());
            } catch (Exception e) {
                // 处理异常
            }
        }
    }
}
```

## 可靠性投递

### 确认机制

1. **生产者确认**

```java
public class ReliableProducer {
    // 同步确认
    public boolean sendWithConfirm(Message message) {
        String msgId = send(message);
        return waitForConfirm(msgId, timeout);
    }

    // 异步确认
    public void sendAsync(Message message, Callback callback) {
        String msgId = send(message);
        registerCallback(msgId, callback);
    }
}
```

2. **消费者确认**

```java
public class ReliableConsumer {
    public void consumeWithAck(Message message) {
        try {
            // 处理消息
            processMessage(message);
            // 手动确认
            ack(message.getId());
        } catch (Exception e) {
            // 消费失败，拒绝消息
            nack(message.getId());
        }
    }
}
```

### 消息重试

```java
public class RetryManager {
    private Map<String, Integer> retryCount;
    private Queue<RetryMessage> retryQueue;

    public void retry(Message message) {
        int count = retryCount.getOrDefault(message.getId(), 0);
        if (count < maxRetryCount) {
            // 增加重试次数
            retryCount.put(message.getId(), count + 1);
            // 加入重试队列
            retryQueue.offer(new RetryMessage(message,
                System.currentTimeMillis() + getRetryDelay(count)));
        } else {
            // 超过重试次数，进入死信队列
            moveToDeadLetter(message);
        }
    }

    private long getRetryDelay(int retryCount) {
        // 指数退避策略
        return (long) (Math.pow(2, retryCount) * baseDelay);
    }
}
```

## 高级特性

### 消息顺序性

```java
public class OrderedMessageQueue {
    private Map<String, Queue<Message>> partitionedQueues;

    // 发送消息到指定分区
    public void send(String partition, Message message) {
        Queue<Message> queue = partitionedQueues.get(partition);
        queue.offer(message);
    }

    // 顺序消费
    public void consume(String partition) {
        Queue<Message> queue = partitionedQueues.get(partition);
        Message message = queue.poll();
        if (message != null) {
            processInOrder(message);
        }
    }
}
```

### 消息过滤

```java
public class MessageFilter {
    private List<FilterRule> rules;

    public boolean shouldProcess(Message message) {
        return rules.stream()
                   .allMatch(rule -> rule.match(message));
    }

    // 标签过滤
    public class TagFilter implements FilterRule {
        private Set<String> tags;

        @Override
        public boolean match(Message message) {
            return tags.contains(message.getTag());
        }
    }
}
```

## 最佳实践

1. **消息设计**

   - 合理的消息格式
   - 消息分区策略
   - 消息优先级

2. **可靠性保证**

   - 消息持久化
   - 确认机制
   - 失败重试

3. **性能优化**

   - 批量处理
   - 异步发送
   - 合理的队列大小

4. **监控告警**
   - 消息堆积
   - 处理延迟
   - 失败率统计

## 注意事项

1. **消息幂等性**

   - 全局消息 ID
   - 幂等性检查
   - 状态存储

2. **消息顺序性**

   - 分区顺序
   - 全局顺序
   - 重试策略

3. **异常处理**
   - 死信队列
   - 重试机制
   - 监控告警

