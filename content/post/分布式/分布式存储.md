---
title: "分布式存储"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 分布式存储

## 分布式缓存

### Redis 集群

#### 1. 主从复制（Master-Slave）

主从复制是 Redis 实现高可用的最基础方案。

**原理**：

- Master 负责读写，Slave 负责读和数据备份
- Master 将数据变更同步给 Slave
- 支持链式复制（Slave 可以是另一个 Slave 的 Master）

**实现方式**：

```java
// master配置
port 6379
bind 127.0.0.1

// slave配置
port 6380
slaveof 127.0.0.1 6379
```

**优点**：

- 实现简单，部署方便
- 读写分离，提高系统吞吐量
- 数据备份，提高可用性

**缺点**：

- Master 故障时需要手动切换
- 不能自动故障转移
- Master 压力大，容易成为性能瓶颈

#### 2. 哨兵模式（Sentinel）

哨兵模式是 Redis 实现高可用的标准方案。

**原理**：

- 哨兵节点监控 Master 和 Slave 的状态
- 当 Master 故障时，自动选举新的 Master
- 通知客户端新 Master 的地址
- 在 Master 恢复后，将其作为 Slave 加入集群

**实现方式**：

```java
// 哨兵配置
sentinel monitor mymaster 127.0.0.1 6379 2  // 2表示判定Master下线需要2个哨兵同意
sentinel down-after-milliseconds mymaster 5000  // Master无响应5秒判定下线
sentinel failover-timeout mymaster 60000  // 故障转移超时时间
sentinel parallel-syncs mymaster 1  // 同时同步的slave数量

// 哨兵工作示例
public class SentinelExample {
    private JedisSentinelPool sentinelPool;

    public void init() {
        Set<String> sentinels = new HashSet<>();
        sentinels.add("127.0.0.1:26379");
        sentinels.add("127.0.0.1:26380");
        sentinels.add("127.0.0.1:26381");

        sentinelPool = new JedisSentinelPool("mymaster", sentinels);
    }

    public void execute() {
        try (Jedis jedis = sentinelPool.getResource()) {
            // 自动连接到当前的Master
            jedis.set("key", "value");
        }
    }
}
```

**优点**：

- 自动故障检测和转移
- 多哨兵互相监控，避免单点故障
- 客户端无需关心 Master 地址变化

**缺点**：

- 部署较为复杂
- 资源消耗较大
- 在网络分区时可能产生脑裂

#### 3. 集群模式（Cluster）

集群模式是 Redis 实现分布式存储和高可用的终极方案。

**原理**：

- 数据自动分片，分布在多个节点上
- 每个节点都是 Master-Slave 架构
- 使用一致性哈希进行数据分片
- 支持动态扩容和缩容

**实现方式**：

```java
// Redis集群配置
cluster-enabled yes  // 启用集群模式
cluster-config-file nodes.conf  // 集群配置文件
cluster-node-timeout 5000  // 节点超时时间
cluster-slave-validity-factor 10  // slave有效因子
cluster-migration-barrier 1  // 迁移屏障
cluster-require-full-coverage yes  // 需要全覆盖

// 集群操作示例
public class ClusterExample {
    private JedisCluster jedisCluster;

    public void init() {
        Set<HostAndPort> nodes = new HashSet<>();
        nodes.add(new HostAndPort("127.0.0.1", 7001));
        nodes.add(new HostAndPort("127.0.0.1", 7002));
        nodes.add(new HostAndPort("127.0.0.1", 7003));

        jedisCluster = new JedisCluster(nodes);
    }

    public void execute() {
        // 自动根据key路由到正确的节点
        jedisCluster.set("key", "value");
        String value = jedisCluster.get("key");
    }
}

// 数据分片算法示例
public class HashSlot {
    private static final int SLOT_COUNT = 16384;  // Redis集群槽位数

    public int getSlot(String key) {
        // 计算key的槽位
        return CRC16.calculate(key) % SLOT_COUNT;
    }

    public String getNode(int slot) {
        // 根据槽位获取节点信息
        return slotNodeMapping.get(slot);
    }
}
```

**优点**：

- 自动分片，支持海量数据
- 去中心化，无中心节点压力
- 高可用，部分节点故障不影响整体服务
- 可扩展性强，支持动态调整节点

**缺点**：

- 部署和维护复杂
- 客户端实现复杂
- 事务和多 key 操作受限
- 数据迁移时性能受影响

#### 4. 集群选型建议

1. **单机场景**

   - 数据量小（< 10GB）
   - QPS 不高（< 10000）
   - 对可用性要求不高

2. **主从场景**

   - 数据量中等（< 50GB）
   - 需要读写分离
   - 可以接受手动故障转移

3. **哨兵场景**

   - 数据量中等（< 50GB）
   - 需要自动故障转移
   - 对可用性要求高

4. **集群场景**
   - 数据量大（> 50GB）
   - QPS 很高（> 100000）
   - 需要自动分片和扩展
   - 对可用性要求非常高

### 缓存策略

1. **缓存更新策略**

```java
public class CacheStrategy {
    // Cache-Aside Pattern
    public Data getWithCacheAside(String key) {
        Data data = cache.get(key);
        if (data == null) {
            data = db.get(key);
            if (data != null) {
                cache.put(key, data);
            }
        }
        return data;
    }

    // Write-Through Pattern
    public void writeThrough(String key, Data data) {
        db.put(key, data);
        cache.put(key, data);
    }

    // Write-Behind Pattern
    public void writeBehind(String key, Data data) {
        cache.put(key, data);
        writeQueue.offer(new WriteTask(key, data));
    }
}
```

2. **缓存淘汰策略**

```java
public class CacheEviction {
    // LRU实现
    class LRUCache<K, V> extends LinkedHashMap<K, V> {
        private final int capacity;

        public LRUCache(int capacity) {
            super(capacity, 0.75f, true);
            this.capacity = capacity;
        }

        @Override
        protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
            return size() > capacity;
        }
    }
}
```

## 分布式文件系统

### HDFS 架构

```java
// NameNode实现
public class NameNode {
    private Map<String, List<DataNodeInfo>> fileBlocks;
    private Map<String, DataNodeStatus> dataNodes;

    public List<DataNodeInfo> getBlockLocations(String filename) {
        return fileBlocks.get(filename);
    }

    public void heartbeat(String dataNodeId, DataNodeStatus status) {
        dataNodes.put(dataNodeId, status);
    }
}

// DataNode实现
public class DataNode {
    private String dataNodeId;
    private Map<String, byte[]> blocks;

    public void storeBlock(String blockId, byte[] data) {
        blocks.put(blockId, data);
    }

    public byte[] readBlock(String blockId) {
        return blocks.get(blockId);
    }
}
```

### 文件操作

```java
public class HDFSClient {
    // 写文件
    public void write(String path, byte[] data) {
        // 1. 获取文件块位置
        List<DataNodeInfo> locations = nameNode.allocateBlocks(path, data.length);
        // 2. 写入数据块
        for (int i = 0; i < locations.size(); i++) {
            byte[] block = getBlock(data, i);
            writeBlock(locations.get(i), block);
        }
    }

    // 读文件
    public byte[] read(String path) {
        // 1. 获取文件块位置
        List<DataNodeInfo> locations = nameNode.getBlockLocations(path);
        // 2. 读取并组装数据
        byte[] result = new byte[0];
        for (DataNodeInfo location : locations) {
            byte[] block = readBlock(location);
            result = concat(result, block);
        }
        return result;
    }
}
```

## 分布式数据库

### 分库分表

1. **水平分片**

```java
public class ShardingStrategy {
    // 按ID范围分片
    public String getTableByIdRange(long id) {
        int tableIndex = (int) (id / rangeSize);
        return "table_" + tableIndex;
    }

    // 按Hash分片
    public String getTableByHash(String key) {
        int hash = key.hashCode();
        int tableIndex = Math.abs(hash % tableCount);
        return "table_" + tableIndex;
    }
}
```

2. **垂直分片**

```java
// 用户表
CREATE TABLE user (
    id BIGINT PRIMARY KEY,
    username VARCHAR(50),
    password VARCHAR(100)
);

// 用户详情表
CREATE TABLE user_detail (
    user_id BIGINT PRIMARY KEY,
    address VARCHAR(200),
    phone VARCHAR(20)
);
```

### 数据同步

```java
public class DataSynchronization {
    // 双写模式
    public void dualWrite(Data data) {
        try {
            masterDb.write(data);
            slaveDb.write(data);
        } catch (Exception e) {
            // 处理异常，保证一致性
        }
    }

    // 异步复制
    public void asyncReplicate(Data data) {
        masterDb.write(data);
        replicationQueue.offer(new ReplicationTask(data));
    }
}
```

## 最佳实践

1. **缓存设计**

   - 合理的缓存粒度
   - 防止缓存雪崩和击穿
   - 定期清理过期数据

2. **文件系统**

   - 合理的块大小
   - 备份和容错
   - 监控和维护

3. **数据库设计**

   - 分片键的选择
   - 跨库事务处理
   - 数据一致性保证

4. **性能优化**
   - 读写分离
   - 索引优化
   - 批量操作

## 注意事项

1. **数据一致性**

   - CAP 理论权衡
   - 最终一致性保证
   - 异常处理机制

2. **高可用设计**

   - 故障转移
   - 负载均衡
   - 容灾备份

3. **运维监控**
   - 性能指标
   - 容量规划
   - 告警机制

