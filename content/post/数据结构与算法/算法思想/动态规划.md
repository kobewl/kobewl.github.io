---
title: "1 动态规划 (Dynamic Programming)"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 1 动态规划 (Dynamic Programming)

动态规划 (DP) 是一种将大问题拆分为多个小问题来求解的方法。它的核心思想在于：

- 将复杂问题拆分成**子问题**，并
- 利用**重叠子问题**和**最优子结构**来减少重复计算。

**请注意：** 动态规划的精髓在于保存已经解决过的子问题的答案（例如通过数组、哈希表或其他数据结构），从而避免重复求解，从而显著提高程序的效率。

---

## 1.1 基本概念

### 1.1.1 定义

- **动态规划** 是一种通过将原问题分解成多个相对简单的子问题，并存储子问题答案（记忆化/DP 表）来避免重复计算的方法。
- 可采用**自顶向下**（递归 + 备忘录）或**自底向上**（迭代填表）的方式实现动态规划。
- 动态规划尤其适用于那些可以描述为**最优子结构**的问题。

### 1.1.2 核心要素

动态规划方法要求问题同时满足两个条件：

1. **最优子结构 (Optimal Substructure)**

   - **定义：** 一个问题的最优解可以由其子问题的最优解构造而成。
   - **解释：** 当你解决一个较大问题时，把它拆分为多个子问题。假如每个子问题都能得到最优解，那么将这些最优解按照一定规则组合起来，最终能得到大问题的最优解。
   - **举例：** 例如，在找最短路径的过程中，如果从 A 到 C 的最短路径肯定包含了 A 到 B 的最短路径，那么这个问题就具有最优子结构。
   - **请注意：** 只有问题满足最优子结构，动态规划才有发挥的空间。

   ```ascii
   例如，总问题的最优解由下面子问题的最优解组成：

              总问题
           /    |     \
       子问题1 子问题2 子问题3
       /  \     |      /  \
    子1-1 子1-2 子2-1 子3-1 子3-2
   ```

2. **重叠子问题 (Overlapping Subproblems)**

   - **定义：** 在求解过程中，子问题会反复出现，即相同的子问题可能在不同求解路径中多次出现。
   - **解释：** 如果直接使用递归解决问题，可能会重复计算很多相同的子问题。为避免这种重复计算，我们将这些中间结果存储起来，供后续直接使用（这就是记忆化或采用表格法的原因）。
   - **举例：** 计算斐波那契数列时：

     ```ascii
              fib(5)
            /        \
        fib(4)      fib(3)
       /      \    /      \
     fib(3)  fib(2) fib(2) fib(1)
       /    \
     fib(2) fib(1)
     ```

     注意：这里 `fib(3)` 和 `fib(2)` 等子问题被多次计算。

   - **请注意：** 存储子问题的结果（例如使用数组或 HashMap）是避免重复计算、提高效率的关键。

3. **状态转移 (State Transition)**

   - **定义：** 状态转移描述了如何从已解决的子问题的解推出更大问题的解。
   - **解释：** 对于每一个状态（或子问题），我们需要分析它与其他更小状态之间的关系，并写出一个转移公式（递推公式）。这个公式就是动态规划的"方程式"。
   - **请注意：** 正确设计状态转移公式是动态规划求解问题的核心。

   ```ascii
   状态转移示意：

   [状态1] -----> [状态2] -----> [状态3]
      \             \             \
       v             v             v
   [状态1']  ----> [状态2'] ----> [状态3']
   ```

---

## 1.2 常见问题类型与 Java 实现示例

动态规划可以应用到各种问题中，下面介绍几种常见类型，并给出部分 Java 示例。

### 1.2.1 线性 DP

#### 1.2.1.1 最长递增子序列 (Longest Increasing Subsequence, LIS)

- **问题描述：** 在给定的一维数组中，找到最长的严格递增子序列。
- **思路：**  
  设 `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。  
  状态转移公式：
  **dp[i] = max(dp[j]) + 1**，其中 j < i 且 nums[j] < nums[i]。
- **Java 示例：**

```java
/**
 * 计算数组中最长递增子序列的长度
 */
public int lengthOfLIS(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int n = nums.length;
    // dp[i] 表示以 nums[i] 为结尾的最长递增子序列的长度
    int[] dp = new int[n];
    // 每个位置至少自己一个数字，所以初始值均为1
    for (int i = 0; i < n; i++) {
        dp[i] = 1;
    }

    int maxLen = 1;
    // 遍历每个数字，更新dp数组
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            // 如果前面的数字比当前数字小，则可构成递增序列
            if (nums[j] < nums[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
        maxLen = Math.max(maxLen, dp[i]);
    }
    return maxLen;
}
```

### 1.2.2 区间 DP

#### 1.2.2.1 最长回文子串

- **问题描述：** 给定一个字符串，找出其中最长的回文子串。
- **思路：**  
  定义二维数组 `dp[i][j]` 表示子串 `s[i..j]` 是否为回文串。  
  状态转移：
  **dp[i][j] = (s[i] == s[j]) AND dp[i+1][j-1]**
  其中单个字符和两个字符的情况需要单独处理。
- **注意：** 判断回文时，除第一个和最后一个字符相同之外，内部子串 `dp[i+1][j-1]` 也必须是回文。

### 1.2.3 背包 DP

#### 1.2.3.1 0-1 背包问题

- **问题描述：** 给定一组物品（每个物品有重量和价值）和一个背包容量，求如何选择一部分物品，令总价值最大且总重量不超过背包容量。
- **思路：**  
  定义 `dp[i][w]` 表示前 i 个物品在当前背包容量 w 下能获得的最大价值。  
  状态转移常用公式为：

  **dp[i][w] = max(dp[i-1][w], dp[i-1]w - weight[i]] + value[i])**

  其中，选择或不选择第 i 个物品。

- **Java 示例（伪代码）：**

```java
/**
 * 0-1 背包问题：计算最大价值
 */
public int knapSack(int capacity, int[] weights, int[] values) {
    int n = weights.length;
    // dp[i][w] 表示前 i 个物品、背包容量为 w 时的最大价值
    int[][] dp = new int[n + 1][capacity + 1];

    // 初始化：当没有物品或者容量为 0 时，最大价值为 0
    for (int i = 0; i <= n; i++) {
        dp[i][0] = 0;
    }
    for (int w = 0; w <= capacity; w++) {
        dp[0][w] = 0;
    }

    // 填充dp数组
    for (int i = 1; i <= n; i++) {
        for (int w = 1; w <= capacity; w++) {
            if (weights[i - 1] <= w) {
                dp[i][w] = Math.max(dp[i - 1][w],
                        dp[i - 1][w - weights[i - 1]] + values[i - 1]);
            } else {
                dp[i][w] = dp[i - 1][w];
            }
        }
    }
    return dp[n][capacity];
}
```

---

## 1.3 解题步骤

在使用动态规划解决问题时，一般遵循如下步骤：

1. **定义状态**

   - 分析问题，将问题拆分成多个子问题，并用一个或多个变量描述当前子问题的特征。
   - 例如：在爬楼梯问题中，我们可以定义 `dp[i]` 表示达到第 i 阶楼梯的不同爬法数。
   - **重点提醒：** 状态设计直接决定了整个问题的结构。

2. **确定状态转移方程**

   - 分析不同状态之间的关系，写出从小问题到大问题的转移公式。
   - 例如：对于爬楼梯问题，有 `dp[i] = dp[i-1] + dp[i-2]`（因为你可以从第 i-1 或 i-2 阶楼梯爬上来）。
   - **请注意：** 正确的状态转移是动态规划算法的核心。

3. **初始化边界条件**

   - 确定最小子问题的解（典型例子：`dp[0]` 或 `dp[1]` 如何初始化），这将作为递推的起点。
   - **例如：** 在爬楼梯问题中，当只有 1 阶或 2 阶时，初始值通常为 1 和 2。

4. **确定遍历顺序**
   - 根据状态之间的依赖顺序，决定递推或填表的顺序，确保每个状态在计算时其依赖的状态已经确定。

### Java 示例 —— 爬楼梯问题

```java
/**
 * 爬楼梯问题：给定 n 阶楼梯，每次可以爬 1 或 2 阶，求有多少种爬法
 */
public int climbStairs(int n) {
    // 如果楼梯阶数很少，可以直接返回
    if(n <= 2) {
        return n;
    }
    int[] dp = new int[n + 1];
    // 初始化边界条件
    dp[1] = 1; // 1 阶楼梯只有 1 种走法
    dp[2] = 2; // 2 阶楼梯有 2 种走法：1+1 或 2

    // 自底向上填充 dp 数组
    for (int i = 3; i <= n; i++) {
        // 状态转移：从第 i-1 阶爬 1 阶 或者从 i-2 阶爬 2 阶
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

---

## 1.4 优化技巧

在实际应用中，为了提高动态规划算法的效率，常用以下两种优化方法：

### 1.4.1 空间优化 —— 滚动数组 (Rolling Array)

- **思路：** 当状态转移只依赖固定几个之前的状态时，可以使用**滚动数组**将多维 DP 压缩成一维。
- **举例：** 在爬楼梯问题中，`dp[i]` 只依赖 `dp[i-1]` 和 `dp[i-2]`，因此可以只用两个变量来记录此信息，节省空间。

### 1.4.2 状态压缩 (State Compression)

- **思路：** 某些 DP 状态可能为多维状态，但如果可以通过编码将其转换为一维数据，就可以有效压缩状态空间。
- **举例：** 在一些集合、排列问题中，可以使用位运算将状态压缩成整数或字符串，并用 HashMap 存储。

---

## 1.5 实际应用

动态规划广泛应用于各类实际问题，以下是两个常见例子：

### 1.5.1 最优化问题 —— 最短路径

- **问题描述：** 给定一张图，计算从起点到终点的最短路径。
- **动态规划思路：**  
  定义 `dp[i]` 表示从起点到节点 i 的最短路径；根据相邻节点之间的边权，更新每个节点的最短距离。

  ```ascii
      S ---4--- A ---2--- B
      |         |         |
      6         3         2
      |         |         |
      C ---5--- D ---1--- E

  在这种情况下，**dp[i]** 表示从 S 到节点 i 的最短距离。
  ```

### 1.5.2 计数问题 —— 爬楼梯问题

- **问题描述：** 如前面介绍的，每次可以爬 1 或 2 阶楼梯，求共有多少种爬法。
- **状态转移：**  
  **dp[i] = dp[i-1] + dp[i-2]**

  详细 Java 示例已在 1.3 节中给出。

---

## 1.6 常见误区

在初学动态规划时，新手常遇到以下问题：

```ascii
常见错误：
----------------------------------
| 问题规模过大       | 考虑是否能拆分成合适的子问题 |
| 重复子问题未解决   | 动态规划要求子问题重复出现，便于记忆优化 |
| 无最优子结构       | 如果问题解不能由子问题最优解构成，则不适用DP |
----------------------------------
```

**提醒：**

- 如果问题不存在**最优子结构**或者子问题不重叠，则动态规划通常无效，此时可能要考虑其他算法，比如贪心或分治。
- 在设计算法时，应首先明确状态的定义，再设计合适的状态转移方程，处理好边界情况，最后确定合适的递推顺序。

---

通过以上详细讲解及 Java 示例，希望你能对动态规划有更深刻且直观的理解。**关键提醒：** 理解状态设计、转移公式和初始化条件，才是掌握动态规划的根本所在！

