---
title: "适配器模式（Adapter Pattern）"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 适配器模式（Adapter Pattern）

## 概述

适配器模式是一种结构型设计模式，它允许接口不兼容的对象能够相互合作。适配器模式通过将一个类的接口转换成客户端期望的另一个接口，使得原本不兼容的类可以一起工作。

## 使用场景

- 当需要使用一个已有的类，但其接口与其他代码不兼容时
- 当需要复用一些现有的类，但是这些类的接口与应用程序不兼容时
- 当需要统一多个类的接口时
- 当需要适配第三方库的接口时

## 实现方式

### 1. 类适配器模式（使用继承）

```java
// 目标接口
interface Target {
    void request();
}

// 需要适配的类
class Adaptee {
    public void specificRequest() {
        System.out.println("Specific request");
    }
}

// 类适配器
class ClassAdapter extends Adaptee implements Target {
    @Override
    public void request() {
        specificRequest();  // 调用父类的方法
    }
}
```

### 2. 对象适配器模式（使用组合）

```java
// 目标接口
interface Target {
    void request();
}

// 需要适配的类
class Adaptee {
    public void specificRequest() {
        System.out.println("Specific request");
    }
}

// 对象适配器
class ObjectAdapter implements Target {
    private Adaptee adaptee;

    public ObjectAdapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public void request() {
        adaptee.specificRequest();  // 调用被适配对象的方法
    }
}
```

## 实际应用示例

以音频播放器为例：

```java
// 高级媒体播放器接口
interface AdvancedMediaPlayer {
    void playVlc(String fileName);
    void playMp4(String fileName);
}

// VLC播放器
class VlcPlayer implements AdvancedMediaPlayer {
    @Override
    public void playVlc(String fileName) {
        System.out.println("Playing vlc file: " + fileName);
    }

    @Override
    public void playMp4(String fileName) {
        // 什么都不做
    }
}

// MP4播放器
class Mp4Player implements AdvancedMediaPlayer {
    @Override
    public void playVlc(String fileName) {
        // 什么都不做
    }

    @Override
    public void playMp4(String fileName) {
        System.out.println("Playing mp4 file: " + fileName);
    }
}

// 媒体播放器接口
interface MediaPlayer {
    void play(String audioType, String fileName);
}

// 媒体适配器
class MediaAdapter implements MediaPlayer {
    private AdvancedMediaPlayer advancedMusicPlayer;

    public MediaAdapter(String audioType) {
        if (audioType.equalsIgnoreCase("vlc")) {
            advancedMusicPlayer = new VlcPlayer();
        } else if (audioType.equalsIgnoreCase("mp4")) {
            advancedMusicPlayer = new Mp4Player();
        }
    }

    @Override
    public void play(String audioType, String fileName) {
        if (audioType.equalsIgnoreCase("vlc")) {
            advancedMusicPlayer.playVlc(fileName);
        } else if (audioType.equalsIgnoreCase("mp4")) {
            advancedMusicPlayer.playMp4(fileName);
        }
    }
}

// 音频播放器
class AudioPlayer implements MediaPlayer {
    private MediaAdapter mediaAdapter;

    @Override
    public void play(String audioType, String fileName) {
        // 播放mp3音频文件的内置支持
        if (audioType.equalsIgnoreCase("mp3")) {
            System.out.println("Playing mp3 file: " + fileName);
        }
        // mediaAdapter提供了播放其他文件格式的支持
        else if (audioType.equalsIgnoreCase("vlc") || audioType.equalsIgnoreCase("mp4")) {
            mediaAdapter = new MediaAdapter(audioType);
            mediaAdapter.play(audioType, fileName);
        } else {
            System.out.println("Invalid media type: " + audioType);
        }
    }
}

// 使用示例
public class AdapterDemo {
    public static void main(String[] args) {
        AudioPlayer audioPlayer = new AudioPlayer();

        audioPlayer.play("mp3", "song.mp3");
        audioPlayer.play("vlc", "movie.vlc");
        audioPlayer.play("mp4", "video.mp4");
        audioPlayer.play("avi", "video.avi");
    }
}
```

## 另一个实际示例：第三方支付适配

```java
// 支付接口
interface Payment {
    void pay(double amount);
    void refund(double amount);
}

// 支付宝支付（第三方）
class AliPay {
    public void sendPayment(double money) {
        System.out.println("Using Alipay to pay: " + money);
    }

    public void returnPayment(double money) {
        System.out.println("Using Alipay to refund: " + money);
    }
}

// 微信支付（第三方）
class WeChatPay {
    public void makePayment(double total) {
        System.out.println("Using WeChat to pay: " + total);
    }

    public void makeRefund(double total) {
        System.out.println("Using WeChat to refund: " + total);
    }
}

// 支付宝适配器
class AlipayAdapter implements Payment {
    private AliPay aliPay;

    public AlipayAdapter(AliPay aliPay) {
        this.aliPay = aliPay;
    }

    @Override
    public void pay(double amount) {
        aliPay.sendPayment(amount);
    }

    @Override
    public void refund(double amount) {
        aliPay.returnPayment(amount);
    }
}

// 微信支付适配器
class WeChatPayAdapter implements Payment {
    private WeChatPay weChatPay;

    public WeChatPayAdapter(WeChatPay weChatPay) {
        this.weChatPay = weChatPay;
    }

    @Override
    public void pay(double amount) {
        weChatPay.makePayment(amount);
    }

    @Override
    public void refund(double amount) {
        weChatPay.makeRefund(amount);
    }
}
```

## 优点

1. 将接口转换的过程对客户端透明
2. 提高了类的复用性
3. 增加了类的透明性和灵活性
4. 将目标类和适配者类解耦，无需修改原有代码

## 缺点

1. 适配器编写过程需要全面考虑，可能会增加系统的复杂性
2. 增加了代码可读的难度
3. 过多使用适配器会使系统变得凌乱

## 适用场景

1. 系统需要使用现有的类，但这些类的接口不符合系统的需要
2. 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的类一起工作
3. 需要统一多个类的接口时
4. 需要适配第三方库的接口时

## 注意事项

1. 适配器不应该过多地修改原有的业务逻辑
2. 适配器模式可以与其他模式结合使用
3. 在使用适配器模式时，需要考虑是使用类适配器还是对象适配器
4. 适配器模式应该只用于接口不兼容的情况，而不是用于添加新功能

