---
title: "1 递归 (Recursion)"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 1 递归 (Recursion)

## 1.1 基本概念

递归（Recursion）是一种重要的编程思想和方法，它的核心思想是：**把一个复杂的问题分解成相似的子问题来解决**。

### 1.1.1 直观理解

想象你站在两面镜子之间，你会看到无限多个自己的影像，每个影像都是前一个影像的复制。这就类似于递归的概念：
- 每个影像代表一次函数调用
- 影像的逐渐变小代表问题规模的缩小
- 影像的终止代表递归的出口

### 1.1.2 关键特征

1. **问题的可分解性**
   - 原问题可以分解为更小的子问题
   - 子问题的解决方式与原问题相同
   - 例如：计算 5 的阶乘可以转化为计算 4 的阶乘，再乘以 5

2. **问题的相似性**
   - 子问题与原问题的形式相同
   - 只是规模或范围缩小了
   - 例如：遍历树的左子树和右子树，与遍历整棵树的方法相同

3. **问题的可终止性**
   - 必须有明确的终止条件（递归出口）
   - 问题在递归过程中必须向终止条件靠近
   - 例如：阶乘计算中，当 n=1 时停止递归

### 1.1.3 递归与数学归纳法的关系

递归思想与数学归纳法非常相似：
1. **基础情况**：证明 n=1 时成立
2. **归纳步骤**：假设 n=k 时成立，证明 n=k+1 时也成立

递归也遵循类似的模式：
1. **基础情况**：处理最简单的情况（递归出口）
2. **递归步骤**：将问题转化为更小的子问题

## 1.2 递归的基本要素

一个完整的递归需要包含以下三个要素：

1. **递归出口（Base Case）**
   - 明确的终止条件
   - 当满足条件时，递归停止并返回结果

2. **递归调用（Recursive Case）**
   - 将原问题分解为规模更小的子问题
   - 调用自身解决子问题

3. **递归方向**
   - 确保每次递归都向着递归出口方向发展
   - 问题规模必须不断减小

## 1.3 递归的工作原理

### 1.3.1 详细的执行过程

以计算 `factorial(4)` 为例，详细说明递归的执行过程：

```java
public int factorial(int n) {
    // 递归出口
    if (n <= 1) {
        System.out.println("到达递归出口: n = " + n);
        return 1;
    }
    
    System.out.println("进入递归: n = " + n);
    // 递归调用
    int result = n * factorial(n - 1);
    System.out.println("返回结果: " + n + "! = " + result);
    return result;
}
```

执行 `factorial(4)` 的详细过程：

```
进入递归: n = 4
进入递归: n = 3
进入递归: n = 2
到达递归出口: n = 1
返回结果: 2! = 2
返回结果: 3! = 6
返回结果: 4! = 24
```

### 1.3.2 内存栈分析

递归调用过程中的内存栈变化：

1. **压栈阶段**（自顶向下）：
```
┌─────────────┐
│ factorial(4)│ ← 最先调用
├─────────────┤
│ factorial(3)│
├─────────────┤
│ factorial(2)│
├─────────────┤
│ factorial(1)│ ← 最后调用
└─────────────┘
```

2. **出栈阶段**（自底向上）：
```
factorial(1) 返回 1
factorial(2) 计算 2 * 1 = 2
factorial(3) 计算 3 * 2 = 6
factorial(4) 计算 4 * 6 = 24
```

### 1.3.3 递归的数据流向

以数组求和为例，展示递归中的数据流向：

```java
public int sum(int[] arr, int n) {
    // 打印当前处理的范围
    System.out.println("处理范围: 0 到 " + (n-1));
    
    // 递归出口
    if (n <= 0) {
        System.out.println("到达递归出口，返回 0");
        return 0;
    }
    
    // 递归调用
    int subSum = sum(arr, n-1);
    int currentSum = subSum + arr[n-1];
    System.out.println("当前和: " + currentSum + 
                      " (子数组和: " + subSum + 
                      " + 当前元素: " + arr[n-1] + ")");
    return currentSum;
}
```

对于数组 `[1, 2, 3, 4]` 的执行过程：

```
处理范围: 0 到 3
处理范围: 0 到 2
处理范围: 0 到 1
处理范围: 0 到 0
到达递归出口，返回 0
当前和: 1 (子数组和: 0 + 当前元素: 1)
当前和: 3 (子数组和: 1 + 当前元素: 2)
当前和: 6 (子数组和: 3 + 当前元素: 3)
当前和: 10 (子数组和: 6 + 当前元素: 4)
```

### 1.3.4 递归的思维方式

解决递归问题时，需要培养以下思维习惯：

1. **关注当前层级**
   - 不要试图跟踪整个递归过程
   - 只需要考虑当前层级要做什么
   - 相信递归调用会返回正确的结果

2. **设计递归出口**
   - 确定最简单的情况
   - 明确返回值
   - 例如：数组求和中，空数组返回 0

3. **设计递归调用**
   - 问题如何分解为子问题
   - 如何使用子问题的结果
   - 例如：数组求和 = 第一个元素 + 剩余元素的和

## 1.4 常见递归模式

### 1.4.1 线性递归

只包含一个递归调用的递归函数。

```java
// 计算数组和
public int sum(int[] arr, int n) {
    // 递归出口
    if (n <= 0) return 0;
    // 递归调用
    return arr[n-1] + sum(arr, n-1);
}
```

### 1.4.2 树形递归

包含多个递归调用的递归函数。

```java
// 计算斐波那契数列
public int fibonacci(int n) {
    // 递归出口
    if (n <= 1) return n;
    // 多个递归调用
    return fibonacci(n-1) + fibonacci(n-2);
}
```

### 1.4.3 尾递归

递归调用是函数体中最后执行的语句。

```java
// 尾递归版本的阶乘计算
public int factorialTail(int n, int acc) {
    // 递归出口
    if (n <= 1) return acc;
    // 尾递归调用
    return factorialTail(n-1, n * acc);
}
```

## 1.5 递归的优化

### 1.5.1 记忆化递归

使用缓存存储已计算过的结果，避免重复计算。

```java
public class FibonacciWithMemo {
    private Map<Integer, Integer> memo = new HashMap<>();
    
    public int fibonacci(int n) {
        // 检查缓存
        if (memo.containsKey(n)) return memo.get(n);
        
        // 递归出口
        if (n <= 1) return n;
        
        // 计算并缓存结果
        int result = fibonacci(n-1) + fibonacci(n-2);
        memo.put(n, result);
        return result;
    }
}
```

### 1.5.2 尾递归优化

将普通递归转换为尾递归，可以被编译器优化。

```java
public class FactorialOptimized {
    // 普通递归版本
    public int factorial(int n) {
        if (n <= 1) return 1;
        return n * factorial(n-1);
    }
    
    // 尾递归优化版本
    public int factorialOptimized(int n) {
        return factorialHelper(n, 1);
    }
    
    private int factorialHelper(int n, int acc) {
        if (n <= 1) return acc;
        return factorialHelper(n-1, n * acc);
    }
}
```

## 1.6 递归的优缺点

### 1.6.1 优点
1. 代码简洁清晰
2. 问题解决思路自然
3. 适合处理具有递归结构的数据

### 1.6.2 缺点
1. 空间复杂度较高
2. 可能存在重复计算
3. 调用栈可能溢出

## 1.7 实际应用示例

### 1.7.1 文件系统遍历

```java
public class FileTraversal {
    public void listFiles(File dir) {
        // 递归出口
        if (!dir.isDirectory()) {
            System.out.println(dir.getPath());
            return;
        }
        
        // 处理当前目录
        System.out.println("Dir: " + dir.getPath());
        
        // 递归处理子目录
        File[] files = dir.listFiles();
        if (files != null) {
            for (File file : files) {
                listFiles(file);
            }
        }
    }
}
```

### 1.7.2 树结构遍历

```java
public class TreeTraversal {
    public class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
    }
    
    // 前序遍历
    public void preorder(TreeNode root) {
        if (root == null) return;
        
        System.out.print(root.val + " ");  // 处理当前节点
        preorder(root.left);               // 递归遍历左子树
        preorder(root.right);              // 递归遍历右子树
    }
}
```

## 1.8 注意事项

1. **递归出口**
   - 必须有明确的终止条件
   - 确保所有情况都能到达终止条件

2. **栈溢出预防**
   - 控制递归深度
   - 考虑使用迭代替代深度较大的递归

3. **重复计算**
   - 使用记忆化技术避免重复计算
   - 考虑是否可以用动态规划优化

4. **性能考虑**
   - 评估空间复杂度
   - 在适当情况下使用迭代替代递归

递归是一种强大的编程工具，掌握好递归的原理和优化技巧，可以帮助我们更好地解决复杂问题。在实际应用中，要根据具体情况权衡使用递归还是迭代方案。 
