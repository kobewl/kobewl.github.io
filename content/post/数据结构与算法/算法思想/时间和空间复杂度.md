---
title: "时间复杂度与空间复杂度 (Time & Space Complexity)"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 时间复杂度与空间复杂度 (Time & Space Complexity)

在学习算法时，我们需要了解算法执行所需的时间和占用的内存空间如何随着输入规模的增长而变化。常用的方法是使用大 O 表示法（Big-O notation）来描述这些增长趋势。本文将详细介绍时间复杂度与空间复杂度的基本概念、如何计算它们，以及几种常见的复杂度类型和相应的例子。

---

## 1. 基本概念

### 1.1 时间复杂度 (Time Complexity)

- **定义：**  
  时间复杂度描述了算法执行所需时间相对于输入规模（记作 n）的增长趋势。它衡量的是算法在最坏情况下的执行步骤数。
- **表示方法：**  
  常用大 O 表示法描述，如：
  - **O(1)：** 常数级，不随输入规模增加而变化。
  - **O(log n)：** 对数级，例如二分查找算法。
  - **O(n)：** 线性级，例如遍历数组。
  - **O(n·log n)：** 线性对数级，例如归并排序和快速排序（平均情况）。
  - **O(n²)：** 平方级，例如嵌套循环遍历二维数组。
  - **O(2ⁿ)：** 指数级，例如不带备忘录的递归斐波那契数列。
  - **O(n!)：** 阶乘级，例如全排列生成算法。
- **通俗解释：**  
  将时间复杂度想象成找书的过程：
  - **O(1)：** 就像直接拿到一本书，不管有多少书都只看一次；
  - **O(n)：** 就像有 n 本书，每本都要看一眼；
  - **O(log n)：** 如同用二分查找，书本被不断折半查找，时间远小于 n；
  - **O(n·log n)：** 先对书排序再查找，每本书平均需要 log n 次比较；
  - **O(n²)：** 像安排所有书两两比较，书越多比较次数呈平方增长；
  - **O(2ⁿ) 与 O(n!)：** 表示极端情形，算法时间随输入急速增长，一般仅适用于小规模问题。

### 1.2 空间复杂度 (Space Complexity)

- **定义：**  
  空间复杂度描述了算法在运行过程中所需的额外内存空间相对于输入规模的增长趋势。
- **表示方法：**  
  同样使用大 O 表示法，例如：
  - **O(1)：** 常数空间，额外内存不随 n 增加。
  - **O(n)：** 线性空间，所需额外内存与输入规模成正比。
  - 其他复杂度也可能存在，视具体算法而定（例如递归调用栈深度可能为 O(log n) 或 O(n)）。
- **通俗解释：**  
  想象你需要额外的桌子来存放临时文件；如果不随书堆大小变化是 O(1)，而书越多需要的桌子也越多，则为 O(n)。

---

## 2. 如何计算时间复杂度

### 2.1 常见循环情况

#### (1) 单个循环

使用一个从 0 到 n-1 的循环，每次做常数时间操作：

```java
// 例子：遍历数组
for (int i = 0; i < n; i++) {
    System.out.println(i); // 常数时间操作
}
// 时间复杂度：O(n)
```

#### (2) 嵌套循环

两个嵌套循环，每个循环执行 n 次，总操作次数约为 n\*n，即 n²：

```java
// 例子：遍历二维数组
for (int i = 0; i < n; i++) {             // 外层循环 n 次
    for (int j = 0; j < n; j++) {         // 内层循环 n 次
        System.out.println(i + ", " + j); // 常数时间操作
    }
}
// 时间复杂度：O(n²)
```

#### (3) 对数时间操作

例如二分查找，每次将查找区间折半，所以步骤数为 log₂(n)：

```java
// 二分查找示例（伪代码）：
int left = 0, right = n - 1;
while (left <= right) {
    int mid = left + (right - left) / 2;
    if (arr[mid] == target) {
        return mid;
    } else if (arr[mid] < target) {
        left = mid + 1;
    } else {
        right = mid - 1;
    }
}
// 时间复杂度：O(log n)
```

#### (4) 线性对数时间操作 (O(n·log n))

常见于排序算法，例如归并排序或快速排序的平均时间复杂度：

```java
// 归并排序伪代码（简化版）
void mergeSort(int[] arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;
        mergeSort(arr, left, mid);       // 分治递归
        mergeSort(arr, mid + 1, right);    // 分治递归
        merge(arr, left, mid, right);      // 合并操作，时间复杂度 O(n)
    }
}
// 总体时间复杂度为 O(n·log n)
```

### 2.2 递归算法的时间复杂度

递归算法一般需要构建**递归树 (Recursion Tree)**，将每一层的操作数累加。

- **例子 1：斐波那契数列（不含记忆化优化）**  
  每次调用递归函数会分成两次，不考虑重复计算时间复杂度大约为 O(2ⁿ)。
- **例子 2：二分递归**  
  如果递归每次分治到一半，递归深度约为 log n，时间复杂度可为 O(log n) 或 O(n·log n)（取决于每次递归的合并操作）。

---

## 3. 如何计算空间复杂度

### 3.1 常量级空间 – O(1)

算法只使用固定数量的额外变量，不依赖于输入规模：

```java
// 交换两个数的示例
int a = 10, b = 20;
int temp = a;
a = b;
b = temp;
// 空间复杂度：O(1)
```

### 3.2 线性空间 – O(n)

算法需要一个与输入大小成正比的额外数组或其它数据结构：

```java
// 复制数组的示例
int[] input = new int[n];
int[] output = new int[n]; // 新数组大小随 n 改变
// 空间复杂度：O(n)
```

### 3.3 递归调用栈

递归算法的额外空间由递归深度决定：

- 例如二分查找的递归版本，深度为 O(log n)；
- 而递归遍历链表深度为 O(n)。

---

## 4. 常见时间复杂度分类汇总

| 时间复杂度 | 描述                     | 示例                               |
| ---------- | ------------------------ | ---------------------------------- |
| O(1)       | 常数级，不受输入大小影响 | 数组索引访问                       |
| O(log n)   | 对数级                   | 二分查找                           |
| O(n)       | 线性级                   | 单层循环遍历                       |
| O(n·log n) | 线性对数级               | 归并排序、快速排序（平均情况）     |
| O(n²)      | 平方级                   | 嵌套循环（例如冒泡排序）           |
| O(2ⁿ)      | 指数级                   | 不带记忆化的递归斐波那契算法       |
| O(n!)      | 阶乘级                   | 全排列生成、旅行商问题（暴力解法） |

---

## 5. 总结与建议

- **时间复杂度分析：**

  - 关注算法中循环及递归调用的次数
  - 嵌套循环复杂度相乘，顺序代码只看最大量级
  - 对于递归算法，绘制递归树可帮助估计总调用次数

- **空间复杂度分析：**

  - 计算所有额外使用的内存（数组、对象、递归栈等）
  - 输入数据本身一般不计入额外空间

- **学习建议：**
  - 多练习常见算法（如排序、查找、递归）来体会各种复杂度
  - 读懂算法伪代码，手动推导并总结各部分的计算量
  - 调试代码并使用简单的计数器记录操作次数，验证理论估计

通过不断练习和总结，你将逐步熟悉如何评估算法的运行时间和空间需求，进而优化代码效率。希望这篇文档能帮助你建立扎实的基础知识，为后续深入算法学习打下坚实的基础！

