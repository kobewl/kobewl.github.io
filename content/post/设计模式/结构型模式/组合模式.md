---
title: "组合模式（Composite Pattern）"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 组合模式（Composite Pattern）

## 概述

组合模式是一种结构型设计模式，它允许你将对象组合成树形结构来表现"整体/部分"层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性，简化了客户端代码。

## 使用场景

- 需要表示对象的部分-整体层次结构时
- 希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象时
- 处理树形结构时，如文件系统、公司组织架构等
- 需要统一处理单个对象和对象集合时

## 基本实现

```java
// 抽象组件
abstract class Component {
    protected String name;

    public Component(String name) {
        this.name = name;
    }

    abstract void add(Component c);
    abstract void remove(Component c);
    abstract void display(int depth);
}

// 叶子组件
class Leaf extends Component {
    public Leaf(String name) {
        super(name);
    }

    @Override
    void add(Component c) {
        System.out.println("Cannot add to a leaf");
    }

    @Override
    void remove(Component c) {
        System.out.println("Cannot remove from a leaf");
    }

    @Override
    void display(int depth) {
        StringBuilder indent = new StringBuilder();
        for (int i = 0; i < depth; i++) {
            indent.append("-");
        }
        System.out.println(indent + name);
    }
}

// 组合组件
class Composite extends Component {
    private List<Component> children = new ArrayList<>();

    public Composite(String name) {
        super(name);
    }

    @Override
    void add(Component c) {
        children.add(c);
    }

    @Override
    void remove(Component c) {
        children.remove(c);
    }

    @Override
    void display(int depth) {
        StringBuilder indent = new StringBuilder();
        for (int i = 0; i < depth; i++) {
            indent.append("-");
        }
        System.out.println(indent + name);

        for (Component component : children) {
            component.display(depth + 2);
        }
    }
}
```

## 实际应用示例

以公司组织架构为例：

```java
// 抽象组织组件
abstract class OrganizationComponent {
    protected String name;
    protected String description;

    public OrganizationComponent(String name, String description) {
        this.name = name;
        this.description = description;
    }

    abstract void add(OrganizationComponent org);
    abstract void remove(OrganizationComponent org);
    abstract void display(int depth);
    abstract int getStaffCount();
}

// 部门类（叶子节点）
class Department extends OrganizationComponent {
    private int staffCount;

    public Department(String name, String description, int staffCount) {
        super(name, description);
        this.staffCount = staffCount;
    }

    @Override
    void add(OrganizationComponent org) {
        throw new UnsupportedOperationException();
    }

    @Override
    void remove(OrganizationComponent org) {
        throw new UnsupportedOperationException();
    }

    @Override
    void display(int depth) {
        StringBuilder indent = new StringBuilder();
        for (int i = 0; i < depth; i++) {
            indent.append("  ");
        }
        System.out.println(indent + "部门: " + name + " (" + description + ")");
        System.out.println(indent + "人数: " + staffCount);
    }

    @Override
    int getStaffCount() {
        return staffCount;
    }
}

// 公司类（组合节点）
class Company extends OrganizationComponent {
    private List<OrganizationComponent> organizations = new ArrayList<>();

    public Company(String name, String description) {
        super(name, description);
    }

    @Override
    void add(OrganizationComponent org) {
        organizations.add(org);
    }

    @Override
    void remove(OrganizationComponent org) {
        organizations.remove(org);
    }

    @Override
    void display(int depth) {
        StringBuilder indent = new StringBuilder();
        for (int i = 0; i < depth; i++) {
            indent.append("  ");
        }
        System.out.println(indent + "公司: " + name + " (" + description + ")");
        System.out.println(indent + "总人数: " + getStaffCount());

        for (OrganizationComponent org : organizations) {
            org.display(depth + 1);
        }
    }

    @Override
    int getStaffCount() {
        int totalCount = 0;
        for (OrganizationComponent org : organizations) {
            totalCount += org.getStaffCount();
        }
        return totalCount;
    }
}

// 使用示例
public class OrganizationDemo {
    public static void main(String[] args) {
        // 创建总公司
        Company headquarters = new Company("总公司", "总部");

        // 创建子公司
        Company branchOffice = new Company("分公司", "分支机构");

        // 创建部门
        Department hr = new Department("人力资源部", "人员管理", 10);
        Department rd = new Department("研发部", "技术研发", 100);
        Department sales = new Department("销售部", "市场销售", 50);
        Department finance = new Department("财务部", "财务管理", 15);

        // 组织架构
        headquarters.add(branchOffice);
        headquarters.add(hr);
        headquarters.add(rd);
        branchOffice.add(sales);
        branchOffice.add(finance);

        // 显示组织架构
        headquarters.display(0);
    }
}
```

## 另一个实际示例：文件系统

```java
// 文件系统组件
abstract class FileSystemNode {
    protected String name;
    protected String path;

    public FileSystemNode(String name, String path) {
        this.name = name;
        this.path = path;
    }

    abstract long getSize();
    abstract void display(int depth);
}

// 文件
class File extends FileSystemNode {
    private long size;

    public File(String name, String path, long size) {
        super(name, path);
        this.size = size;
    }

    @Override
    long getSize() {
        return size;
    }

    @Override
    void display(int depth) {
        StringBuilder indent = new StringBuilder();
        for (int i = 0; i < depth; i++) {
            indent.append("  ");
        }
        System.out.println(indent + "文件: " + name + " (" + size + " bytes)");
    }
}

// 目录
class Directory extends FileSystemNode {
    private List<FileSystemNode> children = new ArrayList<>();

    public Directory(String name, String path) {
        super(name, path);
    }

    public void addNode(FileSystemNode node) {
        children.add(node);
    }

    public void removeNode(FileSystemNode node) {
        children.remove(node);
    }

    @Override
    long getSize() {
        long totalSize = 0;
        for (FileSystemNode node : children) {
            totalSize += node.getSize();
        }
        return totalSize;
    }

    @Override
    void display(int depth) {
        StringBuilder indent = new StringBuilder();
        for (int i = 0; i < depth; i++) {
            indent.append("  ");
        }
        System.out.println(indent + "目录: " + name + " (总大小: " + getSize() + " bytes)");

        for (FileSystemNode node : children) {
            node.display(depth + 1);
        }
    }
}
```

## 优点

1. 简化客户端代码，客户端可以一致地处理组合对象和单个对象
2. 使得添加新类型的组件变得容易
3. 提供了清晰的层次结构
4. 符合开闭原则，容易扩展

## 缺点

1. 在组件的种类很多时，可能会让设计变得更加复杂
2. 在某些情况下很难对组合中的对象类型进行限制
3. 可能会导致系统设计过于一般化

## 适用场景

1. 表示对象的部分-整体层次结构
2. 希望用户忽略组合对象与单个对象的不同
3. 处理树形结构数据
4. 需要统一处理单个对象和组合对象时

## 注意事项

1. 注意组合模式与其他模式的结合使用
2. 需要考虑对组件的访问控制
3. 注意组件接口的设计，不要过于臃肿
4. 注意组件的安全性和透明性的权衡

