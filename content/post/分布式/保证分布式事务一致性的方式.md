---
title: "1 分布式事务一致性"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 1 分布式事务一致性

## 1.1 概述

分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。分布式事务需要保证 ACID 特性，同时要处理网络延迟、系统崩溃等分布式环境特有的问题。

## 1.2 分布式事务的特性（ACID）

1. **原子性（Atomicity）**

   - 事务是不可分割的工作单位
   - 要么全部完成，要么全部失败

2. **一致性（Consistency）**

   - 事务执行前后，数据保持一致
   - 所有节点达到最终一致性

3. **隔离性（Isolation）**

   - 并发事务之间互不干扰
   - 防止数据混乱

4. **持久性（Durability）**
   - 事务一旦提交，永久生效
   - 即使系统崩溃也能恢复

## 1.3 分布式事务解决方案

### 1.3.1 两阶段提交（2PC）

#### 概念

两阶段提交（Two-Phase Commit）是最早的分布式事务解决方案，将事务的提交过程分为两个阶段：准备阶段（Prepare Phase）和提交阶段（Commit Phase）。整个过程由协调者（Coordinator）和参与者（Participant）共同完成。

#### 工作流程

1. **准备阶段**

   - 协调者向所有参与者发送准备请求
   - 参与者执行事务操作，但不提交
   - 参与者将执行结果返回给协调者

2. **提交阶段**
   - 如果所有参与者都准备成功，协调者发送提交请求
   - 如果任一参与者准备失败，协调者发送回滚请求
   - 参与者执行提交或回滚操作

```java
// 协调者
public class Coordinator {
    // 阶段1：准备阶段
    public boolean prepare() {
        boolean allReady = true;
        for (Participant participant : participants) {
            allReady &= participant.prepare();
        }
        return allReady;
    }

    // 阶段2：提交阶段
    public void commit() {
        if (prepare()) {
            for (Participant participant : participants) {
                participant.commit();
            }
        } else {
            for (Participant participant : participants) {
                participant.rollback();
            }
        }
    }
}
```

#### 优点

1. 强一致性保证，满足 ACID 特性
2. 原理简单，实现相对容易
3. 适合对数据一致性要求很高的场景
4. 常用于传统的单体应用和分布式数据库系统

#### 缺点

1. 性能问题

   - 同步阻塞，参与者在等待协调者指令时处于阻塞状态
   - 响应时间长，需要等待所有参与者的响应

2. 单点问题

   - 协调者宕机会导致整个系统不可用
   - 参与者宕机会导致事务悬挂

3. 数据不一致风险
   - 网络分区可能导致部分参与者未收到提交指令
   - 无法处理协调者和参与者同时宕机的情况

#### 应用场景

1. 银行转账系统
2. 订单支付系统
3. 库存管理系统
4. 积分兑换系统

### 1.3.2 三阶段提交（3PC）

#### 概念

三阶段提交是对 2PC 的改进版本，通过引入超时机制和预提交阶段来降低阻塞概率。将提交过程分为：询问阶段（CanCommit）、预提交阶段（PreCommit）和提交阶段（DoCommit）。

#### 工作流程

1. **CanCommit 阶段**

   - 协调者询问参与者是否可以执行事务
   - 参与者检查自身资源并回复

2. **PreCommit 阶段**

   - 协调者根据第一阶段的结果发送预提交请求
   - 参与者执行事务但不提交
   - 参与者记录 undo 和 redo 信息

3. **DoCommit 阶段**
   - 协调者发送提交请求
   - 参与者正式完成事务提交
   - 释放所有资源

#### 优点

1. 相比 2PC 降低了阻塞概率
2. 引入超时机制，解决了单点故障问题
3. 增加了预提交阶段，提高了可靠性

#### 缺点

1. 实现复杂度高
2. 网络分区可能导致数据不一致
3. 性能开销比 2PC 更大
4. 无法完全解决数据一致性问题

#### 应用场景

1. 分布式数据库系统
2. 大型分布式事务处理系统
3. 需要高可靠性的金融系统

### 1.3.3 TCC（Try-Confirm-Cancel）

#### 概念

TCC 是一种补偿型事务，将业务逻辑分为 Try（尝试）、Confirm（确认）、Cancel（取消）三个操作。它是一种业务层面的分布式事务解决方案。

#### 工作流程

1. **Try 阶段**

   - 尝试执行业务
   - 预留必要的业务资源
   - 校验业务参数

2. **Confirm 阶段**

   - 确认执行业务
   - 使用 Try 阶段预留的资源
   - 不做任何业务检查

3. **Cancel 阶段**
   - 取消执行业务
   - 释放 Try 阶段预留的资源
   - 实现业务补偿

```java
public interface TccService {
    // Try阶段：尝试执行业务
    boolean try();

    // Confirm阶段：确认执行业务
    boolean confirm();

    // Cancel阶段：取消执行业务
    boolean cancel();
}
```

#### 优点

1. 性能较好，避免了长事务
2. 可靠性高，有完善的补偿机制
3. 符合实际业务特点
4. 可以实现最终一致性

#### 缺点

1. 开发成本高，需要实现三个接口
2. 业务侵入性强
3. 补偿逻辑复杂
4. 需要考虑幂等性设计

#### 应用场景

1. 电商订单系统
2. 库存预占系统
3. 支付交易系统
4. 航班预订系统

### 1.3.4 本地消息表（消息队列）

#### 概念

本地消息表是一种异步确保型事务，通过将分布式事务拆分为本地事务进行处理，并通过消息日志的方式来异步执行。这种方式实现了最终一致性，是一种业务友好的分布式事务解决方案。

#### 工作流程

1. **事务发起方**

   - 开启本地事务
   - 执行业务操作
   - 写入消息表
   - 提交本地事务

2. **消息推送**

   - 定时扫描消息表
   - 重试发送失败的消息
   - 更新消息状态

3. **事务参与方**
   - 接收消息
   - 执行本地事务
   - 返回确认信息

```sql
-- 本地消息表结构
CREATE TABLE local_message (
    id BIGINT PRIMARY KEY,
    message VARCHAR(1000),  -- 消息内容
    status INT,            -- 消息状态：0-待发送，1-已发送，2-发送失败
    retry_count INT,       -- 重试次数
    create_time TIMESTAMP, -- 创建时间
    update_time TIMESTAMP  -- 更新时间
);

-- 消息处理示例
public class MessageProcessor {
    // 发送消息
    public void sendMessage(String message) {
        try {
            // 1. 开启本地事务
            beginTransaction();

            // 2. 执行业务操作
            businessService.process();

            // 3. 写入消息表
            saveMessage(message);

            // 4. 提交事务
            commit();
        } catch (Exception e) {
            // 5. 回滚事务
            rollback();
        }
    }

    // 重试发送消息
    @Scheduled(fixedRate = 5000)
    public void retryFailedMessages() {
        List<Message> failedMessages = getFailedMessages();
        for (Message msg : failedMessages) {
            tryResend(msg);
        }
    }
}
```

#### 优点

1. 实现简单，无需额外组件
2. 性能好，适合高并发场景
3. 可靠性高，消息持久化
4. 支持消息重试机制

#### 缺点

1. 依赖消息队列的可靠性
2. 需要额外的表和定时任务
3. 消息重复发送的问题
4. 需要处理消息丢失的情况

#### 应用场景

1. 订单系统的异步处理
2. 积分系统的消息通知
3. 库存系统的异步更新
4. 日志系统的消息处理

### 1.3.5 Saga 模式

#### 概念

Saga 模式是一种分布式事务解决方案，将一个大事务拆分为多个本地事务，每个本地事务都有对应的补偿操作。当某个本地事务失败时，已完成的本地事务会通过补偿操作来回滚。

#### 工作流程

1. **正向操作**

   - 按顺序执行本地事务
   - 记录执行状态
   - 通知下一个本地事务

2. **补偿操作**
   - 检测失败的事务
   - 按相反顺序执行补偿
   - 恢复到初始状态

```java
public class SagaTransaction {
    private List<SagaStep> steps;
    private TransactionStatus status;

    // 执行Saga事务
    public void execute() {
        // 1. 正向操作
        for (SagaStep step : steps) {
            try {
                step.execute();
                recordSuccess(step);
            } catch (Exception e) {
                compensate();
                throw e;
            }
        }
    }

    // 补偿操作
    private void compensate() {
        // 2. 反向补偿
        for (int i = steps.size() - 1; i >= 0; i--) {
            SagaStep step = steps.get(i);
            if (isStepExecuted(step)) {
                step.compensate();
            }
        }
    }
}

// Saga步骤接口
public interface SagaStep {
    void execute();    // 正向操作
    void compensate(); // 补偿操作
}
```

#### 优点

1. 适合长事务处理
2. 无需锁定资源
3. 可以实现并行化
4. 补偿机制灵活

#### 缺点

1. 补偿操作复杂
2. 事务隔离性较弱
3. 需要设计补偿接口
4. 编程复杂度高

#### 应用场景

1. 复杂的业务流程
2. 长事务处理
3. 跨服务调用链
4. 订单履约系统

## 1.4 使用场景

1. **电商订单**

   - 订单创建
   - 库存扣减
   - 支付处理

2. **银行转账**

   - 账户扣款
   - 账户入账
   - 交易记录

3. **积分系统**
   - 消费积分
   - 奖励积分
   - 积分兑换

## 1.5 最佳实践

1. **选择合适的方案**

   - 强一致性要求：2PC/3PC
   - 最终一致性：TCC/Saga
   - 简单场景：本地消息表

2. **异常处理**

   - 超时处理
   - 补偿机制
   - 幂等性保证

3. **性能优化**

   - 减少锁定时间
   - 异步化处理
   - 合理的事务边界

4. **监控和运维**
   - 事务状态监控
   - 补偿任务监控
   - 性能指标监控

## 1.6 注意事项

1. **数据一致性级别**

   - 强一致性
   - 最终一致性
   - 弱一致性

2. **性能与一致性的平衡**

   - 业务要求
   - 技术成本
   - 维护成本

3. **容错和恢复机制**

   - 幂等性设计
   - 重试机制
   - 补偿机制

4. **业务设计建议**
   - 减少分布式事务
   - 合理的事务边界
   - 异步化处理

