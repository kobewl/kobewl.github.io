---
title: "工厂方法模式（Factory Method Pattern）"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 工厂方法模式（Factory Method Pattern）

## 概述

工厂方法模式是一种创建型设计模式，它定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

## 使用场景

- 当一个类不知道它所必须创建的对象的类时
- 当一个类希望由它的子类来指定它所创建的对象时
- 当类将创建对象的职责委托给多个帮助子类中的某一个时

## 结构

```java
// 产品接口
interface Product {
    void operation();
}

// 具体产品A
class ConcreteProductA implements Product {
    @Override
    public void operation() {
        System.out.println("ConcreteProductA operation");
    }
}

// 具体产品B
class ConcreteProductB implements Product {
    @Override
    public void operation() {
        System.out.println("ConcreteProductB operation");
    }
}

// 工厂接口
interface Factory {
    Product createProduct();
}

// 具体工厂A
class ConcreteFactoryA implements Factory {
    @Override
    public Product createProduct() {
        return new ConcreteProductA();
    }
}

// 具体工厂B
class ConcreteFactoryB implements Factory {
    @Override
    public Product createProduct() {
        return new ConcreteProductB();
    }
}
```

## 实际应用示例

以日志记录器为例：

```java
// 日志记录器接口
interface Logger {
    void writeLog(String message);
}

// 文件日志记录器
class FileLogger implements Logger {
    @Override
    public void writeLog(String message) {
        System.out.println("File Logger: " + message);
    }
}

// 数据库日志记录器
class DatabaseLogger implements Logger {
    @Override
    public void writeLog(String message) {
        System.out.println("Database Logger: " + message);
    }
}

// 日志记录器工厂接口
interface LoggerFactory {
    Logger createLogger();
}

// 文件日志记录器工厂
class FileLoggerFactory implements LoggerFactory {
    @Override
    public Logger createLogger() {
        // 可以在这里添加文件日志记录器的初始化代码
        return new FileLogger();
    }
}

// 数据库日志记录器工厂
class DatabaseLoggerFactory implements LoggerFactory {
    @Override
    public Logger createLogger() {
        // 可以在这里添加数据库连接等初始化代码
        return new DatabaseLogger();
    }
}

// 使用示例
public class LoggerExample {
    public static void main(String[] args) {
        LoggerFactory factory = new FileLoggerFactory();
        Logger logger = factory.createLogger();
        logger.writeLog("测试日志消息");

        factory = new DatabaseLoggerFactory();
        logger = factory.createLogger();
        logger.writeLog("测试日志消息");
    }
}
```

## 优点

1. 遵循单一职责原则，将创建对象的代码与使用对象的代码分离
2. 遵循开闭原则，可以引入新的产品类型而无需修改现有代码
3. 避免了创建者和具体产品之间的紧密耦合
4. 将产品的实例化推迟到子类进行

## 缺点

1. 需要引入许多新的子类，可能会使代码结构复杂化
2. 对于简单的对象创建可能会显得小题大做

## 与简单工厂的区别

1. 工厂方法模式更符合开闭原则
2. 工厂方法模式是类的创建模式，而简单工厂是对象的创建模式
3. 工厂方法模式可以允许系统在不修改原有代码的情况下引入新的产品类型

## 适用场景

1. 当一个类不知道它所需要的对象的类时
2. 当一个类希望由它的子类来指定它所创建的对象时
3. 当需要一个类的子类来创建对象，并且这些对象的创建过程比较复杂时

## 注意事项

1. 工厂方法模式通常和依赖倒置原则结合使用
2. 在实际应用中，可以结合单例模式来实现工厂类
3. 注意避免创建过多的工厂类，可能会导致系统复杂度增加

