---
title: "1 什么是 MySQL 事务？"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 1 什么是 MySQL 事务？
^e76500

事务就是一个完整的操作序列，要么全部成功，要么全部失败！
它能保证这两个步骤要么一起成功，要么一起失败。如果在执行的时候出了问题，事务就会回到开始的状态，把已经执行的操作撤销掉，确保数据的一致性。 ^9e6c24

# 2 事务的状态

^0c60f5

事务在其生命周期里会经历好几种状态：

1. 活动状态（active）：事务正在执行。
2. 部分提交状态（partially committed）：事务里的所有操作都弄完了，但还没提交。
3. 提交状态（committed）：事务成功提交了，对数据库的更改就永久保存下来啦。
4. 失败状态（failed）：事务执行的时候出错了。
5. 中止状态（aborted）：事务回滚啦，恢复到事务开始前的样子。

![](https://cdn.nlark.com/yuque/0/2024/jpeg/28830381/1730465987757-8df48c49-00db-44d4-9c68-b3300250ba1a.jpeg)

# 3 如何使用事务？

在 MySQL 里，咱们可以用下面的语句来定义和操作事务：

```sql
START TRANSACTION;
-- 这里写你的SQL操作，比如转账的SQL语句
COMMIT; -- 如果所有操作都成功，就提交事务
```
或者
```sql
START TRANSACTION;
-- 这里写你的SQL操作，比如转账的SQL语句
ROLLBACK; -- 如果出现错误，就回滚事务
```


> **注意，不是所有的MySQL存储引擎都支持事务。比如，MyISAM存储引擎就不支持事务，而InnoDB存储引擎则支持！**

# 4 MySQL事务的特性

^c75474

事务有四个重要的特性，简称ACID：

1. **原子性（Atomicity）：** 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
2. **一致性（Consistency）：** 事务必须使数据库从一个一致性状态变换到另一个一致性状态。
3. **隔离性（Isolation）：** 事务的隔离性是指多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离。
4. **持久性（Durability）：** 一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

# 5 事务的隔离级别

^80b699

在多个事务并发执行的情况下，如果没有采取必要的隔离机制，就会导致各种并发问题。为了解决这些问题，数据库提供了四种隔离级别：

## 5.1 并发事务可能引起的问题

在介绍隔离级别之前，我们先来了解一下并发事务可能会引起的几个典型问题：

1. **脏读（Dirty Read）**：一个事务读取了另一个未提交事务修改过的数据。
   ```sql
   -- 事务A
   START TRANSACTION;
   UPDATE account SET balance = balance - 100 WHERE id = 1;
   -- 此时事务B读取了数据
   ROLLBACK;  -- 事务A回滚
   
   -- 事务B读取到了事务A未提交的数据，这就是脏读
   ```

2. **不可重复读（Non-repeatable Read）**：一个事务内多次读取同一数据，但是这个数据在这期间被其他事务修改并提交了，导致两次读取的结果不一致。
   ```sql
   -- 事务A
   START TRANSACTION;
   SELECT balance FROM account WHERE id = 1;  -- 读取余额为1000
   -- 此时事务B修改了数据并提交
   SELECT balance FROM account WHERE id = 1;  -- 再次读取余额变为900
   COMMIT;
   
   -- 事务B
   UPDATE account SET balance = 900 WHERE id = 1;
   COMMIT;
   ```

3. **幻读（Phantom Read）**：一个事务在查询某个范围的记录时，另一个事务在这个范围内插入了新的记录，当第一个事务再次查询时，会发现多了一些原本不存在的记录。
   ```sql
   -- 事务A
   START TRANSACTION;
   SELECT * FROM account WHERE balance > 1000;  -- 查询到3条记录
   -- 此时事务B插入了一条余额为1500的记录
   SELECT * FROM account WHERE balance > 1000;  -- 查询到4条记录
   COMMIT;
   ```

## 5.2 四种隔离级别

^c55f20

为了解决上述问题，SQL标准定义了四种隔离级别：

### 5.2.1 读未提交（READ UNCOMMITTED）
- **特点**：最低的隔离级别，允许读取未提交的数据。
- **存在的问题**：脏读、不可重复读、幻读都可能发生。
- **使用场景**：对数据一致性要求不高，但要求性能最高的场景。
- **设置方式**：
  ```sql
  SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
  ```

### 5.2.2 读已提交（READ COMMITTED）
- **特点**：只能读取已经提交的数据。
- **解决的问题**：解决了脏读的问题。
- **存在的问题**：不可重复读、幻读仍可能发生。
- **使用场景**：大多数数据库的默认级别（如Oracle）。
- **设置方式**：
  ```sql
  SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
  ```

### 5.2.3 可重复读（REPEATABLE READ）
- **特点**：同一事务内多次读取数据结果一致。
- **解决问题**：解决了脏读、不可重复读的问题。
- **存在的问题**：可能发生幻读。
- **使用场景**：MySQL InnoDB的默认级别。
- **设置方式**：
  ```sql
  SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
  ```

### 5.2.4 串行化（SERIALIZABLE）
- **特点**：最高的隔离级别，完全串行执行。
- **解决问题**：解决了脏读、不可重复读、幻读的问题。
- **缺点**：性能最差，因为事务是串行执行的。
- **使用场景**：对数据一致性要求极高的场景。
- **设置方式**：
  ```sql
  SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE;
  ```

## 5.3 隔离级别对比

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 性能 |
|---------|------|------------|------|------|
| 读未提交 | 可能 | 可能 | 可能 | 最好 |
| 读已提交 | 不可能 | 可能 | 可能 | 好 |
| 可重复读 | 不可能 | 不可能 | 可能 | 一般 |
| 串行化 | 不可能 | 不可能 | 不可能 | 最差 |

>**注意**：在实际应用中，要根据业务需求选择合适的隔离级别。通常情况下，MySQL的默认隔离级别（可重复读）能满足大多数应用场景的需求。如果应用对数据一致性要求特别高，可以考虑使用串行化隔离级别，但要注意性能影响。

# 6 事务的设置与查看

我们可以分别来查看和设置事务的开启情况和事务的隔离级别，我们先来看一下事务的隔离级别。  
在默认情况下，**MySQL的InnoDB存储引擎使用的是可重复读**（REPEATABLE READ）隔离级别。，我们可以通过以下的命令来查看和设置事务的隔离级别：

```sql
-- 查看当前事务的隔离级别
SHOW VARIABLES LIKE 'transaction_isolation';

-- 设置事务隔离级别
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

接下来我们查看和设置一下事务的状态：

```sql
-- 查看事务开启情况：
mysql> SHOW VARIABLES LIKE 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+

-- 关闭事务的自动提交，把系统变量autocommit的值设置为OFF。
SET autocommit = OFF;
```

>默认是事务自动提交的，每执行一条SQL就自动提交。
>此时需要操作事务，则需要显式开启（begin or start transaction）和提交（commit）或回滚（rollback）。
>如设置成OFF，则需要执行提交（commit）或回滚（rollback）操作时才会真正执行事务。

# 7 事务日志

为了确保事务的可靠性，MySQL采用了日志机制，其中包括两种重要的日志类型：

### 7.1.1 Redo Log（重做日志）

- **功能**：记录事务提交时所做的所有更改。
- **作用**：在系统崩溃后，可以利用这些记录来恢复数据，确保事务的持久性。

### 7.1.2 Undo Log（回滚日志）

- **功能**：保存事务开始前的数据状态。
- **用途**：

	- **回滚操作**：如果事务执行失败或被用户取消，可以使用Undo Log将数据恢复到事务开始前的状态。
	- **多版本并发控制（MVCC）**：支持并发事务处理，通过提供不同时间点的数据视图来避免读写冲突。

通过这两种日志机制，MySQL能够有效地保证事务的完整性和一致性。

# 8 事务失效的原因

有以下几种情况可能会让事务失效：

1. 存储引擎不支持事务（比如 MyISAM）。
2. 没有用`START TRANSACTION`语句。
3. 在事务里用了不是事务安全的 SQL 函数（比如`LOAD DATA INFILE`）。
4. 把自动提交设置成 ON 了（默认情况下，MySQL 是自动提交的）。
5. 服务器崩溃或者断电了（虽然不影响已经提交的事务，但可能影响没提交的事务）。




