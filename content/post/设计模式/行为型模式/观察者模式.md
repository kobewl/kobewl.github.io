---
title: "观察者模式（Observer Pattern）"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 观察者模式（Observer Pattern）

## 概述

观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。当主题对象的状态发生变化时，所有依赖于它的观察者都会得到通知并自动更新。这种模式也被称为发布-订阅（Publish/Subscribe）模式。

## 使用场景

- 当一个对象的改变需要同时改变其他对象时
- 当一个对象必须通知其他对象，而它又不知道这些对象是谁时
- 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面时
- 需要在系统中创建一个触发链时

## 基本实现

```java
// 观察者接口
interface Observer {
    void update(String message);
}

// 主题接口
interface Subject {
    void registerObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers();
}

// 具体主题
class ConcreteSubject implements Subject {
    private List<Observer> observers = new ArrayList<>();
    private String state;

    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }

    @Override
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(state);
        }
    }

    public void setState(String state) {
        this.state = state;
        notifyObservers();
    }
}

// 具体观察者
class ConcreteObserver implements Observer {
    private String name;

    public ConcreteObserver(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        System.out.println(name + " 收到消息: " + message);
    }
}
```

## 实际应用示例

以新闻订阅系统为例：

```java
// 新闻类型枚举
enum NewsType {
    TECH, BUSINESS, SPORTS
}

// 新闻类
class NewsData {
    private String title;
    private String content;
    private NewsType type;

    public NewsData(String title, String content, NewsType type) {
        this.title = title;
        this.content = content;
        this.type = type;
    }

    // getter方法
    public String getTitle() { return title; }
    public String getContent() { return content; }
    public NewsType getType() { return type; }
}

// 新闻订阅者接口
interface NewsSubscriber {
    void onNews(NewsData news);
    Set<NewsType> getSubscribedTypes();
}

// 新闻发布系统
class NewsAgency {
    private List<NewsSubscriber> subscribers = new ArrayList<>();

    // 添加订阅者
    public void addSubscriber(NewsSubscriber subscriber) {
        subscribers.add(subscriber);
    }

    // 移除订阅者
    public void removeSubscriber(NewsSubscriber subscriber) {
        subscribers.remove(subscriber);
    }

    // 发布新闻
    public void publishNews(NewsData news) {
        for (NewsSubscriber subscriber : subscribers) {
            if (subscriber.getSubscribedTypes().contains(news.getType())) {
                subscriber.onNews(news);
            }
        }
    }
}

// 邮件订阅者
class EmailSubscriber implements NewsSubscriber {
    private String email;
    private Set<NewsType> subscribedTypes;

    public EmailSubscriber(String email, NewsType... types) {
        this.email = email;
        this.subscribedTypes = new HashSet<>(Arrays.asList(types));
    }

    @Override
    public void onNews(NewsData news) {
        System.out.println("发送邮件到 " + email);
        System.out.println("标题: " + news.getTitle());
        System.out.println("内容: " + news.getContent());
        System.out.println("类型: " + news.getType());
    }

    @Override
    public Set<NewsType> getSubscribedTypes() {
        return subscribedTypes;
    }
}

// 手机APP订阅者
class MobileAppSubscriber implements NewsSubscriber {
    private String userId;
    private Set<NewsType> subscribedTypes;

    public MobileAppSubscriber(String userId, NewsType... types) {
        this.userId = userId;
        this.subscribedTypes = new HashSet<>(Arrays.asList(types));
    }

    @Override
    public void onNews(NewsData news) {
        System.out.println("推送通知到用户 " + userId);
        System.out.println("新闻: " + news.getTitle());
    }

    @Override
    public Set<NewsType> getSubscribedTypes() {
        return subscribedTypes;
    }
}
```

## 另一个实际示例：股票价格监控系统

```java
// 股票数据类
class StockData {
    private String symbol;
    private double price;
    private Date timestamp;

    public StockData(String symbol, double price) {
        this.symbol = symbol;
        this.price = price;
        this.timestamp = new Date();
    }

    // getter方法
    public String getSymbol() { return symbol; }
    public double getPrice() { return price; }
    public Date getTimestamp() { return timestamp; }
}

// 股票观察者接口
interface StockObserver {
    void onStockChange(StockData stockData);
}

// 股票市场
class StockMarket {
    private Map<String, List<StockObserver>> observers = new HashMap<>();
    private Map<String, Double> lastPrices = new HashMap<>();

    // 添加观察者
    public void addObserver(String symbol, StockObserver observer) {
        observers.computeIfAbsent(symbol, k -> new ArrayList<>()).add(observer);
    }

    // 移除观察者
    public void removeObserver(String symbol, StockObserver observer) {
        if (observers.containsKey(symbol)) {
            observers.get(symbol).remove(observer);
        }
    }

    // 更新股票价格
    public void updateStock(String symbol, double newPrice) {
        // 检查价格是否真的发生变化
        if (!lastPrices.containsKey(symbol) || lastPrices.get(symbol) != newPrice) {
            lastPrices.put(symbol, newPrice);
            notifyObservers(new StockData(symbol, newPrice));
        }
    }

    private void notifyObservers(StockData stockData) {
        String symbol = stockData.getSymbol();
        if (observers.containsKey(symbol)) {
            for (StockObserver observer : observers.get(symbol)) {
                observer.onStockChange(stockData);
            }
        }
    }
}

// 价格提醒器
class PriceAlertObserver implements StockObserver {
    private String userId;
    private double targetPrice;
    private boolean isAboveTarget;

    public PriceAlertObserver(String userId, double targetPrice, boolean isAboveTarget) {
        this.userId = userId;
        this.targetPrice = targetPrice;
        this.isAboveTarget = isAboveTarget;
    }

    @Override
    public void onStockChange(StockData stockData) {
        if (isAboveTarget && stockData.getPrice() > targetPrice) {
            System.out.println("提醒用户 " + userId + ": " + stockData.getSymbol() +
                " 价格已超过 " + targetPrice);
        } else if (!isAboveTarget && stockData.getPrice() < targetPrice) {
            System.out.println("提醒用户 " + userId + ": " + stockData.getSymbol() +
                " 价格已低于 " + targetPrice);
        }
    }
}

// 股票分析器
class StockAnalyzer implements StockObserver {
    private Map<String, List<Double>> priceHistory = new HashMap<>();

    @Override
    public void onStockChange(StockData stockData) {
        // 记录价格历史
        priceHistory.computeIfAbsent(stockData.getSymbol(), k -> new ArrayList<>())
                   .add(stockData.getPrice());

        // 进行分析
        analyzeStock(stockData);
    }

    private void analyzeStock(StockData stockData) {
        List<Double> history = priceHistory.get(stockData.getSymbol());
        if (history.size() >= 2) {
            double previousPrice = history.get(history.size() - 2);
            double currentPrice = stockData.getPrice();
            double change = ((currentPrice - previousPrice) / previousPrice) * 100;

            System.out.println("股票分析 - " + stockData.getSymbol());
            System.out.printf("价格变化: %.2f%%\n", change);
        }
    }
}
```

## 优点

1. 实现了观察者和主题之间的松耦合
2. 支持广播通信
3. 符合开闭原则，容易扩展
4. 可以在运行时建立对象之间的关系

## 缺点

1. 观察者模式可能会引起内存泄漏
2. 如果观察者太多，通知的过程会花费较多时间
3. 如果观察者和主题之间有循环依赖，可能会导致系统崩溃

## 适用场景

1. 当一个对象的改变需要同时改变其他对象时
2. 当一个对象必须通知其他对象，而又不知道这些对象是谁时
3. 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面时
4. 需要在系统中创建一个触发链时

## 注意事项

1. 注意避免循环调用
2. 考虑线程安全问题
3. 注意观察者的添加和删除时机
4. 可以考虑使用弱引用来避免内存泄漏

