---
title: "1 状态模式（State Pattern）"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 1 状态模式（State Pattern）

## 1.1 概述

状态模式是一种行为型设计模式，它允许一个对象在其内部状态改变时改变它的行为。状态模式将状态封装成独立的类，并将动作委托到代表当前状态的对象，从而使得对象看起来似乎修改了它的类。

## 1.2 使用场景

- 对象的行为取决于它的状态，并且必须在运行时根据状态改变它的行为
- 代码中包含大量与对象状态有关的条件语句
- 需要消除庞大的条件分支语句
- 状态转换规则复杂的场景

## 1.3 基本实现

```java
// 状态接口
interface State {
    void handle();
}

// 具体状态A
class ConcreteStateA implements State {
    @Override
    public void handle() {
        System.out.println("状态A的处理逻辑");
    }
}

// 具体状态B
class ConcreteStateB implements State {
    @Override
    public void handle() {
        System.out.println("状态B的处理逻辑");
    }
}

// 上下文类
class Context {
    private State currentState;

    public Context() {
        // 设置初始状态
        currentState = new ConcreteStateA();
    }

    public void setState(State state) {
        this.currentState = state;
    }

    public void request() {
        currentState.handle();
    }
}
```

## 1.4 实际应用示例

以自动售货机为例：

```java
// 商品类
class Product {
    private String name;
    private double price;

    public Product(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public String getName() { return name; }
    public double getPrice() { return price; }
}

// 售货机状态接口
interface VendingMachineState {
    void insertMoney(VendingMachine machine, double amount);
    void selectProduct(VendingMachine machine, String productCode);
    void dispense(VendingMachine machine);
    void refund(VendingMachine machine);
}

// 待机状态
class IdleState implements VendingMachineState {
    @Override
    public void insertMoney(VendingMachine machine, double amount) {
        machine.setCurrentAmount(machine.getCurrentAmount() + amount);
        System.out.println("投入金额: " + amount + "元");
        machine.setState(new HasMoneyState());
    }

    @Override
    public void selectProduct(VendingMachine machine, String productCode) {
        System.out.println("请先投币");
    }

    @Override
    public void dispense(VendingMachine machine) {
        System.out.println("请先投币并选择商品");
    }

    @Override
    public void refund(VendingMachine machine) {
        System.out.println("没有可退的金额");
    }
}

// 已投币状态
class HasMoneyState implements VendingMachineState {
    @Override
    public void insertMoney(VendingMachine machine, double amount) {
        machine.setCurrentAmount(machine.getCurrentAmount() + amount);
        System.out.println("追加金额: " + amount + "元");
    }

    @Override
    public void selectProduct(VendingMachine machine, String productCode) {
        Product product = machine.getProduct(productCode);
        if (product != null) {
            if (machine.getCurrentAmount() >= product.getPrice()) {
                System.out.println("已选择商品: " + product.getName());
                machine.setSelectedProduct(product);
                machine.setState(new ProductSelectedState());
            } else {
                System.out.println("金额不足，请继续投币");
            }
        } else {
            System.out.println("商品不存在");
        }
    }

    @Override
    public void dispense(VendingMachine machine) {
        System.out.println("请先选择商品");
    }

    @Override
    public void refund(VendingMachine machine) {
        System.out.println("退还金额: " + machine.getCurrentAmount() + "元");
        machine.setCurrentAmount(0);
        machine.setState(new IdleState());
    }
}

// 已选择商品状态
class ProductSelectedState implements VendingMachineState {
    @Override
    public void insertMoney(VendingMachine machine, double amount) {
        System.out.println("已选择商品，无需继续投币");
    }

    @Override
    public void selectProduct(VendingMachine machine, String productCode) {
        System.out.println("已选择商品，请等待出货");
    }

    @Override
    public void dispense(VendingMachine machine) {
        Product product = machine.getSelectedProduct();
        double change = machine.getCurrentAmount() - product.getPrice();
        System.out.println("出货: " + product.getName());
        if (change > 0) {
            System.out.println("找零: " + change + "元");
        }
        machine.setCurrentAmount(0);
        machine.setSelectedProduct(null);
        machine.setState(new IdleState());
    }

    @Override
    public void refund(VendingMachine machine) {
        System.out.println("退还金额: " + machine.getCurrentAmount() + "元");
        machine.setCurrentAmount(0);
        machine.setSelectedProduct(null);
        machine.setState(new IdleState());
    }
}

// 售货机类
class VendingMachine {
    private VendingMachineState currentState;
    private Map<String, Product> products;
    private double currentAmount;
    private Product selectedProduct;

    public VendingMachine() {
        currentState = new IdleState();
        products = new HashMap<>();
        currentAmount = 0;
        // 初始化商品
        products.put("A1", new Product("可乐", 3.0));
        products.put("A2", new Product("雪碧", 3.0));
        products.put("B1", new Product("薯片", 6.0));
        products.put("B2", new Product("巧克力", 5.0));
    }

    public void setState(VendingMachineState state) {
        this.currentState = state;
    }

    public void insertMoney(double amount) {
        currentState.insertMoney(this, amount);
    }

    public void selectProduct(String productCode) {
        currentState.selectProduct(this, productCode);
    }

    public void dispense() {
        currentState.dispense(this);
    }

    public void refund() {
        currentState.refund(this);
    }

    // getter和setter方法
    public double getCurrentAmount() { return currentAmount; }
    public void setCurrentAmount(double amount) { this.currentAmount = amount; }
    public Product getProduct(String code) { return products.get(code); }
    public Product getSelectedProduct() { return selectedProduct; }
    public void setSelectedProduct(Product product) { this.selectedProduct = product; }
}
```

## 1.5 另一个实际示例：订单状态管理

```java
// 订单状态接口
interface OrderState {
    void pay(Order order);
    void ship(Order order);
    void deliver(Order order);
    void cancel(Order order);
}

// 待付款状态
class PendingPaymentState implements OrderState {
    @Override
    public void pay(Order order) {
        System.out.println("订单支付成功");
        order.setState(new PaidState());
    }

    @Override
    public void ship(Order order) {
        System.out.println("订单尚未支付，无法发货");
    }

    @Override
    public void deliver(Order order) {
        System.out.println("订单尚未支付，无法送达");
    }

    @Override
    public void cancel(Order order) {
        System.out.println("订单已取消");
        order.setState(new CancelledState());
    }
}

// 已支付状态
class PaidState implements OrderState {
    @Override
    public void pay(Order order) {
        System.out.println("订单已支付，无需重复支付");
    }

    @Override
    public void ship(Order order) {
        System.out.println("订单已发货");
        order.setState(new ShippedState());
    }

    @Override
    public void deliver(Order order) {
        System.out.println("订单尚未发货，无法送达");
    }

    @Override
    public void cancel(Order order) {
        System.out.println("订单已支付，需要申请退款才能取消");
    }
}

// 已发货状态
class ShippedState implements OrderState {
    @Override
    public void pay(Order order) {
        System.out.println("订单已支付，无需重复支付");
    }

    @Override
    public void ship(Order order) {
        System.out.println("订单已发货，无需重复发货");
    }

    @Override
    public void deliver(Order order) {
        System.out.println("订单已送达");
        order.setState(new DeliveredState());
    }

    @Override
    public void cancel(Order order) {
        System.out.println("订单已发货，无法取消");
    }
}

// 已送达状态
class DeliveredState implements OrderState {
    @Override
    public void pay(Order order) {
        System.out.println("订单已完成，无需支付");
    }

    @Override
    public void ship(Order order) {
        System.out.println("订单已完成，无需发货");
    }

    @Override
    public void deliver(Order order) {
        System.out.println("订单已送达，无需重复送达");
    }

    @Override
    public void cancel(Order order) {
        System.out.println("订单已完成，无法取消");
    }
}

// 已取消状态
class CancelledState implements OrderState {
    @Override
    public void pay(Order order) {
        System.out.println("订单已取消，无法支付");
    }

    @Override
    public void ship(Order order) {
        System.out.println("订单已取消，无法发货");
    }

    @Override
    public void deliver(Order order) {
        System.out.println("订单已取消，无法送达");
    }

    @Override
    public void cancel(Order order) {
        System.out.println("订单已经是取消状态");
    }
}

// 订单类
class Order {
    private String orderId;
    private OrderState state;
    private List<String> items;
    private double totalAmount;

    public Order(String orderId, List<String> items, double totalAmount) {
        this.orderId = orderId;
        this.items = items;
        this.totalAmount = totalAmount;
        this.state = new PendingPaymentState();
    }

    public void setState(OrderState state) {
        this.state = state;
    }

    public void pay() { state.pay(this); }
    public void ship() { state.ship(this); }
    public void deliver() { state.deliver(this); }
    public void cancel() { state.cancel(this); }

    // getter方法
    public String getOrderId() { return orderId; }
    public List<String> getItems() { return items; }
    public double getTotalAmount() { return totalAmount; }
}
```

## 1.6 优点

1. 封装了状态的转换规则，使得状态转换更加明确
2. 将与特定状态相关的行为局部化，减少了条件语句
3. 使得状态转换更加明确，便于维护
4. 允许状态转换逻辑与状态对象合成一体

## 1.7 缺点

1. 可能会导致状态类的数量增多
2. 状态模式的结构与实现都较为复杂
3. 对"开闭原则"的支持并不太好，增加新的状态类需要修改那些负责状态转换的源代码

## 1.8 适用场景

1. 对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为
2. 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态
3. 需要对对象的状态转换进行严格控制的场景

## 1.9 注意事项

1. 状态模式的使用必须在环境类中维护状态，并且对状态对象进行唯一性检查
2. 注意状态转换的条件和顺序
3. 注意状态对象的共享问题
4. 注意环境类与状态类之间的依赖关系

