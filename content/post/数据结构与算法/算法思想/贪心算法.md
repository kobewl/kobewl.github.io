---
title: "贪心算法 (Greedy Algorithm)"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 贪心算法 (Greedy Algorithm)

## 1. 基本概念

### 1.1 定义

- 贪心算法是一种在每一步选择中都采取当前状态下最好或最优的选择
- 通过局部最优选择，期望导致全局最优解
- 不需要回溯和动态规划中的状态记录

### 1.2 特点

1. **局部最优选择**

   - 每步选择都是当前最优
   - 不考虑全局影响
   - 选择一旦做出，不再改变

2. **适用条件**
   - 问题具有贪心选择性质
   - 问题具有最优子结构
   - 局部最优导致全局最优

## 2. 常见问题类型

### 2.1 区间问题

```java
// 区间调度问题
public class IntervalScheduling {
    public int maxMeetings(int[] start, int[] end) {
        int n = start.length;
        Meeting[] meetings = new Meeting[n];

        // 创建会议对象数组
        for (int i = 0; i < n; i++) {
            meetings[i] = new Meeting(start[i], end[i]);
        }

        // 按结束时间排序
        Arrays.sort(meetings, (a, b) -> a.end - b.end);

        int count = 1;  // 第一个会议一定可以安排
        int lastEnd = meetings[0].end;

        // 贪心选择不冲突的会议
        for (int i = 1; i < n; i++) {
            if (meetings[i].start >= lastEnd) {
                count++;
                lastEnd = meetings[i].end;
            }
        }
        return count;
    }

    class Meeting {
        int start, end;
        Meeting(int start, int end) {
            this.start = start;
            this.end = end;
        }
    }
}
```

### 2.2 分配问题

```java
// 分发糖果问题
public class CandyDistribution {
    public int candy(int[] ratings) {
        int n = ratings.length;
        int[] candies = new int[n];
        Arrays.fill(candies, 1);  // 每个孩子至少一颗糖

        // 从左向右扫描
        for (int i = 1; i < n; i++) {
            if (ratings[i] > ratings[i-1]) {
                candies[i] = candies[i-1] + 1;
            }
        }

        // 从右向左扫描
        for (int i = n-2; i >= 0; i--) {
            if (ratings[i] > ratings[i+1]) {
                candies[i] = Math.max(candies[i], candies[i+1] + 1);
            }
        }

        // 计算总和
        return Arrays.stream(candies).sum();
    }
}
```

### 2.3 最小生成树

```java
// Kruskal算法实现最小生成树
public class KruskalMST {
    class Edge implements Comparable<Edge> {
        int src, dest, weight;

        public int compareTo(Edge other) {
            return this.weight - other.weight;
        }
    }

    class UnionFind {
        int[] parent;

        UnionFind(int n) {
            parent = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
            }
        }

        int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }

        void union(int x, int y) {
            parent[find(x)] = find(y);
        }
    }

    public List<Edge> kruskal(List<Edge> edges, int n) {
        List<Edge> mst = new ArrayList<>();
        UnionFind uf = new UnionFind(n);

        // 按权重排序所有边
        Collections.sort(edges);

        for (Edge edge : edges) {
            if (mst.size() == n-1) break;

            if (uf.find(edge.src) != uf.find(edge.dest)) {
                mst.add(edge);
                uf.union(edge.src, edge.dest);
            }
        }
        return mst;
    }
}
```

### 2.4 背包问题

```java
// 分数背包问题
public class FractionalKnapsack {
    class Item {
        int weight;
        int value;
        double ratio;  // 价值密度

        Item(int weight, int value) {
            this.weight = weight;
            this.value = value;
            this.ratio = (double)value / weight;
        }
    }

    public double getMaxValue(int[] weights, int[] values, int capacity) {
        int n = weights.length;
        Item[] items = new Item[n];

        // 创建物品对象并计算价值密度
        for (int i = 0; i < n; i++) {
            items[i] = new Item(weights[i], values[i]);
        }

        // 按价值密度排序
        Arrays.sort(items, (a, b) -> Double.compare(b.ratio, a.ratio));

        double totalValue = 0;
        int currentWeight = 0;

        for (Item item : items) {
            if (currentWeight + item.weight <= capacity) {
                // 可以完整放入
                currentWeight += item.weight;
                totalValue += item.value;
            } else {
                // 部分放入
                int remainingCapacity = capacity - currentWeight;
                totalValue += item.ratio * remainingCapacity;
                break;
            }
        }
        return totalValue;
    }
}
```

## 3. 解题思路

### 3.1 基本步骤

1. **问题分析**

   - 确定问题是否适合贪心
   - 找出局部最优策略
   - 验证全局最优性

2. **贪心策略设计**

   - 定义选择标准
   - 设计选择过程
   - 考虑边界情况

3. **正确性证明**
   - 数学归纳法
   - 反证法
   - 举例验证

### 3.2 常用技巧

1. **排序预处理**

   - 按特定属性排序
   - 多关键字排序
   - 自定义比较器

2. **双向扫描**
   - 正向处理
   - 反向处理
   - 结果合并

## 4. 实战技巧

### 4.1 常见误区

1. **策略选择不当**

   - 局部最优不导致全局最优
   - 忽略了某些约束条件
   - 贪心策略过于简单

2. **边界处理不当**
   - 特殊情况未考虑
   - 临界值处理错误
   - 初始化不正确

### 4.2 优化方向

1. **时间优化**

   - 高效的数据结构
   - 预处理优化
   - 剪枝策略

2. **空间优化**
   - 原地算法
   - 变量复用
   - 空间压缩

## 5. 实际应用

### 5.1 应用场景

1. **调度问题**

   - 任务调度
   - 资源分配
   - 时间安排

2. **网络问题**

   - 最小生成树
   - 最短路径
   - 网络流

3. **优化问题**
   - 装载问题
   - 切割问题
   - 分配问题

### 5.2 实际案例

1. **系统设计**

   - 缓存策略
   - 负载均衡
   - 资源调度

2. **金融应用**

   - 投资组合
   - 风险控制
   - 交易策略

3. **物流规划**
   - 路径优化
   - 仓储管理
   - 配送规划

