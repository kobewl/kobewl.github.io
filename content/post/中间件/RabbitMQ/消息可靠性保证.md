---
title: "RabbitMQ 消息可靠性保证"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# RabbitMQ 消息可靠性保证

## 生产者确认机制

### Publisher Confirm

#### 1. 单条确认

```java
// 开启发布确认
channel.confirmSelect();

// 发送消息
channel.basicPublish(exchange, routingKey, null, message.getBytes());

// 等待确认
if (channel.waitForConfirms()) {
    System.out.println("消息发送成功");
} else {
    System.out.println("消息发送失败");
}
```

#### 2. 批量确认

```java
channel.confirmSelect();
for (int i = 0; i < batchSize; i++) {
    channel.basicPublish(exchange, routingKey, null, message.getBytes());
}
channel.waitForConfirmsOrDie(5_000); // 等待5秒
```

#### 3. 异步确认

```java
ConcurrentNavigableMap<Long, String> outstandingConfirms = new ConcurrentSkipListMap<>();

channel.confirmSelect();
channel.addConfirmListener((sequenceNumber, multiple) -> {
    // 确认成功回调
    if (multiple) {
        ConcurrentNavigableMap<Long, String> confirmed = outstandingConfirms.headMap(
                sequenceNumber, true
        );
        confirmed.clear();
    } else {
        outstandingConfirms.remove(sequenceNumber);
    }
}, (sequenceNumber, multiple) -> {
    // 确认失败回调
    String message = outstandingConfirms.get(sequenceNumber);
    System.err.format("Message with body %s has been nack-ed. Sequence number: %d, multiple: %b%n",
            message, sequenceNumber, multiple);
    // 重发消息逻辑
});
```

### Publisher Return

```java
channel.addReturnListener((replyCode, replyText, exchange, routingKey, properties, body) -> {
    String message = new String(body);
    System.err.format("Message %s returned with reply code %d: %s%n",
            message, replyCode, replyText);
});

// 发送消息时设置 mandatory 为 true
channel.basicPublish(exchange, routingKey, true, null, message.getBytes());
```

## 消费者确认机制

### Consumer Ack

#### 1. 自动确认（autoAck=true）

```java
channel.basicConsume(queueName, true, (consumerTag, delivery) -> {
    String message = new String(delivery.getBody(), "UTF-8");
    // 处理消息
}, consumerTag -> {});
```

#### 2. 手动确认（autoAck=false）

```java
channel.basicConsume(queueName, false, (consumerTag, delivery) -> {
    try {
        String message = new String(delivery.getBody(), "UTF-8");
        // 处理消息
        channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
    } catch (Exception e) {
        // 处理失败，拒绝消息
        channel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, true);
    }
}, consumerTag -> {});
```

#### 3. 批量确认

```java
// 设置预取数量
channel.basicQos(100);

channel.basicConsume(queueName, false, (consumerTag, delivery) -> {
    // 处理消息
    // 批量确认
    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), true);
}, consumerTag -> {});
```

### Consumer Reject

#### 1. Basic.Reject（单条拒绝）

```java
channel.basicReject(delivery.getEnvelope().getDeliveryTag(), true); // 重回队列
```

#### 2. Basic.Nack（批量拒绝）

```java
channel.basicNack(delivery.getEnvelope().getDeliveryTag(), true, true); // 批量拒绝并重回队列
```

## 持久化机制

### Exchange 持久化

```java
// 声明持久化的交换机
channel.exchangeDeclare(exchangeName, "direct", true);
```

### Queue 持久化

```java
// 声明持久化的队列
channel.queueDeclare(queueName, true, false, false, null);
```

### Message 持久化

```java
// 发送持久化消息
AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()
    .deliveryMode(2) // 持久化消息
    .build();
channel.basicPublish(exchange, routingKey, properties, message.getBytes());
```

## 死信队列

### 死信交换机配置

```java
// 声明死信交换机
channel.exchangeDeclare("dlx.exchange", "direct");

// 声明死信队列
channel.queueDeclare("dlx.queue", true, false, false, null);

// 绑定死信队列到死信交换机
channel.queueBind("dlx.queue", "dlx.exchange", "dlx.routing.key");

// 为普通队列指定死信交换机
Map<String, Object> args = new HashMap<>();
args.put("x-dead-letter-exchange", "dlx.exchange");
args.put("x-dead-letter-routing-key", "dlx.routing.key");
channel.queueDeclare("normal.queue", true, false, false, args);
```

### 死信消息处理

```java
// 消费死信队列
channel.basicConsume("dlx.queue", false, (consumerTag, delivery) -> {
    String message = new String(delivery.getBody(), "UTF-8");
    // 处理死信消息
    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
}, consumerTag -> {});
```

## 延迟队列

### TTL + DLX 实现

```java
// 声明延迟队列（设置TTL）
Map<String, Object> args = new HashMap<>();
args.put("x-message-ttl", 5000); // 5秒延迟
args.put("x-dead-letter-exchange", "dlx.exchange");
args.put("x-dead-letter-routing-key", "dlx.routing.key");
channel.queueDeclare("delay.queue", true, false, false, args);
```

### 插件实现

```java
// 使用延迟消息插件
channel.exchangeDeclare("delay.exchange", "x-delayed-message",
    Collections.singletonMap("x-delayed-type", "direct"));

// 发送延迟消息
AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()
    .headers(Collections.singletonMap("x-delay", 5000))
    .build();
channel.basicPublish("delay.exchange", routingKey, properties, message.getBytes());
```

