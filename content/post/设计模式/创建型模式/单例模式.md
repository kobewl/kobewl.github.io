---
title: "单例模式（Singleton Pattern）"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 单例模式（Singleton Pattern）

## 概述

单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点。

## 使用场景

- 需要严格控制全局状态时
- 资源共享的场景（如配置文件、线程池、数据库连接池等）
- 需要频繁实例化然后销毁的对象
- 创建对象时耗时过多或耗费资源过多，但又经常用到的对象

## 实现方式

### 1. 懒汉式（线程不安全）

```java
public class Singleton {
    private static Singleton instance;

    // 私有构造函数
    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

### 2. 懒汉式（线程安全，同步方法）

```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

### 3. 双重检查锁（DCL）

```java
public class Singleton {
    // volatile关键字确保instance变量的可见性
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

### 4. 静态内部类（推荐使用）

```java
public class Singleton {
    private Singleton() {}

    // 静态内部类，实现延迟加载
    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

### 5. 枚举实现（最简单）

```java
public enum Singleton {
    INSTANCE;

    public void doSomething() {
        // 业务方法
    }
}
```

## 优点

1. 保证一个类只有一个实例
2. 提供了对唯一实例的全局访问点
3. 节省系统资源

## 缺点

1. 单例模式可能会隐藏类之间的依赖关系
2. 单例类的职责过重
3. 扩展困难

## 注意事项

1. 注意线程安全问题
2. 考虑序列化和反序列化的影响
3. 注意延迟加载和性能的平衡
4. 考虑反射攻击的防范

## 实际应用示例

```java
// 配置管理器示例
public class ConfigManager {
    private static volatile ConfigManager instance;
    private Properties properties;

    private ConfigManager() {
        properties = new Properties();
        try {
            properties.load(new FileInputStream("config.properties"));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static ConfigManager getInstance() {
        if (instance == null) {
            synchronized (ConfigManager.class) {
                if (instance == null) {
                    instance = new ConfigManager();
                }
            }
        }
        return instance;
    }

    public String getProperty(String key) {
        return properties.getProperty(key);
    }
}
```

