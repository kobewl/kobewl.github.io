---
title: "1 抽象工厂模式（Abstract Factory Pattern）"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 1 抽象工厂模式（Abstract Factory Pattern）

## 1.1 概述

抽象工厂模式是一种创建型设计模式，它提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。抽象工厂模式与工厂方法模式的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则是针对的多个产品等级结构。

## 1.2 使用场景

- 一个系统要独立于它的产品的创建、组合和表示时
- 一个系统要由多个产品系列中的一个来配置时
- 当你要强调一系列相关的产品对象的设计以便进行联合使用时
- 当你提供一个产品类库，而只想显示它们的接口而不是实现时

## 1.3 结构示例

```java
// 抽象产品A
interface AbstractProductA {
    void operationA();
}

// 抽象产品B
interface AbstractProductB {
    void operationB();
}

// 具体产品A1
class ConcreteProductA1 implements AbstractProductA {
    @Override
    public void operationA() {
        System.out.println("Product A1 operation");
    }
}

// 具体产品A2
class ConcreteProductA2 implements AbstractProductA {
    @Override
    public void operationA() {
        System.out.println("Product A2 operation");
    }
}

// 具体产品B1
class ConcreteProductB1 implements AbstractProductB {
    @Override
    public void operationB() {
        System.out.println("Product B1 operation");
    }
}

// 具体产品B2
class ConcreteProductB2 implements AbstractProductB {
    @Override
    public void operationB() {
        System.out.println("Product B2 operation");
    }
}

// 抽象工厂
interface AbstractFactory {
    AbstractProductA createProductA();
    AbstractProductB createProductB();
}

// 具体工厂1
class ConcreteFactory1 implements AbstractFactory {
    @Override
    public AbstractProductA createProductA() {
        return new ConcreteProductA1();
    }

    @Override
    public AbstractProductB createProductB() {
        return new ConcreteProductB1();
    }
}

// 具体工厂2
class ConcreteFactory2 implements AbstractFactory {
    @Override
    public AbstractProductA createProductA() {
        return new ConcreteProductA2();
    }

    @Override
    public AbstractProductB createProductB() {
        return new ConcreteProductB2();
    }
}
```

## 1.4 实际应用示例

以跨平台 UI 组件为例：

```java
// 抽象按钮
interface Button {
    void paint();
    void click();
}

// 抽象文本框
interface TextField {
    void paint();
    void input(String text);
}

// Windows按钮
class WindowsButton implements Button {
    @Override
    public void paint() {
        System.out.println("Render a button in Windows style");
    }

    @Override
    public void click() {
        System.out.println("Windows button clicked");
    }
}

// MacOS按钮
class MacOSButton implements Button {
    @Override
    public void paint() {
        System.out.println("Render a button in MacOS style");
    }

    @Override
    public void click() {
        System.out.println("MacOS button clicked");
    }
}

// Windows文本框
class WindowsTextField implements TextField {
    @Override
    public void paint() {
        System.out.println("Render a text field in Windows style");
    }

    @Override
    public void input(String text) {
        System.out.println("Windows text field input: " + text);
    }
}

// MacOS文本框
class MacOSTextField implements TextField {
    @Override
    public void paint() {
        System.out.println("Render a text field in MacOS style");
    }

    @Override
    public void input(String text) {
        System.out.println("MacOS text field input: " + text);
    }
}

// GUI工厂接口
interface GUIFactory {
    Button createButton();
    TextField createTextField();
}

// Windows GUI工厂
class WindowsFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new WindowsButton();
    }

    @Override
    public TextField createTextField() {
        return new WindowsTextField();
    }
}

// MacOS GUI工厂
class MacOSFactory implements GUIFactory {
    @Override
    public Button createButton() {
        return new MacOSButton();
    }

    @Override
    public TextField createTextField() {
        return new MacOSTextField();
    }
}

// 客户端代码
class Application {
    private Button button;
    private TextField textField;

    public Application(GUIFactory factory) {
        button = factory.createButton();
        textField = factory.createTextField();
    }

    public void paint() {
        button.paint();
        textField.paint();
    }
}

// 使用示例
public class Demo {
    public static void main(String[] args) {
        // 创建Windows风格的UI
        Application windowsApp = new Application(new WindowsFactory());
        windowsApp.paint();

        // 创建MacOS风格的UI
        Application macApp = new Application(new MacOSFactory());
        macApp.paint();
    }
}
```

## 1.5 优点

1. 保证了同一产品族中产品的一致性
2. 将一个系列的产品族统一到一起创建
3. 将客户端与类的具体实现相分离
4. 符合开闭原则，易于扩展新的产品族

## 1.6 缺点

1. 难以支持新种类的产品（产品等级结构）
2. 产品族扩展非常困难
3. 增加了系统的抽象性和理解难度

## 1.7 适用场景

1. 需要创建一组相互关联的产品族时
2. 系统需要独立于产品的创建、组合和表示时
3. 系统要由多个产品系列中的一个来配置时

## 1.8 注意事项

1. 抽象工厂模式的使用需要事先规划好产品等级结构
2. 增加新的产品等级结构很困难，需要修改抽象工厂和所有的具体工厂类
3. 在实际应用中，可以结合其他模式（如单例、原型）来使用

