---
title: "分治算法 (Divide and Conquer)"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 分治算法 (Divide and Conquer)

## 1. 基本概念

### 1.1 定义

- 分治算法是一种将问题划分为多个子问题，递归求解子问题，再将子问题的解合并得到原问题的解的方法
- 其核心思想是"分而治之"：将大问题分解为小问题，各个击破
- 通常采用递归的方式实现

### 1.2 基本步骤

1. **分解 (Divide)**

   - 将原问题分解为若干个规模较小的子问题
   - 子问题相互独立且与原问题形式相同
   - 分解到可以直接求解的程度

2. **解决 (Conquer)**

   - 递归求解各个子问题
   - 若子问题足够小，则直接求解
   - 保持子问题的独立性

3. **合并 (Combine)**
   - 将子问题的解合并成原问题的解
   - 合并操作要高效
   - 处理好边界情况

## 2. 经典问题

### 2.1 归并排序

```java
public class MergeSort {
    public void mergeSort(int[] arr) {
        if (arr == null || arr.length <= 1) return;
        mergeSort(arr, 0, arr.length - 1);
    }

    private void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = left + (right - left) / 2;
            // 分解
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);
            // 合并
            merge(arr, left, mid, right);
        }
    }

    private void merge(int[] arr, int left, int mid, int right) {
        int[] temp = new int[right - left + 1];
        int i = left, j = mid + 1, k = 0;

        // 合并两个有序数组
        while (i <= mid && j <= right) {
            if (arr[i] <= arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
            }
        }

        // 处理剩余元素
        while (i <= mid) temp[k++] = arr[i++];
        while (j <= right) temp[k++] = arr[j++];

        // 复制回原数组
        for (i = 0; i < temp.length; i++) {
            arr[left + i] = temp[i];
        }
    }
}
```

### 2.2 快速排序

```java
public class QuickSort {
    public void quickSort(int[] arr) {
        if (arr == null || arr.length <= 1) return;
        quickSort(arr, 0, arr.length - 1);
    }

    private void quickSort(int[] arr, int left, int right) {
        if (left < right) {
            // 分区
            int pivot = partition(arr, left, right);
            // 递归排序左右两部分
            quickSort(arr, left, pivot - 1);
            quickSort(arr, pivot + 1, right);
        }
    }

    private int partition(int[] arr, int left, int right) {
        int pivot = arr[right];  // 选择最右元素作为基准
        int i = left - 1;  // 小于基准的元素的边界

        for (int j = left; j < right; j++) {
            if (arr[j] <= pivot) {
                i++;
                swap(arr, i, j);
            }
        }

        swap(arr, i + 1, right);
        return i + 1;
    }

    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 2.3 大整数乘法

```java
public class BigNumberMultiplication {
    public String multiply(String num1, String num2) {
        if (num1.equals("0") || num2.equals("0")) return "0";

        int[] result = new int[num1.length() + num2.length()];

        // 从右往左遍历
        for (int i = num1.length() - 1; i >= 0; i--) {
            for (int j = num2.length() - 1; j >= 0; j--) {
                int product = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');
                int sum = result[i + j + 1] + product;

                result[i + j + 1] = sum % 10;
                result[i + j] += sum / 10;
            }
        }

        // 构建结果字符串
        StringBuilder sb = new StringBuilder();
        int i = 0;
        while (i < result.length && result[i] == 0) i++;
        while (i < result.length) sb.append(result[i++]);

        return sb.length() == 0 ? "0" : sb.toString();
    }
}
```

## 3. 应用场景

### 3.1 排序算法

1. **归并排序**

   - 稳定排序
   - 外部排序
   - 并行计算

2. **快速排序**
   - 内部排序
   - 平均性能最优
   - 原地排序

### 3.2 搜索算法

1. **二分搜索**

   - 有序数组查找
   - 二分答案
   - 区间查找

2. **最近点对**
   - 计算几何
   - 空间划分
   - 距离计算

### 3.3 其他应用

1. **矩阵运算**

   - Strassen 算法
   - 矩阵乘法
   - 矩阵分块

2. **傅里叶变换**
   - FFT 算法
   - 信号处理
   - 多项式乘法

## 4. 性能分析

### 4.1 时间复杂度

1. **递归方程**

   - T(n) = aT(n/b) + f(n)
   - a：子问题个数
   - b：子问题规模缩小比例
   - f(n)：分解和合并时间

2. **常见复杂度**
   - 归并排序：O(nlogn)
   - 快速排序：O(nlogn)平均，O(n²)最坏
   - Strassen 算法：O(n^2.81)

### 4.2 空间复杂度

1. **递归栈空间**

   - 递归深度
   - 栈帧大小
   - 临时变量

2. **额外空间**
   - 合并操作所需空间
   - 临时数组
   - 缓存空间

## 5. 实现技巧

### 5.1 优化策略

1. **基准选择**

   - 随机选择
   - 三数取中
   - 九数取中

2. **小规模优化**
   - 插入排序替代
   - 阈值控制
   - 尾递归优化

### 5.2 注意事项

1. **递归控制**

   - 边界条件
   - 递归深度
   - 栈溢出处理

2. **数值稳定性**
   - 数值溢出
   - 精度控制
   - 舍入误差

## 6. 实际应用

### 6.1 工程实践

1. **系统应用**

   - 文件系统
   - 内存管理
   - 任务调度

2. **数据处理**
   - 大数据排序
   - 并行计算
   - 分布式系统

### 6.2 优化建议

1. **并行化**

   - 多线程处理
   - GPU 加速
   - 分布式计算

2. **内存管理**
   - 缓存优化
   - 内存池
   - 空间复用

