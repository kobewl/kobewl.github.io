---
title: "1 什么是 MySQL索引？"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 1 什么是 MySQL索引？

^40e189

MySQL索引是一种**数据结构**，用于提高数据库查询效率。它们类似于书籍的目录，可以帮助数据库快速找到所需的数据行。

**1. 索引的作用**
- **加快查询速度**：通过索引，数据库可以快速定位到所需的数据行，而不必扫描整个表。
- **提高排序和分组操作的性能**：索引可以加速ORDER BY和GROUP BY子句的执行。 ^5975af
- **唯一性约束**：某些类型的索引（如唯一索引）可以确保列中的数据唯一。

**2. 索引分类** ^140c3c

从数据结构角度来看，MySQL 索引可以分为以下几类：

- **B+树索引**
	- 最常用的索引类型，适用于大多数查询场景
	- 支持范围查询和排序操作
	- 树的高度通常在2-4层，查询效率高
	- 叶子节点相连，有利于范围查询

- **哈希索引**
	- 基于哈希表实现，只适用于等值查询（= 和 IN）
	- 不支持范围查询和排序操作
	- 查询复杂度为O(1)，等值查询性能极高
	- 主要用于MEMORY存储引擎

- **倒排索引（即全文索引 Full-Text）**
	- 用于全文搜索，适用于长文本字段
	- 支持复杂的文本搜索操作，如MATCH AGAINST
	- 将文档中的词项映射到包含该词项的文档

- **R-树索引（多维空间树）**
	- 用于地理空间数据类型，支持空间查询操作
	- 主要用于GIS（地理信息系统）应用
	- 适合处理多维空间数据的范围查询

从常见的基于 InnoDB B+ 树索引角度来看，可以分为：

- **聚簇索引（Clustered Index）**
	- 数据和索引存储在一起
	- 一个表只能有一个聚簇索引
	- 默认是主键索引

- **非聚簇索引（Non-clustered Index）**
	- 数据和索引分开存储
	- 一个表可以有多个非聚簇索引

从索引性质的角度来看，可以分为：

- **普通索引（二级索引、辅助索引）**
	- 最基本的索引类型，没有任何限制
	- 允许在相同列中插入重复值

- **主键索引**
	- 确保每一行数据的唯一性
	- 不允许有NULL值
	- 在InnoDB中会自动成为聚簇索引

- **联合索引**
	- 在多个列上创建的索引
	- 遵循最左前缀原则
	- 可以覆盖多个查询条件

**3. 创建索引**
可以在创建表时定义索引，也可以在表创建后添加索引。

**创建表时定义索引：**

``` SQL
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100),
    INDEX idx_username (username)
);
```

**表创建后添加索引：**
```SQL
ALTER TABLE users ADD INDEX idx_email (email);
```

**4. 索引的优缺点**
- **优点**：
	- 提高查询速度。
	- 加速排序和分组操作。
	- 确保数据的唯一性。
- **缺点**：
	- 占用额外的存储空间。
	- 插入、更新和删除操作的性能可能会降低，因为需要维护索引结构。
	- 过多的索引可能会导致写操作变慢，并增加数据库的维护成本。

**5. 索引的选择**

 - **选择性高的列**：选择性高的列（即不同值较多的列）更适合创建索引。
 - **频繁查询的列**：经常用于WHERE子句中的列应创建索引。
 - **外键列**：外键列通常需要创建索引以提高连接查询的性能。
 - **避免过度索引**：过多的索引会增加写操作的开销，并占用额外的存储空间。

**6. 不推荐使用索引的场景** ^d59388

以下情况下不建议使用索引，因为可能会导致性能下降或资源浪费：

- **数据量较小**：当表的数据量很小时（如少于1000行），全表扫描可能比使用索引更快。

- **区分度低的列**：
  - 如性别、状态等只有几个不同值的列
  - 当索引列的重复值超过表数据的20%时，索引的效果会大幅降低

- **频繁更新的列**：
  - 经常进行INSERT、UPDATE、DELETE操作的列
  - 索引维护成本高，可能影响写入性能

- **复合索引选择不当**：
  - 未遵循最左前缀原则
  - 索引列顺序与查询条件不匹配

- **大文本字段**：
  - TEXT、BLOB等大字段不适合建立普通索引
  - 可以考虑前缀索引或全文索引

- **需要在索引列上进行运算**：
  - WHERE子句中对索引列使用函数或运算
  - 会导致索引失效，转为全表扫描

# 2 MySQL中怎么查看SQL是否命中索引？

在MySQL中，可以通过以下几种方法查看SQL是否命中索引：

**方法一：使用** `EXPLAIN` **命令**

`EXPLAIN` 命令用于分析SQL查询的执行计划，并显示是否使用了索引。

**示例：**
```
EXPLAIN SELECT * FROM users WHERE username = 'john_doe';
```

**输出示例：**
```sql
id | select_type | table | partitions | type  | possible_keys | key         | key_len | ref  | rows | filtered | Extra
1  | SIMPLE      | users | NULL       | ref   | idx_username | idx_username | 20      | const| 1    | 100.00   | Using where
```

- **key** 列：显示实际使用的索引。如果此列为空，则表示没有使用索引。
- **type** 列：显示连接类型。常见的值有 `ALL`（全表扫描）、`index`（全索引扫描）、`range`（范围扫描）、`ref`（非唯一索引扫描）、`eq_ref`（唯一索引扫描）等。通常，`ALL` 和 `index` 表示没有有效利用索引。

**方法二：查看慢查询日志**

如果启用了慢查询日志，可以在慢查询日志中查看哪些查询没有使用索引。
**启用慢查询日志：**

```
SET GLOBAL slow_query_log = 'ON';
SET GLOBAL long_query_time = 2; -- 设置慢查询阈值为2秒
```

查看慢查询日志文件：  
慢查询日志文件的位置可以通过以下命令查看：

```sql
SHOW VARIABLES LIKE 'slow_query_log_file';
```

**方法三：使用** `SHOW PROFILE`

`SHOW PROFILE` 可以显示SQL执行的详细信息，包括是否使用了索引。

**启用性能分析：**

```
SET profiling = 'ON';
```

**执行SQL查询：**

```
SELECT * FROM users WHERE username = 'john_doe';
```

**查看性能分析结果：**

```
SHOW PROFILES;
```

**查看特定查询的详细信息：**

```
SHOW PROFILE FOR QUERY <query_id>;
```

**方法四：使用** `information_schema` **数据库**

`information_schema` 数据库包含有关数据库元数据的信息，可以通过查询相关表来查看索引的使用情况。

**示例：**

```sql
SELECT * FROM information_schema.STATISTICS WHERE TABLE_SCHEMA = 'your_database_name' AND TABLE_NAME = 'users';
```


# 3 什么是脏读、幻读、不可重复读？要怎么处理？

>这些问题都是MySQL进行事务并发过程中常见的问题。

1. 脏读： 在事务进行过程中，读到了其他事务未提交的数据。
2. 不可重复读：在事务进行过程中，多次查询的结果不一致。
3. 幻读：在同一个事务中，用同样的操作查询数据，得到的记录数不相同。

==处理的方式：==

1. 加锁：修改时加排他锁、读取时加共享锁，幻读加范围锁。
2. 事务隔离
3. MVCC[[MySQL MVCC]]

# 4 事务的基本特性和隔离级别有哪些？

==事务：==表示多个数据操作组成的一个完整的事务单元，这个事务内的所有数据操作要么同时成功，要么同时失败。

==事务特性：ACID==

1. **原子性**：事务是不可分割的最小单位，要么全部成功，要么全部失败。
2. **一致性**：事务无论是成功还是失败，都必须保持事务内的一致性。当失败时，要对所有的操作全部回滚。
3. **隔离性**：当多个事务操作同一个数据时，为了防止数据损坏，需要将每个事务进行隔离，互不干扰。
4. **持久性**：事务开始就不会终止。

==事务的隔离级别：==

 1. **NONE**
		*不使用事务。*
 2. **读未提交（Read Uncommitted）**
		*事务可以读取到还未提交的数据，允许脏读*
3. **读已提交（Read Committed）**
		*一个事务只能读取其他已提交事务的数据，可以避免脏读，但会出现不可重复读*
4. **可重复读（Repeatable Read）**
		*这是 MySQL 的默认隔离级别，在一个事务中多次读取同一数据，结果始终保持一致，即使其他事务对该数据进行了修改并提交，当前事务也不会看到这些修改（直到当前事务结束），会出现幻读。*
5. **串行化（Serializable）**
		*事务串行执行，完全避免了脏读、不可重复读和幻读*

>五种隔离级别，级别越高，事务的安全性越高，但是事务的性能越差。

# 5 请详细阐述 MySQL 中 MVCC 的实现原理，以及它是如何解决脏读、不可重复读和幻读问题的？

MVCC：多版本并发控制器，事务隔离级别无锁的实现方式，用于提高事务的并发性能。

**MVCC 的实现原理**：

1. **隐含字段**：InnoDB 会向数据库中的每行记录增加三个字段，分别是 DB_ROW_ID、DB_TRX_ID 和 DB_ROLL_PTR。其中 DB_TRX_ID 记录插入或最后一次更新这条记录的事务 ID；DB_ROLL_PTR 指向上个版本数据在 undo log 里的位置。
2. **undo log 日志**：事务进行插入操作时会产生 insert undo log，在事务回滚时需要，提交事务后可以被立即丢弃。进行 update、delete 操作时会产生 update undo log，不仅在回滚事务时需要，在快照读时也需要，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被 purge 线程统一清除。
3. **ReadView**：当隔离级别为 RR 时，每开启一个事务，数据库系统会给这个事务分配一个事务 ID，当这个事务执行 select 语句的时候，会生成一个当前时间点的事务快照读视图 ReadView。ReadView 包含几个属性，如创建当前 ReadView 时系统活跃事务 id 升序的列表 m_ids、不可见范围的最小（low）id m_low_limit_id、可见范围的最大（up）id m_up_limit_id、创建当前 ReadView 的事务 id m_creator_trx_id。

**MySQL InnoDB 中的 MVCC**

- InnoDB 存储引擎也支持 MVCC。
- 每条记录包含三个隐藏字段：
    - `DB_TRX_ID`：最近修改该记录的事务 ID。
    - `DB_ROLL_PTR`：指向回滚段中的旧版本数据。
    - `ROW_ID`：我们在没有维护主键id时，会维护一个ROW_ID的隐藏列
* MVCC将历史数据存储在undolog中。
- 事务通过 `Read View` 来决定可见性。

# 6 MySQL中的锁有哪些？什么是间隙锁？

==从锁的粒度区分：==
1. **行锁**：加锁粒度小，但是加锁资源开销比较大。InnoDB支持。
	1. **共享锁**：读锁，多个事务都可以对同一个数据共享同一把锁。持有锁的事务都可以访问数据，但是只能读，不能修改。
	2. **排他锁**：写锁，只有一个事务能够获得排他锁，其他事务不能获取该行的锁。InnoDB会对update/delete/insert语句自动添加排他锁。
	3. **自增锁**：通常是针对MySQL中的自增字段。如果有事务回滚的情况，数据会回滚，但是自增序列不会回滚。例如在高并发插入时，确保自增字段的唯一性和顺序性。

2. **表锁**：加锁粒度大，但是加锁资源开销比较小。MyISAM和InnoDB都支持。
	1. **表共享锁**：表共享锁允许多个事务同时读取表，但不能进行写操作。
	2. **表排他锁**：表排他锁允许一个事务对表进行写操作，其他事务不能读取或写入该表。
	3. **意向锁**：是InnoDB自动添加的锁，不需要用户干预。

3. **全局锁**：Flush tables with read lock。加锁之后整个数据库的实例处于只读状态，所有的数据变更操作都会被挂起，一般用于全库备份的时候。
 
==常见的锁算法：==
1. **记录锁**：锁一条具体的数据。
2. **间隙锁**：RR隔离级别下会加间隙锁。锁一定的范围，而不锁具体的记录。用于避免幻读现象。
3. **Next-Key**：间隙锁+右记录锁。Next-Key锁结合了记录锁和间隙锁，确保在RR隔离级别下的强一致性。

# 7 MySQL的索引结构是什么样的？聚簇索引和非聚簇索引又是什么？

>二叉树 ——> AVL树 ——> 红黑树 ——> B-树 ——> B+树

1. **二叉树**：每个节点最多有两个子节点，左边的子节点都比当前节点小，右边的子节点都比当前节点大。

2. **AVL树**：树中任意节点的两个子树的高度差最大为1。

3. **红黑树**：1.每个节点都是红色或黑色。2.根节点是黑色。3.每个叶子节点都是黑色的空姐点。4.红色节点的父子节点必须是黑色。5.从任意一个节点到其每一个叶子节点的所有路径都包含相同的黑色节点。

4. **B-树**：1.B-树的每个非叶子节点的子节点个数都不会超过D（B-树的阶）。2.所有的叶子节点都在同一层。3.所有的节点关键字都是按照递增顺序排列。

5. **B+树**：1.非叶子节点不存储数据，只进行数据索引。2.所有数据都存储在叶子节点中。3.每个叶子节点都存有相邻叶子节点的指针。4.叶子节点按照本身关键字从小到大排序。

==聚簇索引== ^09ace2

数据和索引是在一起的。

==非聚簇索引==

数据和索引是分开的。

MyISAM使用的是非聚簇索引，树的子节点上的data不是数据本身，而是数据存放的地址。InnoDB采用的是聚簇索引，树的子节点上的data就是数据本身。

聚簇索引的物理数据存放顺序和索引数据是一致的，所以一个表中只能有一个聚簇索引，而非聚簇索引可以有多个。

InnoDB中如果定义了PK，那PK就是聚簇索引。如果没有PK，就会找到第一个非空的unique列作为聚簇索引。否则，InnoDB会创建一个隐藏的row-id作为聚簇索引。

# 8 MySQL的覆盖索引和回表是什么？

如果只需要在一颗索引树上就可以获取SQL所需要的所有列，就不再需要回表查询，这样的查询速度就更快。

实现索引覆盖最简单的方式就是将要查询的字段，全部建立到联合索引中。

"回表" 是指在使用二级索引（非聚簇索引）作为条件进行查询时，由于二级索引中只存储了索引字段的值和对应的主键值，无法得到其它数据。如果要查询数据行中的其它数据，需要根据主键去聚簇索引查找实际的数据行，**这个过程被称为回表**。 ^12e445


# 9 MySQL 索引优化？

MySQL 索引优化是提升数据库查询性能的重要手段。以下是一些常见的索引优化方式：

### 9.1.1 选择合适的索引类型
- **B-Tree 索引**：适用于大多数查询场景，特别是范围查询和排序操作。
- **哈希索引**：适用于等值查询，但不支持范围查询和排序。
- **全文索引**：适用于文本搜索场景。

### 9.1.2 为什么MySQL选择B+树而不是B树作为索引结构？

#### 9.1.2.1 数据存储结构的差异
- **B树**：非叶子节点既存储键值，也存储数据。
- **B+树**：非叶子节点只存储键值，数据全部存储在叶子节点。

#### 9.1.2.2 查询性能的优势
1. **更少的IO次数**
   - B+树的非叶子节点不存储数据，因此同样大小的节点可以存储更多索引项
   - 树的高度更低，查询时IO次数更少

2. **范围查询更高效**
   - B+树所有数据都在叶子节点，且叶子节点通过链表相连
   - 范围查询只需要遍历叶子节点链表
   - B树需要中序遍历整棵树

#### 9.1.2.3 磁盘存储的优化
1. **更好的磁盘预读性能**
   - B+树的叶子节点相连，适合磁盘的顺序读取
   - 充分利用磁盘预读特性

2. **更高的空间利用率**
   - 非叶子节点不存储数据，可以存储更多索引项
   - 叶子节点紧凑存储，空间利用率更高

#### 9.1.2.4 示意图
```
B树结构：
     [key1 data1]
    /           \
[key2 data2]  [key3 data3]

B+树结构：
    [key1]
   /      \
[key2]   [key3]
   |        |
[data2] -> [data3] -> ...
```

### 9.1.3 创建合适的索引

### 9.1.4 创建合适的索引
- **单列索引**：在单个列上创建索引，适用于该列的频繁查询。
- **复合索引**：在多个列上创建索引，适用于多列组合查询。注意列的顺序，将选择性高的列放在前面。
- **覆盖索引**：索引包含了查询所需的所有数据，避免回表操作。

### 9.1.5 最左前缀原则
最左前缀原则是MySQL复合索引的重要使用原则，它决定了索引能否被正确使用。

#### 9.1.5.1 原理
- 复合索引在创建时会按照从左到右的顺序对各个字段进行索引。
- 查询时必须从索引的最左列开始匹配，否则无法使用索引。
- 如果跳过某个字段，索引将部分失效。

#### 9.1.5.2 示例
假设有一个复合索引：`idx_name_age_city(name, age, city)`

**能够使用索引的查询：**
```sql
-- 完全匹配
SELECT * FROM users WHERE name = 'Tom' AND age = 25 AND city = 'Beijing';
-- 最左前缀匹配
SELECT * FROM users WHERE name = 'Tom';
-- 最左前缀匹配（前两个字段）
SELECT * FROM users WHERE name = 'Tom' AND age = 25;
```

**无法完全使用索引的查询：**
```sql
-- 跳过name字段，索引失效
SELECT * FROM users WHERE age = 25 AND city = 'Beijing';
-- 跳过age字段，只能使用name列的索引
SELECT * FROM users WHERE name = 'Tom' AND city = 'Beijing';
```

#### 9.1.5.3 注意事项
1. **字段顺序很重要**：创建复合索引时，应该把最常用的列放在最左边。
2. **范围查询的限制**：如果某个字段使用了范围查询（如 >、<），则该字段右边的列都无法使用索引。
3. **优化建议**：
   - 将选择性高的列放在索引最左边
   - 避免创建冗余的索引
   - 考虑查询的实际需求来设计索引顺序

### 9.1.6 避免索引失效

^9a30e7

- **避免在索引列上进行函数操作**：如 `YEAR(date)`，会导致索引失效。
- **避免使用 `!=` 和 `<>`**：会导致全表扫描。
- **避免在索引列上进行计算**：如 `price * 2`，会导致索引失效。
- **避免在索引列上进行类型转换**：如 `CAST(id AS CHAR)`，会导致索引失效。
- **避免在索引列上进行子查询**：如 `WHERE id IN (SELECT id FROM another_table)`，会导致索引失效。

### 9.1.7 合理设置索引的可见性
- **VISIBLE**：默认设置，索引对查询可见。
- **INVISIBLE**：索引对查询不可见，适用于某些特定的优化场景。

### 9.1.8 使用索引提示
- **USE INDEX**：强制使用某个索引。
- **IGNORE INDEX**：忽略某个索引。
- **FORCE INDEX**：强制使用某个索引，忽略其他索引。

### 9.1.9 分析和优化查询
- **EXPLAIN**：使用 `EXPLAIN` 命令分析查询计划，找出潜在的性能瓶颈。
- **优化查询语句**：根据 `EXPLAIN` 的结果，优化查询语句和索引设计。

### 9.1.10 定期维护索引
- **重建索引**：定期重建索引，保持索引的高效性。
- **分析表**：使用 `ANALYZE TABLE` 命令更新表的统计信息，帮助优化器做出更好的决策。

### 9.1.11 监控和调优
- **慢查询日志**：启用慢查询日志，找出执行时间较长的查询，进行优化。
- **性能监控工具**：使用如 `pt-query-digest` 等工具分析慢查询日志，找出性能瓶颈。

### 9.1.12 示例
假设有一个 `users` 表，包含以下列：
```sql
CREATE TABLE users (
    id INT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(50),
    age INT
);
```

#### 9.1.12.1 创建单列索引
```sql
CREATE INDEX idx_username ON users(username);
```

#### 9.1.12.2 创建复合索引
```sql
CREATE INDEX idx_name_age ON users(username, age);
```

#### 9.1.12.3 使用索引提示
```sql
SELECT * FROM users USE INDEX (idx_username) WHERE username = 'john_doe';
```

#### 9.1.12.4 分析查询计划
```sql
EXPLAIN SELECT * FROM users WHERE username = 'john_doe';
```

### 9.1.13 总结
- **选择合适的索引类型**：根据查询需求选择合适的索引类型。
- **创建合适的索引**：合理设计单列索引和复合索引。
- **避免索引失效**：注意避免常见的索引失效情况。
- **分析和优化查询**：使用 `EXPLAIN` 分析查询计划，优化查询语句。
- **定期维护索引**：定期重建索引和分析表。
- **监控和调优**：启用慢查询日志，使用性能监控工具进行分析。

# 10 MySQL 索引什么情况下会失效？

^dc486d

MySQL 索引在某些情况下会失效，导致查询性能下降。以下是一些常见的索引失效场景：

### 10.1.1 使用函数或表达式
当在索引列上使用函数或表达式时，索引会失效。例如：
```sql
SELECT * FROM users WHERE YEAR(birth_date) = 2000; -- 失效
```

### 10.1.2 使用 `!=` 或 `<>` 操作符
当使用 `!=` 或 `<>` 操作符时，索引会失效。例如：
```sql
SELECT * FROM users WHERE age != 30; -- 失效
```

### 10.1.3 使用 `LIKE` 通配符在前
当使用 `LIKE` 进行模糊匹配且通配符在前时，索引会失效。例如：
```sql
SELECT * FROM users WHERE username LIKE '%john%'; -- 失效
```
但如果通配符在后，则索引有效：
```sql
SELECT * FROM users WHERE username LIKE 'john%'; -- 有效
```

### 10.1.4 数据类型不匹配
当查询条件中的数据类型与索引列的数据类型不匹配时，索引会失效。例如：
```sql
SELECT * FROM users WHERE id = '123'; -- 失效（id 是 INT 类型）
```

### 10.1.5 使用 `OR` 连接多个条件
当使用 `OR` 连接多个条件且每个条件涉及的列没有共同的索引时，索引会失效。例如：
```sql
SELECT * FROM users WHERE age = 30 OR username = 'john'; -- 失效
```
可以通过创建复合索引来优化：
```sql
CREATE INDEX idx_age_username ON users(age, username);
```

### 10.1.6 使用子查询
当在索引列上使用子查询时，索引会失效。例如：
```sql
SELECT * FROM users WHERE id IN (SELECT id FROM another_table); -- 失效
```

### 10.1.7 使用 `NOT IN` 或 `NOT EXISTS`
当使用 `NOT IN` 或 `NOT EXISTS` 时，索引可能会失效。例如：
```sql
SELECT * FROM users WHERE id NOT IN (1, 2, 3); -- 失效
```

### 10.1.8 使用 `HAVING` 子句
当在 `HAVING` 子句中使用聚合函数时，索引可能会失效。例如：
```sql
SELECT age, COUNT(*) FROM users GROUP BY age HAVING COUNT(*) > 10; -- 失效
```

### 10.1.9 使用 `ORDER BY` 和 `GROUP BY` 的列没有索引
当 `ORDER BY` 或 `GROUP BY` 的列没有索引时，索引会失效。例如：
```sql
SELECT * FROM users ORDER BY age; -- 失效（如果没有 age 的索引）
```

### 10.1.10 使用 `FORCE INDEX` 或 `IGNORE INDEX`
当显式使用 `FORCE INDEX` 或 `IGNORE INDEX` 时，可能会导致索引失效。例如：
```sql
SELECT * FROM users FORCE INDEX (idx_age) WHERE username = 'john'; -- 失效（idx_age 不包含 username 列）
```

### 10.1.11 总结
- **函数或表达式**：避免在索引列上使用函数或表达式。
- **操作符**：避免使用 `!=` 或 `<>`。
- **模糊匹配**：避免 `LIKE` 通配符在前。
- **数据类型**：确保查询条件中的数据类型与索引列的数据类型匹配。
- **OR 条件**：尽量使用复合索引。
- **子查询**：避免在索引列上使用子查询。
- **NOT IN/NOT EXISTS**：尽量避免使用 `NOT IN` 或 `NOT EXISTS`。
- **HAVING 子句**：避免在 `HAVING` 子句中使用聚合函数。
- **ORDER BY/GROUP BY**：确保 `ORDER BY` 或 `GROUP BY` 的列有索引。
- **显式索引提示**：谨慎使用 `FORCE INDEX` 或 `IGNORE INDEX`。


# 11 什么是覆盖索引？

覆盖索引是指查询的数据列恰好是索引的一部分，这样可以直接从索引中获取数据，而无需回表查询。

**1. 覆盖索引的原理**
- 普通的二级索引包含索引列和主键值
- 当查询的列都包含在索引中时，可以直接从索引获取数据
- 避免了回表操作，提高查询效率

**2. 使用场景**
- 频繁查询的列可以建立覆盖索引
- 适合用于查询结果集较小的场景
- 常用于统计和分析查询

**3. 示例**
```sql
-- 创建覆盖索引
CREATE INDEX idx_name_age ON users(name, age);

-- 可以使用覆盖索引的查询
SELECT name, age FROM users WHERE name = 'John';

-- 需要回表的查询（不是覆盖索引）
SELECT name, age, address FROM users WHERE name = 'John';
```

**4. 验证覆盖索引**
```sql
EXPLAIN SELECT name, age FROM users WHERE name = 'John';
```
在 EXPLAIN 的结果中，Extra 列显示 "Using index" 表示使用了覆盖索引。

**5. 优点**
- 减少 I/O 操作
- 避免回表查询
- 提高查询性能

**6. 注意事项**
- 合理设计索引列，避免冗余
- 平衡索引大小和性能
- 定期维护和优化索引

# 12 MySQL如何进行分库分表？多大的数据量需要进行分库分表？分库分表的方式和分片策略由哪些？分库分表后，SQL 语句的执行流程是怎样的？

==什么是分库分表==

当表中的数据量过大时，整个查询效率就会降低得非常明显。这时为了提升查询效率，就要将一个表 中的数据分散到多个数据库的多个表当中。

分库分表包含分库和分表两个部分,而这两个部分可以统称为数据分片，是将数据拆分成不同的存储单元。另外,从分拆的角度上,1可以分为垂直分片和水平分片。

**垂直分片**：按照业务来对数据进行分片,又称为纵向分片。他的核理念就是专库专用。在拆分之前,一个数据库由多个数据表组成,每个表对应不同的业务。而拆分之后,则是按照业务将表进行归类,分布到不同的数据库或表中,从而将压力分散至不同的数据库或表。

**水平分片**：从数据库的角度将一个表中的数据拆分到不同的库或表中，这样可以从根本上解决数据量过大造成的查询效率低的问题。

常用的分片策略有:
取余 \ 取模：优点均匀存放数据，缺点扩容非常麻烦
按照范围分片：比较好扩容，数据分布不够均匀
接照时间分片：比较容易将热点数据区分出来。
按照枚举值分片：例如按地区分片
按照目标字段前缀指定进行分区：自定义业务规则分片
水平分片从理论上突破了单机数据量处理的瓶颈，并且扩展相对自由，是分库分表的标准解决方案。

阿里云提供的开发手册中，建议：一个表的数据量超过500W或者数据文件超过2G，就可以考虑分库分表。


# 13 MySQL为什么选用B+树，而不是B-？





