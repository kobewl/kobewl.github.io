---
title: "1 二分查找法 (Binary Search)"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 1 二分查找法 (Binary Search)

## 1.1 基本概念

二分查找法是一种高效的**查找算法**，适用于已排序的数组或其他支持随机访问的数据结构。这种方法可以极大地减少查找所需的比较次数，从而快速定位目标元素。

**关键提醒：**  
在使用二分查找前，必须确保数据已经按**升序**或**降序**排序，否则算法将无法正确工作。

- **定义：**  
  二分查找 (Binary Search) 利用"不断折半"的思想，将查找区间逐步缩小，直到找到目标值或确定该元素不存在。
- **前提条件：**  
  待查找的数组或序列必须是**有序**的。只有在数据有序的情况下，通过中间值的比较才能有效地缩小查找范围。
- **时间复杂度：**  
  每次查找都将区间分成两半，因此整体时间复杂度为 **O(log n)**，远优于顺序查找的 O(n)。

## 1.2 算法原理

二分查找法主要通过以下几个步骤来逐步缩小查找区间：

1. **初始化边界：**  
   定义左右边界：

   - `left = 0` —— 数组的起始索引
   - `right = arr.length - 1` —— 数组的末尾索引

2. **计算中间位置：**  
   计算中间索引：

   - `mid = left + (right - left) / 2`  
     这里采用这种方式避免使用 `(left + right) / 2` 可能会导致的整数溢出问题。

3. **比较中间值：**

   - 如果 `arr[mid]` 等于目标值 `target`，则查找成功，返回 `mid`；
   - 如果 `arr[mid] < target`，则目标值必在右半部分，更新左边界为 `left = mid + 1`；
   - 如果 `arr[mid] > target`，则目标值必在左半部分，更新右边界为 `right = mid - 1`。

4. **重复查找：**  
   重复步骤 2 和 3，直到 `left` 超过 `right`。此时如果仍未找到目标，说明数组中不存在该值，返回 -1。

**示例说明：**  
给定一个升序数组 `[2, 4, 6, 8, 10, 12]`，若我们的目标值为 `8`，则执行过程如下：

- 初始：`left = 0`，`right = 5`；
- 第一次计算：`mid = 0 + (5-0)/2 = 2`，此时 `arr[2]` 为 `6`，因为 `6 < 8`，更新 `left = 3`；
- 第二次计算：`mid = 3 + (5-3)/2 = 4`，此时 `arr[4]` 为 `10`，因为 `10 > 8`，更新 `right = 3`；
- 第三次计算：`mid = 3 + (3-3)/2 = 3`，此时 `arr[3]` 为 `8`，与目标值匹配，返回索引 `3`。

## 1.3 Java 实现示例

下面提供了两种实现方式：迭代版本和递归版本。代码中加入了详细注释，便于新手理解每一步的运算过程。

### 1.3.1 迭代版本 (Iterative Version)

```java
/**
 * 二分查找的迭代实现
 */
public class BinarySearchIterative {
    /**
     * 在一个已排序的整型数组中查找目标值
     *
     * @param arr    已排序的整型数组（必须保证数组已经按升序或降序排列）
     * @param target 要查找的目标值
     * @return 返回目标值在数组中的索引，如果目标值不存在则返回 -1
     */
    public int binarySearch(int[] arr, int target) {
        // 定义左右边界，初始时区间为整个数组
        int left = 0;
        int right = arr.length - 1;

        // 在区间[left, right]不为空的情况下进行循环
        while (left <= right) {
            // 计算中间索引，防止(left + right)直接求和可能引起的溢出
            int mid = left + (right - left) / 2;

            // 可选：打印调试信息，便于观察每一步的变化
            // System.out.println("left: " + left + ", right: " + right + ", mid: " + mid + ", arr[mid]: " + arr[mid]);

            // 如果中间元素正好等于目标值，则查找成功，直接返回中间索引
            if (arr[mid] == target) {
                return mid;
            }
            // 如果中间元素小于目标值，目标值必在右侧区间
            else if (arr[mid] < target) {
                // 更新左边界，使查找区间缩小为右半部分
                left = mid + 1;
            }
            // 如果中间元素大于目标值，目标值必在左侧区间
            else {
                // 更新右边界，使查找区间缩小为左半部分
                right = mid - 1;
            }
        }

        // 如果循环结束仍未找到目标，则返回 -1，表示目标在数组中不存在
        return -1;
    }
}
```

### 1.3.2 递归版本 (Recursive Version)

```java
/**
 * 二分查找的递归实现
 */
public class BinarySearchRecursive {
    /**
     * 在已排序数组中递归查找目标值
     *
     * @param arr    已排序的整型数组
     * @param target 要查找的目标值
     * @return 返回目标值在数组中的索引，如果目标值不存在则返回 -1
     */
    public int binarySearch(int[] arr, int target) {
        // 调用辅助方法，初始查找区间为整个数组 [0, arr.length - 1]
        return binarySearchHelper(arr, target, 0, arr.length - 1);
    }

    /**
     * 递归二分查找的辅助方法
     *
     * @param arr    数组
     * @param target 目标值
     * @param left   当前查找区间的左边界
     * @param right  当前查找区间的右边界
     * @return 返回目标值在数组中的索引，如果目标值不存在则返回 -1
     */
    private int binarySearchHelper(int[] arr, int target, int left, int right) {
        // 递归终止条件：查找区间为空，则说明数组中不存在目标值
        if (left > right) {
            return -1;
        }

        // 计算中间索引，注意使用安全的计算方式
        int mid = left + (right - left) / 2;

        // 如果中间元素正好等于目标值，返回中间索引
        if (arr[mid] == target) {
            return mid;
        }
        // 如果中间元素小于目标值，递归查找右半部分
        else if (arr[mid] < target) {
            return binarySearchHelper(arr, target, mid + 1, right);
        }
        // 如果中间元素大于目标值，递归查找左半部分
        else {
            return binarySearchHelper(arr, target, left, mid - 1);
        }
    }
}
```

## 1.4 分析与注意事项

- **时间复杂度：**  
  由于每次比较后查找区间都减少一半，因此时间复杂度为 **O(log n)**。

- **空间复杂度：**

  - **迭代版本：** 只使用了常量级的额外空间，空间复杂度为 **O(1)**。
  - **递归版本：** 递归调用会在调用栈中占用空间，最坏时空间复杂度为 **O(log n)**（与递归深度成正比）。

- **注意事项：**

  1. **数据排序：**  
     在使用二分查找之前，一定要确保数据是**有序**的，否则即使代码正确，也可能找不到目标值。

  2. **中点计算：**  
     为防止 `left + right` 计算时溢出，建议使用 `left + (right - left) / 2`。

  3. **边界条件：**  
     更新左右边界时要特别小心，确保不跳过可能包含目标值的元素。在查找过程中，当 `left > right` 时，就说明目标值不在数组中。

  4. **重复元素：**  
     若数组中存在重复元素，二分查找可能返回遇到的第一个匹配项的索引。如果需要找出所有重复项，则需要额外遍历该匹配点两侧的相邻元素。

## 1.5 应用场景

二分查找法具有很广泛的应用场景，包括但不限于：

- **快速定位：**  
  在一个大规模有序数据集中快速查找某个特定元素（如查找电话号码、记录等）。
- **确定插入位置：**  
  当需要在保持顺序的同时插入新元素时，可以利用二分查找确定新元素的正确位置。
- **参数优化搜索（Parametric Search）：**  
  在一些算法问题中，利用二分查找在一个参数范围内寻找满足条件的最优解。

## 1.6 二分查找的变体与细节

在实际应用中，二分查找有多种变体，主要体现在以下几个方面：

### 1.6.1 mid 的计算方式

mid 的计算有两种常见方式：

1. **向下取整（常用）**：

```java
int mid = left + (right - left) / 2;
```

- 最常用的计算方式
- 当 left = 0, right = 1 时，mid = 0

2. **向上取整**：

```java
int mid = left + (right - left + 1) / 2;
```

- 在特定场景使用，如查找最后一个满足条件的元素
- 当 left = 0, right = 1 时，mid = 1

### 1.6.2 边界条件的选择

根据不同的查找需求，我们需要选择不同的边界处理方式：

1. **查找第一个满足条件的位置**：

```java
public int findFirst(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;  // 注意这里不是 mid-1
        }
    }
    return nums[left] == target ? left : -1;
}
```

2. **查找最后一个满足条件的位置**：

```java
public int findLast(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left < right) {
        // 注意这里使用向上取整
        int mid = left + (right - left + 1) / 2;
        if (nums[mid] <= target) {
            left = mid;  // 注意这里不是 mid+1
        } else {
            right = mid - 1;
        }
    }
    return nums[left] == target ? left : -1;
}
```

### 1.6.3 重要注意事项

1. **循环条件的选择**

   - `while (left <= right)`：用于标准二分查找
   - `while (left < right)`：用于查找边界值

2. **边界更新规则**

   - 查找第一个位置时：`right = mid`
   - 查找最后一个位置时：`left = mid`
   - 标准二分查找：`left = mid + 1` 或 `right = mid - 1`

3. **死循环预防**

   - 使用 `left < right` 时，确保能够正确更新边界
   - 在查找最后一个位置时使用向上取整的 mid 计算方式

4. **返回值处理**
   - 标准二分查找：找到返回 index，未找到返回 -1
   - 边界查找：需要额外验证返回值是否满足条件

### 1.6.4 实际应用示例

1. **查找插入位置**：

```java
public int searchInsert(int[] nums, int target) {
    int left = 0, right = nums.length;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return left;
}
```

2. **查找重复元素的范围**：

```java
public int[] searchRange(int[] nums, int target) {
    int first = findFirst(nums, target);
    int last = findLast(nums, target);
    return new int[]{first, last};
}

// 查找第一个位置
private int findFirst(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return nums[left] == target ? left : -1;
}

// 查找最后一个位置
private int findLast(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left < right) {
        int mid = left + (right - left + 1) / 2;
        if (nums[mid] <= target) {
            left = mid;
        } else {
            right = mid - 1;
        }
    }
    return nums[left] == target ? left : -1;
}
```

这些变体和细节的掌握对于解决实际问题至关重要。在实践中，我们需要根据具体问题选择合适的实现方式。

