---
title: "排序算法 (Sorting Algorithms)"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 排序算法 (Sorting Algorithms)

## 1. 基础排序算法

### 1.1 冒泡排序 (Bubble Sort)

```java
public class BubbleSort {
    public void sort(int[] arr) {
        int n = arr.length;
        // 外层循环控制排序轮数
        for (int i = 0; i < n - 1; i++) {
            // 内层循环进行相邻元素比较和交换
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    // 交换元素
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
}
```

**优化版本**：

```java
public void optimizedBubbleSort(int[] arr) {
    int n = arr.length;
    boolean swapped;
    for (int i = 0; i < n - 1; i++) {
        swapped = false;
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = true;
            }
        }
        // 如果没有发生交换，说明数组已经有序
        if (!swapped) break;
    }
}
```

### 1.2 选择排序 (Selection Sort)

```java
public class SelectionSort {
    public void sort(int[] arr) {
        int n = arr.length;
        // 外层循环控制已排序区间
        for (int i = 0; i < n - 1; i++) {
            int minIdx = i;
            // 在未排序区间找最小值
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIdx]) {
                    minIdx = j;
                }
            }
            // 将最小值放到已排序区间末尾
            int temp = arr[minIdx];
            arr[minIdx] = arr[i];
            arr[i] = temp;
        }
    }
}
```

### 1.3 插入排序 (Insertion Sort)

```java
public class InsertionSort {
    public void sort(int[] arr) {
        int n = arr.length;
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            int j = i - 1;
            // 将大于 key 的元素都向后移动
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j--;
            }
            arr[j + 1] = key;
        }
    }
}
```

## 2. 高级排序算法

### 2.1 快速排序 (Quick Sort)

```java
public class QuickSort {
    public void sort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            sort(arr, low, pi - 1);
            sort(arr, pi + 1, high);
        }
    }

    private int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;

        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }

        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;

        return i + 1;
    }
}
```

### 2.2 归并排序 (Merge Sort)

```java
public class MergeSort {
    public void sort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = (left + right) / 2;
            sort(arr, left, mid);
            sort(arr, mid + 1, right);
            merge(arr, left, mid, right);
        }
    }

    private void merge(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;

        int[] L = new int[n1];
        int[] R = new int[n2];

        for (int i = 0; i < n1; i++)
            L[i] = arr[left + i];
        for (int j = 0; j < n2; j++)
            R[j] = arr[mid + 1 + j];

        int i = 0, j = 0, k = left;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }

        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }

        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }
}
```

### 2.3 堆排序 (Heap Sort)

```java
public class HeapSort {
    public void sort(int[] arr) {
        int n = arr.length;

        // 构建最大堆
        for (int i = n / 2 - 1; i >= 0; i--)
            heapify(arr, n, i);

        // 逐个从堆中取出最大值
        for (int i = n - 1; i > 0; i--) {
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;

            heapify(arr, i, 0);
        }
    }

    private void heapify(int[] arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;

        if (left < n && arr[left] > arr[largest])
            largest = left;

        if (right < n && arr[right] > arr[largest])
            largest = right;

        if (largest != i) {
            int swap = arr[i];
            arr[i] = arr[largest];
            arr[largest] = swap;

            heapify(arr, n, largest);
        }
    }
}
```

## 3. 特殊排序算法

### 3.1 计数排序 (Counting Sort)

```java
public class CountingSort {
    public void sort(int[] arr) {
        int max = Arrays.stream(arr).max().getAsInt();
        int min = Arrays.stream(arr).min().getAsInt();
        int range = max - min + 1;

        int[] count = new int[range];
        int[] output = new int[arr.length];

        for (int value : arr)
            count[value - min]++;

        for (int i = 1; i < count.length; i++)
            count[i] += count[i - 1];

        for (int i = arr.length - 1; i >= 0; i--) {
            output[count[arr[i] - min] - 1] = arr[i];
            count[arr[i] - min]--;
        }

        System.arraycopy(output, 0, arr, 0, arr.length);
    }
}
```

### 3.2 基数排序 (Radix Sort)

```java
public class RadixSort {
    public void sort(int[] arr) {
        int max = Arrays.stream(arr).max().getAsInt();

        for (int exp = 1; max / exp > 0; exp *= 10)
            countSort(arr, exp);
    }

    private void countSort(int[] arr, int exp) {
        int[] output = new int[arr.length];
        int[] count = new int[10];

        for (int value : arr)
            count[(value / exp) % 10]++;

        for (int i = 1; i < 10; i++)
            count[i] += count[i - 1];

        for (int i = arr.length - 1; i >= 0; i--) {
            output[count[(arr[i] / exp) % 10] - 1] = arr[i];
            count[(arr[i] / exp) % 10]--;
        }

        System.arraycopy(output, 0, arr, 0, arr.length);
    }
}
```

## 4. 性能分析

### 4.1 时间复杂度

| 算法     | 最好情况  | 平均情况  | 最坏情况  | 空间复杂度 | 稳定性 |
| -------- | --------- | --------- | --------- | ---------- | ------ |
| 冒泡排序 | O(n)      | O(n²)     | O(n²)     | O(1)       | 稳定   |
| 选择排序 | O(n²)     | O(n²)     | O(n²)     | O(1)       | 不稳定 |
| 插入排序 | O(n)      | O(n²)     | O(n²)     | O(1)       | 稳定   |
| 快速排序 | O(nlogn)  | O(nlogn)  | O(n²)     | O(logn)    | 不稳定 |
| 归并排序 | O(nlogn)  | O(nlogn)  | O(nlogn)  | O(n)       | 稳定   |
| 堆排序   | O(nlogn)  | O(nlogn)  | O(nlogn)  | O(1)       | 不稳定 |
| 计数排序 | O(n+k)    | O(n+k)    | O(n+k)    | O(k)       | 稳定   |
| 基数排序 | O(d(n+k)) | O(d(n+k)) | O(d(n+k)) | O(n+k)     | 稳定   |

### 4.2 空间使用

1. **原地排序**

   - 冒泡排序
   - 选择排序
   - 插入排序
   - 堆排序

2. **需要额外空间**
   - 归并排序：O(n)
   - 计数排序：O(k)
   - 基数排序：O(n+k)

## 5. 应用场景

### 5.1 场景选择

1. **小规模数据**

   - 插入排序
   - 选择排序
   - 冒泡排序

2. **大规模数据**

   - 快速排序
   - 归并排序
   - 堆排序

3. **特殊场景**
   - 计数排序：数据范围有限
   - 基数排序：整数或字符串
   - 桶排序：均匀分布数据

### 5.2 实际应用

1. **系统应用**

   - 文件排序
   - 任务调度
   - 数据库索引

2. **业务应用**
   - 成绩排名
   - 商品排序
   - 日志排序

## 6. 优化策略

### 6.1 通用优化

1. **预处理**

   - 数据规模判断
   - 数据特征分析
   - 预排序检查

2. **混合策略**
   - 快排 + 插入排序
   - 归并 + 插入排序
   - 多路归并

### 6.2 特定优化

1. **快速排序优化**

   - 三数取中
   - 双路快排
   - 三路快排

2. **归并排序优化**
   - 原地归并
   - 多路归并
   - 并行归并

