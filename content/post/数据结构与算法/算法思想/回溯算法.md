---
title: "回溯算法 (Backtracking)"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 回溯算法 (Backtracking)

## 1. 基本概念

### 1.1 定义

- 回溯算法是一种通过探索所有可能的候选解来找出所有解的算法
- 如果候选解被确认不是解，就回溯到上一步继续尝试其他可能
- 本质是一种试错的思想，通过系统地尝试所有可能找到解

### 1.2 基本要素

1. **选择列表**

   - 当前可以做的选择
   - 随着路径变化而变化
   - 构成决策树的分支

2. **路径**

   - 已经做出的选择
   - 构成当前解的部分内容
   - 需要能够回退

3. **结束条件**
   - 找到一个完整的解
   - 达到约束条件的边界
   - 无法继续选择

## 2. 常见问题类型

### 2.1 组合问题

```java
// 组合问题模板
public class Combinations {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> results = new ArrayList<>();
        backtrack(results, new ArrayList<>(), 1, n, k);
        return results;
    }

    private void backtrack(List<List<Integer>> results, List<Integer> current,
                          int start, int n, int k) {
        // 找到一个组合
        if (current.size() == k) {
            results.add(new ArrayList<>(current));
            return;
        }

        // 尝试可能的选择
        for (int i = start; i <= n; i++) {
            // 做选择
            current.add(i);
            // 递归
            backtrack(results, current, i + 1, n, k);
            // 撤销选择
            current.remove(current.size() - 1);
        }
    }
}
```

### 2.2 排列问题

```java
// 排列问题模板
public class Permutations {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> results = new ArrayList<>();
        backtrack(results, new ArrayList<>(), nums, new boolean[nums.length]);
        return results;
    }

    private void backtrack(List<List<Integer>> results, List<Integer> current,
                          int[] nums, boolean[] used) {
        // 找到一个排列
        if (current.size() == nums.length) {
            results.add(new ArrayList<>(current));
            return;
        }

        // 尝试所有可能的数字
        for (int i = 0; i < nums.length; i++) {
            if (used[i]) continue;

            // 做选择
            used[i] = true;
            current.add(nums[i]);
            // 递归
            backtrack(results, current, nums, used);
            // 撤销选择
            current.remove(current.size() - 1);
            used[i] = false;
        }
    }
}
```

### 2.3 子集问题

```java
// 子集问题模板
public class Subsets {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> results = new ArrayList<>();
        backtrack(results, new ArrayList<>(), nums, 0);
        return results;
    }

    private void backtrack(List<List<Integer>> results, List<Integer> current,
                          int[] nums, int start) {
        // 每个路径都是一个子集
        results.add(new ArrayList<>(current));

        // 尝试添加新的数字
        for (int i = start; i < nums.length; i++) {
            // 做选择
            current.add(nums[i]);
            // 递归
            backtrack(results, current, nums, i + 1);
            // 撤销选择
            current.remove(current.size() - 1);
        }
    }
}
```

### 2.4 约束满足问题

```java
// N皇后问题
public class NQueens {
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> results = new ArrayList<>();
        char[][] board = new char[n][n];
        for (char[] row : board) {
            Arrays.fill(row, '.');
        }

        backtrack(results, board, 0);
        return results;
    }

    private void backtrack(List<List<String>> results, char[][] board, int row) {
        if (row == board.length) {
            results.add(constructSolution(board));
            return;
        }

        for (int col = 0; col < board.length; col++) {
            if (isValid(board, row, col)) {
                // 做选择
                board[row][col] = 'Q';
                // 递归
                backtrack(results, board, row + 1);
                // 撤销选择
                board[row][col] = '.';
            }
        }
    }

    private boolean isValid(char[][] board, int row, int col) {
        // 检查列
        for (int i = 0; i < row; i++) {
            if (board[i][col] == 'Q') return false;
        }

        // 检查左上对角线
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] == 'Q') return false;
        }

        // 检查右上对角线
        for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {
            if (board[i][j] == 'Q') return false;
        }

        return true;
    }

    private List<String> constructSolution(char[][] board) {
        List<String> solution = new ArrayList<>();
        for (char[] row : board) {
            solution.add(new String(row));
        }
        return solution;
    }
}
```

## 3. 解题模板

### 3.1 基本框架

```java
void backtrack(路径, 选择列表) {
    if (满足结束条件) {
        保存结果;
        return;
    }

    for (选择 : 选择列表) {
        做选择;
        backtrack(路径, 选择列表);
        撤销选择;
    }
}
```

### 3.2 优化策略

1. **剪枝**

   - 提前判断无效分支
   - 约束条件过滤
   - 重复状态去除

2. **状态记录**
   - 使用合适的数据结构
   - 高效的状态转移
   - 避免重复计算

## 4. 实战技巧

### 4.1 效率提升

1. **剪枝优化**

   - 可行性剪枝
   - 最优性剪枝
   - 重复性剪枝

2. **状态设计**
   - 状态压缩
   - 位运算优化
   - 哈希优化

### 4.2 代码优化

1. **代码结构**

   - 清晰的变量命名
   - 模块化设计
   - 复用通用逻辑

2. **边界处理**
   - 特殊情况检查
   - 输入验证
   - 异常处理

## 5. 实际应用

### 5.1 应用场景

1. **搜索问题**

   - 路径搜索
   - 迷宫问题
   - 图的遍历

2. **优化问题**

   - 资源分配
   - 任务调度
   - 装载问题

3. **游戏问题**
   - 数独游戏
   - 棋类游戏
   - 益智游戏

### 5.2 注意事项

1. **性能考虑**

   - 时间复杂度
   - 空间复杂度
   - 栈深度限制

2. **实现细节**
   - 状态恢复
   - 递归终止
   - 结果收集

