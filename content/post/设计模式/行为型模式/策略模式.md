---
title: "策略模式（Strategy Pattern）"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 策略模式（Strategy Pattern）

## 概述

策略模式是一种行为型设计模式，它定义了一系列算法，并将每个算法封装起来，使它们可以相互替换。策略模式让算法独立于使用它的客户端而变化，客户端可以在运行时选择不同的策略。

## 使用场景

- 需要在运行时根据需要切换不同的算法时
- 有一组类似的算法，只是具体实现不同时
- 需要屏蔽算法实现的复杂性时
- 需要避免使用多重条件语句时

## 基本实现

```java
// 策略接口
interface Strategy {
    void execute();
}

// 具体策略A
class ConcreteStrategyA implements Strategy {
    @Override
    public void execute() {
        System.out.println("执行策略A");
    }
}

// 具体策略B
class ConcreteStrategyB implements Strategy {
    @Override
    public void execute() {
        System.out.println("执行策略B");
    }
}

// 上下文类
class Context {
    private Strategy strategy;

    public Context(Strategy strategy) {
        this.strategy = strategy;
    }

    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }

    public void executeStrategy() {
        strategy.execute();
    }
}
```

## 实际应用示例

以支付系统为例：

```java
// 支付策略接口
interface PaymentStrategy {
    void pay(double amount);
}

// 信用卡支付
class CreditCardPayment implements PaymentStrategy {
    private String cardNumber;
    private String name;
    private String cvv;
    private String dateOfExpiry;

    public CreditCardPayment(String cardNumber, String name, String cvv, String dateOfExpiry) {
        this.cardNumber = cardNumber;
        this.name = name;
        this.cvv = cvv;
        this.dateOfExpiry = dateOfExpiry;
    }

    @Override
    public void pay(double amount) {
        System.out.println("使用信用卡支付: " + amount + "元");
        System.out.println("卡号: " + cardNumber);
    }
}

// 支付宝支付
class AlipayPayment implements PaymentStrategy {
    private String email;
    private String password;

    public AlipayPayment(String email, String password) {
        this.email = email;
        this.password = password;
    }

    @Override
    public void pay(double amount) {
        System.out.println("使用支付宝支付: " + amount + "元");
        System.out.println("账号: " + email);
    }
}

// 微信支付
class WeChatPayment implements PaymentStrategy {
    private String id;

    public WeChatPayment(String id) {
        this.id = id;
    }

    @Override
    public void pay(double amount) {
        System.out.println("使用微信支付: " + amount + "元");
        System.out.println("微信ID: " + id);
    }
}

// 购物车类
class ShoppingCart {
    private List<Item> items;
    private PaymentStrategy paymentStrategy;

    public ShoppingCart() {
        this.items = new ArrayList<>();
    }

    public void addItem(Item item) {
        items.add(item);
    }

    public void removeItem(Item item) {
        items.remove(item);
    }

    public double calculateTotal() {
        return items.stream().mapToDouble(Item::getPrice).sum();
    }

    public void setPaymentStrategy(PaymentStrategy paymentStrategy) {
        this.paymentStrategy = paymentStrategy;
    }

    public void checkout() {
        double total = calculateTotal();
        paymentStrategy.pay(total);
    }
}

// 商品类
class Item {
    private String name;
    private double price;

    public Item(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public String getName() { return name; }
    public double getPrice() { return price; }
}
```

## 另一个实际示例：文件压缩策略

```java
// 压缩策略接口
interface CompressionStrategy {
    void compressFiles(List<String> files);
}

// ZIP压缩
class ZipCompression implements CompressionStrategy {
    @Override
    public void compressFiles(List<String> files) {
        System.out.println("使用ZIP格式压缩文件:");
        for (String file : files) {
            System.out.println("压缩: " + file);
        }
    }
}

// RAR压缩
class RarCompression implements CompressionStrategy {
    @Override
    public void compressFiles(List<String> files) {
        System.out.println("使用RAR格式压缩文件:");
        for (String file : files) {
            System.out.println("压缩: " + file);
        }
    }
}

// 7Z压缩
class SevenZCompression implements CompressionStrategy {
    @Override
    public void compressFiles(List<String> files) {
        System.out.println("使用7Z格式压缩文件:");
        for (String file : files) {
            System.out.println("压缩: " + file);
        }
    }
}

// 压缩管理器
class CompressionManager {
    private CompressionStrategy strategy;

    public void setCompressionStrategy(CompressionStrategy strategy) {
        this.strategy = strategy;
    }

    public void createArchive(List<String> files) {
        if (strategy == null) {
            throw new IllegalStateException("未设置压缩策略");
        }
        strategy.compressFiles(files);
    }
}

// 使用示例
class CompressionExample {
    public static void main(String[] args) {
        List<String> files = Arrays.asList(
            "file1.txt",
            "file2.pdf",
            "file3.jpg"
        );

        CompressionManager cm = new CompressionManager();

        // 使用ZIP压缩
        cm.setCompressionStrategy(new ZipCompression());
        cm.createArchive(files);

        // 使用RAR压缩
        cm.setCompressionStrategy(new RarCompression());
        cm.createArchive(files);

        // 使用7Z压缩
        cm.setCompressionStrategy(new SevenZCompression());
        cm.createArchive(files);
    }
}
```

## 优点

1. 算法可以自由切换，避免使用多重条件判断
2. 扩展性良好，增加新的策略很方便
3. 策略类之间可以自由替换
4. 客户端代码只需要知道策略接口，不需要了解具体实现

## 缺点

1. 客户端必须知道所有的策略类，并自行决定使用哪一个策略类
2. 策略模式会造成很多的策略类
3. 所有策略类都需要对外暴露

## 适用场景

1. 系统需要动态地在几种算法中选择一种
2. 系统中有一些类仅仅是行为不同的类
3. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现

## 注意事项

1. 注意策略类的创建时机和方式
2. 避免暴露太多的策略细节给客户端
3. 考虑使用简单工厂来创建策略对象
4. 注意策略模式与其他模式的结合使用

