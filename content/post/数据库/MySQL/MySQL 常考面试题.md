---
title: "1 MySQL 常见面试题"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# 1 MySQL 常见面试题

## 1.1 MySQL 中有哪些锁类型？

从锁的粒度来分，MySQL 中主要有以下几种锁：

1. **全局锁**
   - 对整个数据库实例加锁
   - 典型使用场景：全库逻辑备份
   - 通过 `FLUSH TABLES WITH READ LOCK` 实现
   - 特点：整个数据库处于只读状态

2. **表级锁**
   - **表锁**：对整张表加锁
   - **元数据锁（MDL）**：防止表结构被修改
   - **意向锁**：为了支持表锁和行锁的共存

3. **行级锁**
   - **记录锁（Record Lock）**：锁定单个行记录
   - **间隙锁（Gap Lock）**：锁定一个范围
   - **临键锁（Next-key Lock）**：记录锁+间隙锁的组合

从锁的类型来分：
1. **共享锁（S锁）**：读锁，多个事务可以同时读
2. **排他锁（X锁）**：写锁，只允许一个事务写入

## 1.2 MySQL 的乐观锁和悲观锁是什么？

### 1.2.1 悲观锁
- **概念**：假设会发生并发冲突，屏蔽一切可能违反数据完整性的操作
- **实现方式**：
  ```sql
  -- 开始事务
  BEGIN;
  -- 查询时锁定记录
  SELECT * FROM table_name WHERE id = 1 FOR UPDATE;
  -- 更新操作
  UPDATE table_name SET column = value WHERE id = 1;
  -- 提交事务
  COMMIT;
  ```
- **适用场景**：
  - 并发写入多的场景
  - 强一致性要求的场景
  - 核心业务数据

### 1.2.2 乐观锁
- **概念**：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性
- **实现方式**：
  ```sql
  -- 通过版本号实现
  UPDATE table_name 
  SET column = new_value, version = version + 1 
  WHERE id = 1 AND version = old_version;
  ```
- **适用场景**：
  - 读多写少
  - 并发冲突较少
  - 性能要求高的场景

## 1.3 MySQL 中如果发生死锁应该如何解决？

### 1.3.1 死锁的产生原因
1. 多个事务在不同顺序访问资源
2. 事务之间循环依赖
3. 长事务的并发

### 1.3.2 解决方案
1. **预防策略**
   - 固定顺序访问资源
   - 避免长事务
   - 一次性锁定所需资源

2. **诊断方法**
   ```sql
   -- 查看当前锁等待情况
   SHOW ENGINE INNODB STATUS;
   
   -- 查看死锁日志
   SELECT * FROM information_schema.INNODB_TRX;
   ```

3. **处理方法**
   - 设置死锁超时参数
   - 死锁检测
   - 回滚代价小的事务

## 1.4 MySQL 中 count(*)、count(1) 和 count(字段名) 有什么区别？

### 1.4.1 执行效率
1. **count(*)**
   - MySQL 对其做了优化
   - 不会取值，只统计行数
   - 通常性能最好

2. **count(1)**
   - 扫描表但不取值
   - 性能几乎等同于 count(*)

3. **count(字段名)**
   - 需要取出字段值
   - 会忽略字段为 NULL 的行
   - 性能相对较差

### 1.4.2 使用建议
- 统计行数优先使用 count(*)
- 需要排除 NULL 值时使用 count(字段名)
- 避免使用 count(1)，无性能优势

## 1.5 MySQL 中如何进行 SQL 调优？

### 1.5.1 使用 EXPLAIN 分析执行计划
```sql
-- 使用 EXPLAIN 分析 SQL
EXPLAIN SELECT * FROM users WHERE age > 20;
```

### 1.5.2 索引优化
- 合理创建和使用索引
- 避免索引失效的情况：
  - 避免在索引列上使用函数
  - 避免隐式类型转换
  - 避免使用 != 或 <> 操作符
  - 避免使用 OR 连接条件

### 1.5.3 SQL语句优化
- 只查询需要的字段
- 避免 SELECT *
- 使用覆盖索引
- 合理使用子查询
- 使用 LIMIT 限制结果集

### 1.5.4 表结构优化
- 选择合适的数据类型
- 表的垂直拆分和水平拆分
- 适当冗余字段

### 1.5.5 配置优化
- 调整缓冲池大小
- 优化排序和连接缓冲区
- 合理设置并发连接数

### 1.5.6 定期维护
- 更新统计信息
- 定期清理碎片
- 适时优化表
```sql
-- 优化表
OPTIMIZE TABLE table_name;
```
