---
title: "RabbitMQ 性能优化"
date: 2023-01-01T01:01:01+08:00
categories: ["D:"]
tags: ["D:"]
draft: false
---
# RabbitMQ 性能优化

## 生产者优化

### 批量发送

#### 1. 合适的批次大小

```java
// 批量发送示例
List<String> messages = new ArrayList<>();
int batchSize = 100;

channel.confirmSelect(); // 启用发布确认
for (int i = 0; i < messages.size(); i++) {
    channel.basicPublish(exchange, routingKey, null, messages.get(i).getBytes());
    if ((i + 1) % batchSize == 0) {
        channel.waitForConfirmsOrDie(5_000); // 每100条消息确认一次
    }
}
```

#### 2. 批量发送超时设置

```java
// 设置批量发送超时时间
int timeout = 5000; // 5秒
channel.waitForConfirmsOrDie(timeout);
```

### 异步发送

#### 1. ConfirmCallback 处理

```java
// 异步确认示例
ConcurrentNavigableMap<Long, String> outstandingConfirms = new ConcurrentSkipListMap<>();

channel.confirmSelect();
channel.addConfirmListener((sequenceNumber, multiple) -> {
    // 确认成功回调
    if (multiple) {
        ConcurrentNavigableMap<Long, String> confirmed = outstandingConfirms.headMap(
                sequenceNumber, true
        );
        confirmed.clear();
    } else {
        outstandingConfirms.remove(sequenceNumber);
    }
}, (sequenceNumber, multiple) -> {
    // 确认失败回调
    String message = outstandingConfirms.get(sequenceNumber);
    // 重发消息逻辑
});
```

#### 2. ReturnCallback 处理

```java
// 处理无法路由的消息
channel.addReturnListener((replyCode, replyText, exchange, routingKey, properties, body) -> {
    // 处理无法路由的消息
    String message = new String(body);
    // 重发或记录日志
});
```

### 合理配置 Channel

#### 1. Channel 复用

```java
// 使用 Channel 池
public class ChannelPool {
    private final Connection connection;
    private final BlockingQueue<Channel> pool;

    public ChannelPool(Connection connection, int poolSize) {
        this.connection = connection;
        this.pool = new ArrayBlockingQueue<>(poolSize);
        for (int i = 0; i < poolSize; i++) {
            pool.offer(connection.createChannel());
        }
    }

    public Channel getChannel() throws Exception {
        return pool.take();
    }

    public void returnChannel(Channel channel) {
        pool.offer(channel);
    }
}
```

#### 2. 并发数量控制

```java
// 控制 Channel 并发数
int maxChannels = Runtime.getRuntime().availableProcessors() * 2;
ConnectionFactory factory = new ConnectionFactory();
factory.setChannelMax(maxChannels);
```

## 消费者优化

### 合理的 prefetch 数量

#### 1. 消费者处理能力评估

```java
// 根据消费者处理能力设置 prefetch
int prefetchCount = 10; // 根据实际处理能力调整
channel.basicQos(prefetchCount);
```

#### 2. prefetch 动态调整

```java
// 动态调整 prefetch
public void adjustPrefetch(int currentLoad) {
    int newPrefetch;
    if (currentLoad > 80) {
        newPrefetch = channel.getBasicQos() / 2;
    } else if (currentLoad < 30) {
        newPrefetch = channel.getBasicQos() * 2;
    }
    channel.basicQos(newPrefetch);
}
```

### 批量确认

#### 1. 批量大小设置

```java
// 批量确认示例
int batchSize = 100;
AtomicInteger processedCount = new AtomicInteger();

channel.basicConsume(queueName, false, (consumerTag, delivery) -> {
    // 处理消息
    if (processedCount.incrementAndGet() % batchSize == 0) {
        channel.basicAck(delivery.getEnvelope().getDeliveryTag(), true);
    }
}, consumerTag -> {});
```

### 并发消费

#### 1. 多线程消费

```java
// 多线程消费示例
public class ConcurrentConsumer {
    private final ExecutorService executorService;
    private final int threadCount;

    public ConcurrentConsumer(int threadCount) {
        this.threadCount = threadCount;
        this.executorService = Executors.newFixedThreadPool(threadCount);
    }

    public void startConsume(Channel channel, String queueName) {
        for (int i = 0; i < threadCount; i++) {
            executorService.submit(() -> {
                channel.basicConsume(queueName, false, (consumerTag, delivery) -> {
                    // 处理消息
                    channel.basicAck(delivery.getEnvelope().getDeliveryTag(), false);
                }, consumerTag -> {});
            });
        }
    }
}
```

## 队列优化

### 队列数量控制

#### 1. 队列数量限制

```java
// 设置队列数量限制
rabbitmqctl set_vhost_limits / '{"max-queues": 1000}'
```

#### 2. 队列命名规范

```java
// 使用规范的队列命名
String queueName = String.format("%s.%s.%s",
    businessType, messageType, priority);
```

### 消息大小控制

#### 1. 消息体积优化

```java
// 压缩消息内容
byte[] compressed = compress(message.getBytes());
channel.basicPublish(exchange, routingKey, null, compressed);

// 接收时解压
channel.basicConsume(queueName, false, (consumerTag, delivery) -> {
    byte[] decompressed = decompress(delivery.getBody());
    // 处理消息
}, consumerTag -> {});
```

#### 2. 大消息处理策略

```java
// 大消息处理示例
public void handleLargeMessage(byte[] message) {
    if (message.length > MAX_MESSAGE_SIZE) {
        // 存储到外部存储（如S3）
        String reference = uploadToExternalStorage(message);
        // 发送消息引用
        channel.basicPublish(exchange, routingKey, null, reference.getBytes());
    } else {
        // 直接发送消息
        channel.basicPublish(exchange, routingKey, null, message);
    }
}
```

### TTL 设置

#### 1. 消息 TTL

```java
// 设置消息 TTL
AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()
    .expiration("60000") // 60秒
    .build();
channel.basicPublish(exchange, routingKey, properties, message.getBytes());
```

#### 2. 队列 TTL

```java
// 设置队列 TTL
Map<String, Object> args = new HashMap<>();
args.put("x-message-ttl", 60000); // 60秒
channel.queueDeclare(queueName, true, false, false, args);
```

## 系统配置优化

### 内存优化

```bash
# 设置内存限制
rabbitmqctl set_vm_memory_high_watermark 0.4

# 设置空闲内存阈值
rabbitmqctl set_vm_memory_high_watermark_paging_ratio 0.5
```

### 磁盘优化

```bash
# 设置磁盘空间限制
rabbitmqctl set_disk_free_limit 2GB

# 设置持久化写入策略
rabbitmqctl set_parameter policy_name '{"queue-mode":"lazy"}'
```

### 网络优化

```bash
# 设置心跳间隔
rabbitmqctl set_parameter heartbeat 60

# 设置连接超时
rabbitmqctl set_parameter connection_timeout 60000
```

